

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://img1.baidu.com/it/u=4218313265,1883370397&amp;fm=26&amp;fmt=auto">
  <link rel="icon" href="https://img1.baidu.com/it/u=4218313265,1883370397&amp;fm=26&amp;fmt=auto">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="析构、拷贝构造、拷贝赋值、移动构造、移动赋值">
  <meta name="author" content="wuyifff">
  <meta name="keywords" content="">
  <meta name="description" content="析构、拷贝构造、拷贝赋值、移动构造、移动赋值">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ primer 读书笔记 chapter 13 拷贝控制">
<meta property="og:url" content="https://wuyifff.github.io/2021/10/25/c++/13.%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/index.html">
<meta property="og:site_name" content="wuyifff&#39;s blog">
<meta property="og:description" content="析构、拷贝构造、拷贝赋值、移动构造、移动赋值">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-10-25T11:47:42.009Z">
<meta property="article:modified_time" content="2021-10-25T11:49:42.159Z">
<meta property="article:author" content="wuyifff">
<meta name="twitter:card" content="summary_large_image">
  
  <title>C++ primer 读书笔记 chapter 13 拷贝控制 - wuyifff&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"wuyifff.github.io","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":" ","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="wuyifff's blog" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>wuyifff&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://img0.baidu.com/it/u=336294190,1675821935&fm=26&fmt=auto') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="C++ primer 读书笔记 chapter 13 拷贝控制">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      wuyifff
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-10-25 19:47" pubdate>
        2021年10月25日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      12k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      39 分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span>
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C++ primer 读书笔记 chapter 13 拷贝控制</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2021年10月25日 晚上
                
              </p>
            
            <div class="markdown-body">
              <h1 id="C-primer-chapter-13"><a href="#C-primer-chapter-13" class="headerlink" title="C++ primer chapter 13"></a>C++ primer chapter 13</h1><h1 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h1><p>定义一个类，会显式或隐式指定此类型的对象拷贝、移动、赋值和销毁时做什么。类通过定义五种特殊的成员函数来控制这些操作，包括：<strong>拷贝构造函数</strong>（copy constructor）、<strong>拷贝赋值运算</strong>符（copy-assignment operator）、<strong>移动构造函数</strong>（move constructor）、移动赋值运算符（move-assignment operator）和<strong>析构函数</strong>（destructor）。</p>
<h2 id="拷贝、赋值与销毁"><a href="#拷贝、赋值与销毁" class="headerlink" title="拷贝、赋值与销毁"></a>拷贝、赋值与销毁</h2><p>移动语义是C++11新引入的</p>
<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>仅有一个参数为自身类类型引用的构造函数就是拷贝构造函数，形如：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Foo</span>();				<span class="hljs-comment">//默认构造函数</span><br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-keyword">const</span> Foo&amp;);	<span class="hljs-comment">//拷贝构造函数</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>该参数==必须是引用类型==，一般是const引用。由于拷贝构造函数会在几种情况下<strong>隐式地调用</strong>，所以一般不是explicit。</p>
<p>如果自己不定义，编译器就会<strong>合成</strong>一个默认的、合成的拷贝构造函数会把参数成员逐个拷贝到正在创建的对象中（非static成员）。</p>
<p>成员的类型决定了拷贝的方式：类类型的成员会用它自己的拷贝构造函数来拷贝；内置类型则直接值拷贝。数组会逐个复制，如果数组成员是类类型，会逐个调用成员本身的拷贝构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sales_data</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Sales_data</span>(<span class="hljs-keyword">const</span> Sales_data&amp;);<br><span class="hljs-keyword">private</span>:<br>    std::string bookNo;<br>    <span class="hljs-keyword">int</span> units_sold = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">double</span> revenue = <span class="hljs-number">0.0</span>;<br>&#125;;<br><br><span class="hljs-comment">//与Sales_data的合成拷贝构造函数等价</span><br>Sales_data::<span class="hljs-built_in">Sales_data</span>(<span class="hljs-keyword">const</span> Sales_data &amp;orig) : <br>	<span class="hljs-built_in">bookNo</span>(orig.bookNo), <span class="hljs-comment">//使用string的拷贝构造函数</span><br>	<span class="hljs-built_in">units_sold</span>(orig.units_sold),	<span class="hljs-comment">//拷贝orig.units_sold</span><br>	<span class="hljs-built_in">revenue</span>(orig.revenue)	<span class="hljs-comment">//拷贝orig.revenue</span><br>    &#123;&#125;	<span class="hljs-comment">//空函数体</span><br></code></pre></div></td></tr></table></figure>

<h4 id="拷贝初始化"><a href="#拷贝初始化" class="headerlink" title="拷贝初始化"></a>拷贝初始化</h4><p>拷贝初始化和直接初始化的差异：</p>
<p>直接初始化：==普通的函数匹配==</p>
<p>拷贝初始化：==类型转换==</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">dots</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;,&#x27;</span>)</span></span>;	<span class="hljs-comment">//直接初始化</span><br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(dots)</span></span>;			<span class="hljs-comment">//直接初始化</span><br>string s2 = dots;		<span class="hljs-comment">//拷贝初始化</span><br>string null_book = <span class="hljs-string">&quot;9-999-99999-9&quot;</span>;	<span class="hljs-comment">//拷贝初始化</span><br>string nines = <span class="hljs-built_in">string</span>(<span class="hljs-number">100</span>, <span class="hljs-string">&#x27;9&#x27;</span>);	<span class="hljs-comment">//拷贝初始化</span><br></code></pre></div></td></tr></table></figure>

<p>拷贝初始化<strong>一般</strong>由拷贝构造函数完成，之所以说一般是因为移动语义的引入，导致如果类由移动构造函数时，拷贝初始化<strong>有时</strong>会使用移动构造函数而非拷贝构造函数。</p>
<p>拷贝初始化<strong>不仅在用=定义变量</strong>时发生，在下列情形也会发生：</p>
<ul>
<li>将一个对象作为实参传递给一个非引用类型的形参</li>
<li>从一个返回类型为非引用类型的函数返回一个对象</li>
<li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</li>
</ul>
<p>某些类类型还会对它们所分配的对象使用拷贝初始化。如初始化标准库容器或调用其insert或push成员时，容器会对其元素进行<strong>拷贝初始化</strong>。而emplace创建的元素都是<strong>直接初始化</strong>。</p>
<h4 id="参数和返回值"><a href="#参数和返回值" class="headerlink" title="参数和返回值"></a>参数和返回值</h4><p>拷贝构造函数被用来<strong>初始化非引用类类型参数</strong>，所以拷贝构造函数自身的参数必须是引用类型。不然的话，就二者矛盾而无限循环了。</p>
<blockquote>
<p>如果可以不是引用类型，为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数。（套娃）</p>
</blockquote>
<h4 id="拷贝初始化的限制"><a href="#拷贝初始化的限制" class="headerlink" title="拷贝初始化的限制"></a>拷贝初始化的限制</h4><p>构造函数为explicit类型，拷贝初始化只能是直接初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">vector&lt;<span class="hljs-keyword">int</span>&gt; v1 <span class="hljs-number">10</span>;		<span class="hljs-comment">//正确，直接初始化</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; v2 = <span class="hljs-number">10</span>;	<span class="hljs-comment">//错误，vector接受大小的构造函数是explicit的</span><br><span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-built_in">f</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;));	<span class="hljs-comment">//f的参数进行拷贝初始化</span><br><span class="hljs-built_in">f</span>(<span class="hljs-number">10</span>);					<span class="hljs-comment">//错误，不能用一个explicit的构造函数拷贝一个实参</span><br><span class="hljs-built_in">f</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">10</span>));		<span class="hljs-comment">//正确，从一个int直接构造一个临时vector</span><br></code></pre></div></td></tr></table></figure>

<p>对于explicit的构造函数，我们不能隐式的使用它（如第4行），必须显式的使用（如第5行）。</p>
<h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">Sales_data trans, accum;<br>trans = accum;	<span class="hljs-comment">//使用Sales_data的拷贝赋值运算符</span><br></code></pre></div></td></tr></table></figure>

<p>如果类未定义，编译器会合成一个。</p>
<p>这个函数的定义涉及了重载运算符的概念，这里重载的是赋值运算符（ 即 = ）。</p>
<p>重载运算符本质上是函数，名字由operator关键字接要定义的运算符符号组成。所以，赋值运算符就<strong>对应operator=的函数</strong>。</p>
<p>重载运算符的参数表示运算符的运算对象，某些运算符包括赋值必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就<strong>绑定到隐式的this参数</strong>。对一个二元运算符，例如赋值运算符，右侧运算对象作为显式参数传递。</p>
<p>拷贝赋值运算符接受一个与其所在类相同类型的参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    Foo&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Foo&amp;);	<span class="hljs-comment">//赋值运算符</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>为了与内置类型的赋值保持一直，赋值运算符通常<strong>返回一个指向其左侧运算对象的引用</strong>。另外，<strong>标准库通常要求保存在容器中的类型具有赋值运算符，且返回值是左侧运算符对象的引用</strong>。</p>
<p>编译器合成的拷贝赋值运算符类似拷贝构造，也是逐一进行成员拷贝（非static），类类型通过它自身的拷贝赋值运算符来完成，数组成员为类类型的，也会逐一调用自身的拷贝赋值运算符。最后，返回一个指向左侧运算对象的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//该函数等价于合成的拷贝赋值运算符</span><br>Sales_data&amp; Sales_data::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Sales_data &amp;rhs)<br>&#123;<br>    bookNo = rhs.bookNo;	<span class="hljs-comment">//调用string::operator=</span><br>    units_sold = rhs.units_sold;	<span class="hljs-comment">//使用内置的int赋值</span><br>    revenue = rhs.revenue;	<span class="hljs-comment">//使用内置的double赋值</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;	<span class="hljs-comment">//返回左侧对象的引用</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>与构造执行的操作相反。</p>
<p>析构函数名字比构造函数多了一个**~**。没有返回值，也没有参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Foo</span>();	<span class="hljs-comment">//析构函数</span><br>    ...<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>析构函数不能被重载（因为它也不接受参数），是惟一的。</p>
<p>调用析构的时机：</p>
<ul>
<li>变量在<strong>离开作用域</strong>时被销毁</li>
<li>当一个对象被销毁时，其<strong>成员</strong>被销毁</li>
<li><strong>容器被销毁</strong>时（标准库容器或数组），其元素被销毁</li>
<li>动态分配的对象，当对指向它的指针应用<strong>delete</strong>时被销毁</li>
<li><strong>临时对象</strong>，当创建它的完整表达式结束时被销毁</li>
</ul>
<blockquote>
<p>隐式的销毁一个内置指针类型的成员不会delete它所指向的对象</p>
</blockquote>
<p>与普通指针不同,<strong>智能指针</strong>是<strong>类类型</strong>,所以<strong>具有析构函数</strong>,在析构时会<strong>被自动销毁</strong>.</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">&#123;<span class="hljs-comment">//新作用域</span><br>    <span class="hljs-comment">//p和p2指向动态分配对象</span><br>    Sales_data *p = <span class="hljs-keyword">new</span> Sales_data;<span class="hljs-comment">//p是一个内置指针</span><br>    <span class="hljs-keyword">auto</span> p2 = make_shared&lt;Sales_data&gt;();	<span class="hljs-comment">//p2是一个shared_ptr</span><br>    <span class="hljs-function">Sales_data <span class="hljs-title">item</span><span class="hljs-params">(*p)</span></span>;	<span class="hljs-comment">//拷贝构造函数将*p拷贝到item中</span><br>    vector&lt;Sales_data&gt; vec;	<span class="hljs-comment">//局部对象</span><br>    vec.<span class="hljs-built_in">push_back</span>(*p2);		<span class="hljs-comment">//拷贝p2指向的对象</span><br>    <span class="hljs-keyword">delete</span> p;				<span class="hljs-comment">//对p指向的对象执行析构函数</span><br>&#125;<span class="hljs-comment">//退出局部作用域；对item、p2和vec调用析构函数</span><br><span class="hljs-comment">//销毁p2会递减其引用计数；如果引用计数变为0，则对象释放</span><br><span class="hljs-comment">//销毁vec会销毁它的元素</span><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>当指向一个对象的应用或指针离开作用域时,析构函数不会执行</p>
</blockquote>
<p>如果类未定义析构，则编译器会自动合成(合成析构函数)。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sales_data</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//成员会被自动销毁，除此之外不需要做其他事情</span><br>    ~<span class="hljs-built_in">Sales_data</span>()&#123;&#125;<br>    <span class="hljs-comment">//其他成员的定义</span><br>    ...<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>析构函数体（空）执行完毕后，成员会被自动销毁。本例中string的析构函数会被调用，释放bookNo的内存。<strong>析构函数体本身不直接销毁成员</strong>，它们是==<strong>在函数体之后隐含的析构阶段中被销毁</strong>==的。析构函数体只是析构过程的一部分。</p>
<h3 id="三五法则"><a href="#三五法则" class="headerlink" title="三五法则"></a>三五法则</h3><h4 id="需要析构函数的类也需要拷贝和赋值操作"><a href="#需要析构函数的类也需要拷贝和赋值操作" class="headerlink" title="需要析构函数的类也需要拷贝和赋值操作"></a>需要析构函数的类也需要拷贝和赋值操作</h4><p>因为析构函数需要去手工delete成员指针。这种情况下，<strong>编译器合成的拷贝构造和赋值运算符就会有问题，因为仅仅只是完成了浅拷贝</strong>，拷贝了成员指针的地址值（指向同一个对象），这可能引起问题。所以这种情况我们要自己写深拷贝代码。</p>
<h4 id="需要拷贝操作的类也需要赋值操作，反之亦然"><a href="#需要拷贝操作的类也需要赋值操作，反之亦然" class="headerlink" title="需要拷贝操作的类也需要赋值操作，反之亦然"></a>需要拷贝操作的类也需要赋值操作，反之亦然</h4><p>因为<strong>语义上拷贝构造和赋值操作是一致的</strong>，只是调用时机不同。提供了一个就说明需要特化某些操作，那么对应的另一个也要一致。但需要二者却不一定需要一个析构。</p>
<h3 id="default"><a href="#default" class="headerlink" title="=default"></a>=default</h3><p>=default可以显式地要求编译器生成合成的版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sales_data</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Sales_data</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Sales_data</span>(<span class="hljs-keyword">const</span> Sales_data&amp;) = <span class="hljs-keyword">default</span>;<br>    Sales_data &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Sales_data &amp;);<br>    ~<span class="hljs-built_in">Sales_data</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-comment">//其他成员</span><br>    ...<br>&#125;;<br>Sales_data &amp;Sales_data::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Sales_data&amp;) = <span class="hljs-keyword">default</span>;<br></code></pre></div></td></tr></table></figure>

<p>类内使用=default声明，合成的函数会隐式地声明为inline。</p>
<h3 id="delete"><a href="#delete" class="headerlink" title="=delete"></a>=delete</h3><p>有些情况我们希望阻止类的拷贝或赋值。比如iostream就阻止了拷贝，避免多个对象写入或读取相同的IO缓冲。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NoCopy</span>&#123;</span><br>    <span class="hljs-built_in">NoCopy</span>() = <span class="hljs-keyword">default</span>;	<span class="hljs-comment">//合成的默认构造函数</span><br>    <span class="hljs-built_in">NoCopy</span>(<span class="hljs-keyword">const</span> NoCopy&amp;) = <span class="hljs-keyword">delete</span>;	<span class="hljs-comment">//阻止拷贝</span><br>    NoCopy&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> NoCopy&amp;) = <span class="hljs-keyword">delete</span>;	<span class="hljs-comment">//阻止赋值</span><br>    ~<span class="hljs-built_in">NoCopy</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p><strong>=delete通知编译器</strong>，不希望定义这些成员。</p>
<p>注意，<strong>析构函数不能删除，其他任何函数都可以指定=delete</strong>。虽然语法上允许析构函数指定=delete，但这样一来涉及到该类的对象都不能用，因为它无法销毁。</p>
<p>所以，记着析构函数不能加=delete这条软规则即可。</p>
<p>如果一个类有某个数据成员不能默认构造、拷贝、复制或销毁，那么对应的成员函数将被定义为删除的。</p>
<p>具有引用成员或无法默认构造的const成员的类，编译器不会合成默认构造函数。如果类有const成员，则它不能使用合成的拷贝赋值运算符（新值是不能给const对象的）。</p>
<p>在没有=delete之前，C++是通过private权限限制拷贝构造函数和拷贝赋值运算符来阻止拷贝的。这种方法有一个疏漏，就是友元函数和成员函数是可以进行拷贝的。</p>
<p>与 = default 不同， = delete 必须出现在函数第一次声明的时候，这个差异与这些声明的含义在逻辑上是吻合的，默认成员只影响为这个成员生成的代码，因此 = default 直到编译器生成代码时才需要。而对于被删除的函数，编译器需要一开始就直到，以便禁止试图使用它的操作。</p>
<blockquote>
<p>希望组织拷贝的类应该使用 = delete 来定义自己的拷贝构造函数和拷贝赋值运算符，而不是将他们声明为private的，如  <code>NoCopy(const NoCopy&amp;) = delete;</code></p>
</blockquote>
<h2 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a>拷贝控制和资源管理</h2><p>类一旦管理了类外资源，往往就需要自定义析构，根据三五法则也就意味着要自定义拷贝构造和拷贝赋值运算符。</p>
<p>而定义拷贝控制成员时，首先要确定类的拷贝语义，我们是让类的行为看起来像值还是像指针。</p>
<ul>
<li>如果是像值，比如string、标准库容器类等，它们的拷贝会使得副本对象和原对象完全独立，改变副本不会影响原对象。</li>
<li>如果是像指针，比如shared_ptr，那么拷贝的就是指针，指向的是同一个对象。</li>
<li>当然，也可以设置为不允许拷贝或赋值，此时既不像值也不像指针。</li>
</ul>
<h3 id="行为像值的类"><a href="#行为像值的类" class="headerlink" title="行为像值的类"></a>行为像值的类</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HasPtr</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  	<span class="hljs-built_in">HasPtr</span>(<span class="hljs-keyword">const</span> std::string &amp;s = std::<span class="hljs-built_in">string</span>()):<span class="hljs-built_in">ps</span>(<span class="hljs-keyword">new</span> std::<span class="hljs-built_in">string</span>(s)), <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>)&#123;&#125;<br>  	<span class="hljs-comment">//对ps指向的string，每个HasPtr对象都有自己的拷贝</span><br>  	<span class="hljs-built_in">HasPtr</span>(<span class="hljs-keyword">const</span> HasPtr &amp;p):<span class="hljs-built_in">ps</span>(<span class="hljs-keyword">new</span> std::<span class="hljs-built_in">string</span>(*p.ps)), <span class="hljs-built_in">i</span>(p.i)&#123;&#125;<br>  	HasPtr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> HasPtr &amp;);<br>  	~<span class="hljs-built_in">HasPtr</span>()&#123;<span class="hljs-keyword">delete</span> ps;&#125;<br><span class="hljs-keyword">private</span>:<br>  	std::string *ps;<br>  	<span class="hljs-keyword">int</span> i;<br>&#125;;<br><br>HasPtr&amp; HasPtr::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> HasPtr &amp;rhs)<br>&#123;<br>  	<span class="hljs-comment">//这里一定要先new再delete，因为赋值操作赋值给自己是合法的</span><br>  	<span class="hljs-comment">//如果赋值给自己，先delete意味着rhs.ps就丢了</span><br>    <span class="hljs-keyword">auto</span> newp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(*rhs.ps);	<span class="hljs-comment">//拷贝底层string</span><br>  	<span class="hljs-keyword">delete</span> ps;	<span class="hljs-comment">//释放旧内存</span><br>  	ps = newp;	<span class="hljs-comment">//从右侧运算对象拷贝数据到本对象</span><br>  	i = rhs.i;<br>  	<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;	<span class="hljs-comment">//返回本对象</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>赋值运算符要谨记一个好习惯，在销毁左侧运算对象资源之前先拷贝右侧运算对象资源。</p>
</blockquote>
<h3 id="行为像指针的类"><a href="#行为像指针的类" class="headerlink" title="行为像指针的类"></a>行为像指针的类</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HasPtr</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  	<span class="hljs-comment">//构造函数分配新的string和新的计数器，将计数器置为1</span><br>  	<span class="hljs-built_in">HasPtr</span>(<span class="hljs-keyword">const</span> std::string &amp;s = std::<span class="hljs-built_in">string</span>()):<span class="hljs-built_in">ps</span>(<span class="hljs-keyword">new</span> std::<span class="hljs-built_in">string</span>(s)), <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">use</span>(<span class="hljs-keyword">new</span> std::<span class="hljs-built_in">size_t</span>(<span class="hljs-number">1</span>))&#123;&#125;<br>  	<span class="hljs-comment">//拷贝构造函数拷贝所有3个数据成员，并递增计数器</span><br>  	<span class="hljs-built_in">HasPtr</span>(<span class="hljs-keyword">const</span> HasPtr &amp;p):<span class="hljs-built_in">ps</span>(p.ps), <span class="hljs-built_in">i</span>(p.i), <span class="hljs-built_in">use</span>(p.use)&#123;++*use;&#125;<br>  	HasPtr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> HasPtr&amp;);<br>  	~<span class="hljs-built_in">HasPtr</span>();<br><span class="hljs-keyword">private</span>:<br>  	std::string *ps;<br>  	<span class="hljs-keyword">int</span> i;<br>  	std::<span class="hljs-keyword">size_t</span> *use;	<span class="hljs-comment">//用来记录有多少个对象共享*ps的成员</span><br>&#125;;<br><br>HasPtr::~<span class="hljs-built_in">HasPtr</span>()<br>&#123;<br>    <span class="hljs-keyword">if</span>(--*use == <span class="hljs-number">0</span>)&#123;	<span class="hljs-comment">//如果引用计数变为0</span><br>        <span class="hljs-keyword">delete</span> ps;		<span class="hljs-comment">//释放string内存</span><br>      	<span class="hljs-keyword">delete</span> use;		<span class="hljs-comment">//释放计数器内存</span><br>    &#125;<br>&#125;<br><br>HasPtr&amp; HasPtr::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> HasPtr &amp;rhs)<br>&#123;<br>    ++*rhs.use;	<span class="hljs-comment">//递增右侧运算对象的引用计数</span><br>  	<span class="hljs-keyword">if</span>(--*use == <span class="hljs-number">0</span>)&#123;	<span class="hljs-comment">//然后递减本对象的引用计数</span><br>        <span class="hljs-keyword">delete</span> ps;		<span class="hljs-comment">//如果没有其他用户</span><br>      	<span class="hljs-keyword">delete</span> use;		<span class="hljs-comment">//释放本对象分配的成员</span><br>    &#125;<br>  	ps = rhs.ps;	<span class="hljs-comment">//将数据从rhs拷贝到本对象</span><br>  	i = rhs.i;<br>  	use = rhs.use;<br>  	<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;	<span class="hljs-comment">//返回本对象</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>赋值运算符要考虑自赋值的情况，所以在左侧递减引用计数之前先递增右侧引用计数。</p>
<h2 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a>交换操作</h2><p>除了拷贝控制成员外，管理资源的类一般还定义一个swap函数。对与重排元素顺序的算法一起使用的类来说，swap非常重要，因为这些算法交换两个元素时会调用swap。</p>
<p>如果类自己定义了swap，算法就使用自定义版本，否则使用标准库定义的swap。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HasPtr</span>&#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(HasPtr&amp;, HasPtr&amp;)</span></span>;<br>  	<span class="hljs-comment">//其他成员定义</span><br>  	...<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(HasPtr &amp;lhs, HasPtr &amp;rhs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> std::swap;<br>  	<span class="hljs-built_in">swap</span>(lhs.ps, rhs.ps);	<span class="hljs-comment">// 交换指针，而不是string数据</span><br>  	<span class="hljs-built_in">swap</span>(lhs.i, rhs.i);		<span class="hljs-comment">// 交换int成员</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>swap不是必要的，但对分配了资源的类来说，定义swap是一种很重要的优化手段。</p>
<p>swap定义的一个坑：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//Foo有类型为HasPtr的成员h</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Foo &amp;lhs, Foo &amp;rhs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//错误：这个函数使用了标准库版本的swap，而不是HasPtr版本</span><br>  	std::<span class="hljs-built_in">swap</span>(lhs.h, rhs.h);<br>  	<span class="hljs-comment">// 交换类型Foo的其他成员</span><br>&#125;<br><br><span class="hljs-comment">//正确的写法：</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Foo &amp;lhs, Foo &amp;rhs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> std::swap;<br>  	<span class="hljs-built_in">swap</span>(lhs.h, rhs.h);	<span class="hljs-comment">//使用HasPtr版本的swap</span><br>  	<span class="hljs-comment">//交换类型Foo的其他成员</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>这种未加限定的写法之所以可行，本质上是因为类型特定的swap版本匹配程度优于声明的std::swap版本。而对std::swap的声明可以使得在找不到类型特定版本时可以正确的找到std中的版本。</p>
<p>swap常用于赋值运算符，它可以一步到位完成拷贝并交换的技术。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//注意rhs是按值传递的，意味着HasPtr的拷贝构造函数将右侧运算对象中的string拷贝到rhs</span><br>HasPtr&amp; HasPtr::<span class="hljs-keyword">operator</span>=(HasPtr rhs)<br>&#123;<br>    <span class="hljs-comment">//交换左侧运算对象和局部变量rhs的内容</span><br>  	<span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>, rhs);	<span class="hljs-comment">//rhs现在指向本对象曾经使用的内存</span><br>  	<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;	<span class="hljs-comment">//rhs被销毁，从而delete了rhs中的指针</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>这里的参数不是引用，右侧运算对象是值传递，所以rhs<strong>是右侧运算对象的副本</strong>。因此直接swap就一步到位了，自动销毁rhs时就自动销毁了原对象（执行析构）。</p>
<p><strong>使用拷贝和交换的赋值运算符天生异常安全，且能正确处理自赋值。</strong></p>
<h2 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h2><p>C++11引入了一个特性：可以移动而非拷贝对象。移动而非拷贝对象会大幅度提升性能。</p>
<p>旧版本即使在不必拷贝对象的情况下，也不得不拷贝，对象如果巨大，那么拷贝的代价是昂贵的。在旧版本的标准库中，容器所能保存的类型必须是可拷贝的。但在新标准中，可以用容器保存不可拷贝，但可移动的类型。</p>
<p>标准库容器、string和shared_ptr类既支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝。</p>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>为了支持移动操作，C++11引入了一个新的引用类型——右值引用(rvalue reference)。所谓右值引用就是必须绑定到右值的引用。通过&amp;&amp;来获得右值引用（左值引用是通过&amp;）。<strong>右值引用只能绑定到一个将要销毁的对象。</strong>因此，才得以自由地将一个右值引用的资源转移给另一个对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;	<br><span class="hljs-keyword">int</span> &amp;r = i;		<span class="hljs-comment">//正确：r引用i，r是左值引用</span><br><span class="hljs-keyword">int</span> &amp;&amp;rr = i;	<span class="hljs-comment">//错误：右值引用不能绑定到左值上</span><br><span class="hljs-keyword">int</span> &amp;r2 = i*<span class="hljs-number">42</span>;	<span class="hljs-comment">//错误：i*42是右值</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r3 = i*<span class="hljs-number">42</span>;	<span class="hljs-comment">//正确：可以将一个const引用绑定到一个右值上</span><br><span class="hljs-keyword">int</span> &amp;&amp;rr2 = i*<span class="hljs-number">42</span>;	<span class="hljs-comment">//正确：将rr2绑定到乘法结果上</span><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>最特别的就是const左值引用是可以绑定到右值的。</p>
</blockquote>
<p>变量表达式都是左值，所以不能将一个右值引用直接绑定到一个变量上，即使这个变量的类型是右值引用也不行。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> &amp;&amp;rr1 = <span class="hljs-number">42</span>;		<span class="hljs-comment">//正确：字面常量是右值</span><br><span class="hljs-keyword">int</span> &amp;&amp;rr2 = rr1;	<span class="hljs-comment">//错误：表达式rr1是左值</span><br></code></pre></div></td></tr></table></figure>

<p><strong>左值是持久的，右值是短暂的</strong>。</p>
<h3 id="标准库move函数"><a href="#标准库move函数" class="headerlink" title="标准库move函数"></a>标准库move函数</h3><p>虽然右值引用不能绑定到左值，但可以<strong>显式地将左值转换为对应的右值引用类型</strong>。调用<code>move</code>函数可以获得绑定在左值上的右值引用，此函数定义在头文件utility中。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> &amp;&amp;rr3 = std::<span class="hljs-built_in">move</span>(rr1);	<span class="hljs-comment">//正确</span><br></code></pre></div></td></tr></table></figure>

<p>move告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。<strong>但使用move就意味着承诺：除了对rr1赋值或销毁它外，我们将不再使用它。</strong></p>
<p>可以销毁一个移后源对象，也可以赋予它新值，但不能使用移后源对象的值。</p>
<p><strong>调用move函数的代码应该使用std::move而非move，这样做可以避免潜在的名字冲突。</strong></p>
<h3 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h3><p>移动构造函数类似拷贝构造，第一个参数是该类类型的引用。不同于拷贝构造函数，这个引用参数在移动构造函数中是一个右值引用。其他任何额外参数都必须有默认值（与拷贝构造一致）。</p>
<p>除了完成资源移动，移动构造函数还要保证移后源对象处于一个状态：销毁它是无害的。移动之后，源对象必须不再指向被移动的资源，这些资源归新对象所有。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">StrVec::<span class="hljs-built_in">StrVec</span>(StrVec &amp;&amp;s) <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//移动构造不应该抛任何异常</span><br>  <span class="hljs-comment">//成员初始化器接管s中资源</span><br>  : <span class="hljs-built_in">elements</span>(s.elements), <span class="hljs-built_in">first_free</span>(s.first_free), <span class="hljs-built_in">cap</span>(s.cap)<br>&#123;<br>	<span class="hljs-comment">//令s进入这样一个状态————对其运行析构函数是安全的</span><br>    s.elements = s.first_free = s.cap = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>移动构造函数不会分配任何新内存，它接管给定的StrVec的内存。接管之后，源对象的指针置nullptr。</p>
<p><strong>移动操作通常不分配任何资源，因此移动操作通常不抛出任何异常。而通过noexcept可以通知标准库构造函数不会抛出异常，如果不通知，那么标准库会认为移动构造函数可能会抛出异常，为此会做一些额外的工作。</strong></p>
<p>为什么要指出移动操作不抛出异常呢？因为标准库能对异常发生时其自身的行为提供保证，比如vector保证push_back时发生异常不会改变vector本身。</p>
<p>之所不异常时不改变vector，是因为拷贝构造函数中发生异常时，旧元素的内存空间是没有变化的，至于新内存空间尽管发生了异常，vector可以直接释放新分配的内存（尚未成功构造）并返回，这不会影响vector原有的元素。但移动语义就不同，如果移动了部分元素时发生了异常，那么这时源元素就已经被改变了，这就无法满足自身保持不变的要求了。</p>
<p>所以除非vector知道元素类型的移动构造函数不会抛异常，否则在重新分配内存时，它必须使用拷贝构造而不是移动构造。基于此，如果希望vector重新分配内存时可以使用自定义类型对象的移动操作而不是拷贝操作，那就要<strong>显式的声明我们的移动构造函数是noexcept的。</strong></p>
<h3 id="移动赋值运算符"><a href="#移动赋值运算符" class="headerlink" title="移动赋值运算符"></a>移动赋值运算符</h3><p>类似移动构造，如果不抛出任何异常，也要标记为noexcept。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">StrVec &amp;StrVec::<span class="hljs-keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="hljs-keyword">noexcept</span><br>&#123;<br>    <span class="hljs-comment">//直接检测自赋值</span><br>  	<span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> != &amp;rhs)&#123;<br>        <span class="hljs-built_in">free</span>();	<span class="hljs-comment">//释放已有元素</span><br>      	elements = rhs.elements;	/从rhs接管资源<br>        first_free = rhs.first_free;<br>      	cap = rhs.cap;<br>      	<span class="hljs-comment">//将rhs置于可析构状态</span><br>      	rhs.elements = rhs.first_free = rhs.cap = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>  	<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="合成的移动操作"><a href="#合成的移动操作" class="headerlink" title="合成的移动操作"></a>合成的移动操作</h3><p>如果自己不定义，编译器也会自动合成移动操作，但这和拷贝操作不同，它需要一些条件。</p>
<ul>
<li><p>如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会合成移动操作。</p>
</li>
<li><p><strong>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造和移动赋值运算符。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//编译器为X和hasX合成移动操作</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X</span>&#123;</span><br>    <span class="hljs-keyword">int</span> i;	<span class="hljs-comment">//内置类型可以移动</span><br>  	std::string s;	<span class="hljs-comment">//string定义了自己的移动操作</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hasX</span>&#123;</span><br>    X mem;	<span class="hljs-comment">//X有合成的移动操作</span><br>&#125;;<br>X x, x2 = std::<span class="hljs-built_in">move</span>(x);	<span class="hljs-comment">//使用合成的移动构造函数</span><br>hasX hx, hx2 = std::<span class="hljs-built_in">move</span>(hx);	<span class="hljs-comment">//使用合成的移动构造函数</span><br></code></pre></div></td></tr></table></figure>

<p>与拷贝操作不同，移动操作永远不会被隐式定义为删除的函数。但如果显式地要求编译器生成=default的移动操作，且编译器不能移动全部成员，则移动操作会被定义为删除的函数。</p>
<p>定义了移动构造或移动赋值的类也必须定义自己的拷贝操作，否则拷贝操作默认被定义为删除的。</p>
<p>如果类既有移动构造，也有拷贝构造，那么编译器使用普通的函数匹配规则来确定使用哪个构造函数。赋值也类似。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">StrVec v1, v2;<br>v1 = v2;	<span class="hljs-comment">//v2是左值，使用拷贝赋值</span><br><span class="hljs-function">StrVec <span class="hljs-title">getVec</span><span class="hljs-params">(istream &amp;s)</span></span>;	<span class="hljs-comment">//getVec返回一个右值</span><br>v2 = <span class="hljs-built_in">getVec</span>(cin);	<span class="hljs-comment">//getVec(cin)是一个右值，使用移动赋值</span><br></code></pre></div></td></tr></table></figure>

<p>如果类有拷贝构造，但没有移动构造，函数匹配规则会保证该类型的对象会被拷贝：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  	<span class="hljs-built_in">Foo</span>() = <span class="hljs-keyword">default</span>;<br>  	<span class="hljs-built_in">Foo</span>(<span class="hljs-keyword">const</span> Foo&amp;);<br>  	...<br>&#125;;<br>Foo x;<br><span class="hljs-function">Foo <span class="hljs-title">y</span><span class="hljs-params">(x)</span></span>;	<span class="hljs-comment">//拷贝构造函数，x是左值</span><br><span class="hljs-function">Foo <span class="hljs-title">z</span><span class="hljs-params">(std::move(x))</span></span>;	<span class="hljs-comment">//拷贝构造函数，因为未定义移动构造函数</span><br></code></pre></div></td></tr></table></figure>

<p>在未定义移动构造的情境下，<code>Foo z(std::move(x)</code>之所以可行，是因为我们可以把<code>Foo&amp;&amp;</code>转换为一个<code>const Foo&amp;</code>。</p>
</li>
</ul>
<p>五个拷贝控制成员应该当成一个整体来对待。如果一个类需要任何一个拷贝操作，它就应该定义所有五个操作。</p>
<p>C++11标准库定义了移动迭代器（move iterator）适配器。一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。移动迭代器的解引用运算符返回一个右值引用。调用<code>make_move_iterator</code>函数能将一个普通迭代器转换成移动迭代器。原迭代器的所有其他操作在移动迭代器中都照常工作。</p>
<p><strong>最好不要在移动构造函数和移动赋值运算符这些类实现代码之外的地方随意使用move操作。std::move是危险的。</strong></p>
<h3 id="右值引用和成员函数"><a href="#右值引用和成员函数" class="headerlink" title="右值引用和成员函数"></a>右值引用和成员函数</h3><p>在非static成员函数的形参列表后面添加引用限定符（reference qualifier）可以指定this的左值/右值属性。引用限定符可以是<code>&amp;</code>或者<code>&amp;&amp;</code>，分别表示this可以指向一个左值或右值对象。引用限定符必须同时出现在函数的声明和定义中。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    Foo &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Foo&amp;) &amp;; <span class="hljs-comment">// 只能向可修改的左值赋值</span><br>    <span class="hljs-comment">// 其他成员</span><br>&#125;;<br><br>Foo &amp;Foo::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Foo &amp;rhs) &amp;<br>&#123;<br>    <span class="hljs-comment">// 执行将rhs赋予本对象所需的工作</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>一个非static成员函数可以同时使用const和引用限定符，此时引用限定符跟在const限定符之后。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Foo <span class="hljs-title">someMem</span><span class="hljs-params">()</span> &amp; <span class="hljs-keyword">const</span></span>;      <span class="hljs-comment">// error</span><br>    <span class="hljs-function">Foo <span class="hljs-title">anotherMem</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> &amp;</span>;   <span class="hljs-comment">// ok</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p><strong>引用限定符也可以区分成员函数的重载版本。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Foo <span class="hljs-title">sorted</span><span class="hljs-params">()</span> &amp;&amp;</span>;        <span class="hljs-comment">// 可用于可改变的右值</span><br>    <span class="hljs-function">Foo <span class="hljs-title">sorted</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> &amp;</span>;   <span class="hljs-comment">// 可用于任何类型的Foo</span><br>  	<span class="hljs-comment">//Foo其他成员</span><br><span class="hljs-keyword">private</span>:<br>  	vector&lt;<span class="hljs-keyword">int</span>&gt; data;<br>&#125;;<br><br><span class="hljs-comment">//本对象为右值，因此可以原址排序</span><br><span class="hljs-function">Foo <span class="hljs-title">Foo::sorted</span><span class="hljs-params">()</span> &amp;&amp;</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">sort</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>());<br>  	<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125; <br><span class="hljs-comment">//本对象是const或是一个左值，哪种情况我们都不能对其进行原址排序</span><br><span class="hljs-function">Foo <span class="hljs-title">Foo::sorted</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> &amp;</span>&#123;<br>    <span class="hljs-function">Foo <span class="hljs-title">ret</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>  	<span class="hljs-built_in">sort</span>(ret.data.<span class="hljs-built_in">begin</span>(), ret.data.<span class="hljs-built_in">end</span>());<br>  	<span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-built_in">retVal</span>().<span class="hljs-built_in">sorted</span>();	<span class="hljs-comment">//retVal()是右值，调用Foo::sorted() &amp;&amp;</span><br><span class="hljs-built_in">retFoo</span>().<span class="hljs-built_in">sorted</span>();	<span class="hljs-comment">//retFoo()是左值，调用Foo::sorted() const &amp;</span><br></code></pre></div></td></tr></table></figure>

<p>如果定了两个或两个以上具有相同名字和相同参数列表的成员函数，<strong>要么都加引用限定符，要么都不加</strong>，这一点不受const this的影响。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Foo <span class="hljs-title">sorted</span><span class="hljs-params">()</span> &amp;&amp;</span>;<br>    <span class="hljs-function">Foo <span class="hljs-title">sorted</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;    <span class="hljs-comment">// 错误：必须加上引用限定符</span><br>    <span class="hljs-comment">// Comp是函数类型的类型别名</span><br>    <span class="hljs-comment">// 此函数类型可以用来比较int值</span><br>    <span class="hljs-keyword">using</span> Comp = <span class="hljs-built_in"><span class="hljs-keyword">bool</span></span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp;, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp;);<br>    <span class="hljs-function">Foo <span class="hljs-title">sorted</span><span class="hljs-params">(Comp*)</span></span>;  		<span class="hljs-comment">// 正确：不同的参数列表</span><br>  	<span class="hljs-function">Foo <span class="hljs-title">sorted</span><span class="hljs-params">(Comp*)</span> <span class="hljs-keyword">const</span></span>;	<span class="hljs-comment">//正确：两个版本都没有引用限定符</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/c/">c++</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/10/27/c++/effect%201-4/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">effective C++ 第三版 第一章</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/10/24/c++/15.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">
                        <span class="hidden-mobile">C++ primer 读书笔记 chapter 15 面向对象程序设计</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>





  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  








  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
