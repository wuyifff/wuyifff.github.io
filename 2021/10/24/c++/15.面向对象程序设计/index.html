

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://img1.baidu.com/it/u=4218313265,1883370397&amp;fm=26&amp;fmt=auto">
  <link rel="icon" href="https://img1.baidu.com/it/u=4218313265,1883370397&amp;fm=26&amp;fmt=auto">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="OOP三大核心思想：抽象、继承和多态（动态绑定）">
  <meta name="author" content="wuyifff">
  <meta name="keywords" content="">
  <meta name="description" content="OOP三大核心思想：抽象、继承和多态（动态绑定）">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ primer 读书笔记 chapter 15 面向对象程序设计">
<meta property="og:url" content="https://wuyifff.github.io/2021/10/24/c++/15.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/index.html">
<meta property="og:site_name" content="wuyifff&#39;s blog">
<meta property="og:description" content="OOP三大核心思想：抽象、继承和多态（动态绑定）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/10/24/qG3HOzX9Q4kTyhs.png">
<meta property="article:published_time" content="2021-10-24T07:38:00.000Z">
<meta property="article:modified_time" content="2021-10-25T08:57:29.743Z">
<meta property="article:author" content="wuyifff">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://i.loli.net/2021/10/24/qG3HOzX9Q4kTyhs.png">
  
  <title>C++ primer 读书笔记 chapter 15 面向对象程序设计 - wuyifff&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"wuyifff.github.io","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":" ","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="wuyifff's blog" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>wuyifff&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://img0.baidu.com/it/u=336294190,1675821935&fm=26&fmt=auto') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="C++ primer 读书笔记 chapter 15 面向对象程序设计">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-10-24 15:38" pubdate>
        2021年10月24日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      11k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      34 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C++ primer 读书笔记 chapter 15 面向对象程序设计</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2021年10月25日 下午
                
              </p>
            
            <div class="markdown-body">
              <h1 id="C-Primer-chapter-15"><a href="#C-Primer-chapter-15" class="headerlink" title="C++ Primer  chapter 15"></a>C++ Primer  chapter 15</h1><h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1><h2 id="OOP概述"><a href="#OOP概述" class="headerlink" title="OOP概述"></a>OOP概述</h2><p><strong>OOP三大核心思想：抽象、继承和多态（动态绑定）。</strong></p>
<ul>
<li><strong>数据抽象将类的接口与实现分离</strong></li>
<li><strong>继承可以定义相似的类型并对其相似关系建模</strong></li>
<li><strong>多态则在一定程度上忽略相似类型的区别，实现统一方式来使用一组对象</strong></li>
</ul>
<p>对继承来说，层次关系的根部类叫基类，其他类可以直接或间接从基类继承而来，它们叫派生类。基类负责定义在层次关系中所有类共同拥有的成员，派生类定义各自特有的成员。</p>
<p>而一旦有了继承，也就可以应用多态。想要解释继承和多态，再多的语言也是苍白无力。不如从一个例子说起：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Quote</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  	<span class="hljs-function">std::string <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>  	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span> n)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-comment">//定义为虚函数，实现多态</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bulk_quote</span> :</span> <span class="hljs-keyword">public</span> Quote&#123;	<span class="hljs-comment">// Bulk_quote继承了Quote</span><br><span class="hljs-keyword">public</span>:<br>  	<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>Quote为基类，Bulk_quote为Quote的派生类（子类）。派生类通过类派生列表(class derivation list)明确指出从哪个(哪些)基类继承而来。其中关键字public表示公有继承，先不解释其作用。</p>
<p>基类的函数net_price前面加上virtual表示其是一个虚函数，虚函数的作用是为了实现多态。一旦基类定义了虚函数，那么派生的子类就可以通过重新定义来覆盖基类的虚函数实现。派生类可以省略virtual关键字，尽管子类中不声明virtual，覆盖函数定义仍然还是虚函数。(<strong>但是还是应该带上virtual,这样间接继承就免得去看基类的实现</strong>)</p>
<p>C++11标准允许派生类<strong>显式地注明</strong>它将使用哪个成员函数改写基类的虚函数，这就是上例中override关键字的作用。==（好处是万一同名参数形参列表不同将会overrid失败，编译器将会报错帮助你发现）==</p>
<p>virtual实现的动态绑定怎么用呢？<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1dE41167hJ?p=22&share_source=copy_web"><strong>（翁恺c++ p23-24）</strong></a></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">print_total</span><span class="hljs-params">(ostream &amp;os, <span class="hljs-keyword">const</span> Quote &amp;item, <span class="hljs-keyword">size_t</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  	<span class="hljs-comment">//如果item是Quote对象，调用Quote::net_price</span><br>  	<span class="hljs-comment">//如果item是Bulk_quote对象，调用Bulk_quote::net_price</span><br>    <span class="hljs-keyword">double</span> ret = item.<span class="hljs-built_in">net_price</span>(n);<br>  	os &lt;&lt; <span class="hljs-string">&quot;ISBN: &quot;</span> &lt;&lt; item.<span class="hljs-built_in">isbn</span>()	<span class="hljs-comment">//调用Quote::isbn</span><br>      	&lt;&lt; <span class="hljs-string">&quot; # sold: &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; total due: &quot;</span> &lt;&lt; ret &lt;&lt; endl;<br>  	<span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-built_in">print_total</span>(cout, basic, <span class="hljs-number">20</span>);	<span class="hljs-comment">//basic是Quote对象</span><br><span class="hljs-built_in">print_total</span>(cout, bulk, <span class="hljs-number">20</span>);	<span class="hljs-comment">//bulk是Bulk_quote对象</span><br></code></pre></div></td></tr></table></figure>

<p>可以看到尽管形参是一个const Quote对象的引用，但可以传入一个派生类对象作为实参，而一旦如此，对形参调用类成员函数时，就会进行动态绑定，即派生类调用派生类重新定义的虚函数体，基类调用基类定义的虚函数体。</p>
<blockquote>
<p>如果net_price不是虚函数，即使子类中重新定义了一模一样的net_price，对该例来说，无论传给item的对象是子类还是派生类，最终调用的都是父类的net_price。所以说<strong>虚函数才支持动态绑定</strong>。深入一点说，拥有虚函数的类对象都有虚表，忽略基类型别动态绑定到子类成员函数的过程实际上是依赖于类对象的虚表指针，因为无论对象被看成基类还是子类，它的虚表指针始终是指向正确的解绑函数的。</p>
</blockquote>
<p>所以，多态的存在可以让我们在程序设计上使用父类指针（或引用）指向子类对象，也就是所谓的“一定程度上忽略相似类型的区别，实现统一方式来使用一组对象”。</p>
<h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Quote</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  	<span class="hljs-built_in">Quote</span>() = <span class="hljs-keyword">default</span>;	<span class="hljs-comment">//合成默认构造函数</span><br>  	<span class="hljs-built_in">Quote</span>(<span class="hljs-keyword">const</span> std::string &amp;book, <span class="hljs-keyword">double</span> sales_price):<span class="hljs-built_in">bookNo</span>(book), <span class="hljs-built_in">price</span>(sales_price)&#123;&#125;<br>  	<span class="hljs-function">std::string <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> bookNo;&#125;<br>  	<span class="hljs-comment">//返回给定数量的书籍的销售总额</span><br>  	<span class="hljs-comment">//派生类负责改写并使用不同的折扣计算算法</span><br>  	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span> n)</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">    </span>&#123;<span class="hljs-keyword">return</span> n * price;&#125;<br>  	<span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Quote</span>() = <span class="hljs-keyword">default</span>;	<span class="hljs-comment">//对析构函数进行动态绑定</span><br><span class="hljs-keyword">private</span>:<br>  	std::string bookNo;	<span class="hljs-comment">//书籍的ISBN编号</span><br><span class="hljs-keyword">protected</span>:<br>  	<span class="hljs-keyword">double</span> price = <span class="hljs-number">0.0</span>;	<span class="hljs-comment">//代表普通状态下不打折的价格</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p><strong>为什么析构函数要定义成虚函数呢？因为我们往往使用多态时，会使用父类指针指向子类对象，而后续可能会delete父类指针，如果析构函数不是虚函数，那么delete一个子类对象不会调用子类对象的析构，而是直接调用父类的析构了，这与预期不符。</strong></p>
<p>所以，==拥有虚函数的父类的析构函数往往也是虚函数==（因为多态需要虚函数来实现）。</p>
<p>这里的一个疑点：类成员protected权限是什么？</p>
<h3 id="成员函数与继承"><a href="#成员函数与继承" class="headerlink" title="成员函数与继承"></a>成员函数与继承</h3><p>派生类可以继承基类的成员，基类的成员函数有两种：希望派生类进行覆盖而被声明为virtual的虚函数、希望派生类直接使用的函数。</p>
<p>任何构造函数之外的非静态函数都可以是虚函数。==构造函数不能virtual！==</p>
<blockquote>
<p>构造函数为什么不能virtual呢？很简单，因为构造子类理应递归的调用父类的构造器，如果父类构造器被virtual化了，那么子类就无法调用到父类的构造器了。</p>
</blockquote>
<p>普通的成员函数的解析过程发生在编译阶段，虚函数的解析过程发生在运行时(从虚表(virtual table)取函数地址)。</p>
<p>所以有虚函数的类会大一点，在<strong>类的开头有一个指针指向virtual table。</strong></p>
<p><img src="https://i.loli.net/2021/10/24/qG3HOzX9Q4kTyhs.png" alt="image-20211024153527689"></p>
<h3 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h3><p>派生类可以继承基类的成员，但这并不意味着派生类内部可以随意使用基类的成员。在public继承条件下，如果父类的成员是private权限，那么派生类内部无法访问，如果父类的成员是public权限，那么派生类内部可以访问。</p>
<p>那么，有的时候我们希望父类的一些成员也可以被子类访问，但不希望被其他外部非亲非戚的访问，private和public就都不好用了，于是，就有了protected权限。protected修饰的成员意味着派生类可以访问，外部不行。</p>
<p>继续定义派生类：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bulk_quote</span> :</span> <span class="hljs-keyword">public</span> Quote&#123;<br><span class="hljs-keyword">public</span>:<br>  	<span class="hljs-built_in">Bulk_quote</span>() = <span class="hljs-keyword">default</span>;<br>  	<span class="hljs-built_in">Bulk_quote</span>(<span class="hljs-keyword">const</span> std::string &amp;, <span class="hljs-keyword">double</span>, std::<span class="hljs-keyword">size_t</span>, <span class="hljs-keyword">double</span>);<br>  	<span class="hljs-comment">//覆盖基类的虚函数，隐式virtual</span><br>  	<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-keyword">private</span>:<br>  	std::<span class="hljs-keyword">size_t</span> min_qty = <span class="hljs-number">0</span>;	<span class="hljs-comment">//自己的成员，折扣政策下最低购买量</span><br>  	<span class="hljs-keyword">double</span> discount = <span class="hljs-number">0.0</span>;		<span class="hljs-comment">//折扣额</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>派生类对象包含多个组成部分：含有派生类自己定义的(非静态)成员的子对象，以及一个与该类继承的基类对应的子对象，如果有多个基类，那么也就有对应多个子对象。</p>
<p>Bulk_quote对象</p>
<p>| bookNo | 从Quote继承</p>
<p>| price |</p>
<p>| min_qty | Bulk_quote自定义的成员</p>
<p>| discount |</p>
<p>之所以能完成继承，本质上是因为派生类对象中拥有基类对象。</p>
<p>C++标准没有规定派生类对象的内存如何分布，有兴趣可以看看《深度探索C++对象模型》，当然由于这本书比较老了，所以现在主流编译器的设计和书中内容有较大差异，但仍然极有价值，毕竟授人以渔。</p>
<p>因为派生类对象中含有与其基类对应的组成部分，所以可以把派生类对象当成基类对象使用，也能将基类指针或引用绑定到派生类对象的基类部分上。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">Quote item;			<span class="hljs-comment">//基类对象</span><br>Bulk_quote bulk;	<span class="hljs-comment">//派生类对象</span><br>Quote *p = &amp;item;	<span class="hljs-comment">//p指向Quote对象</span><br>p = &amp;bulk;			<span class="hljs-comment">//p指向bulk的Quote部分</span><br>Quote &amp;r = bulk;	<span class="hljs-comment">//r绑定到bulk的Quote部分</span><br></code></pre></div></td></tr></table></figure>

<p>这种称为派生类到基类的类型转换，编译器会隐式执行派生类到基类的转换。</p>
<h3 id="派生类构造函数"><a href="#派生类构造函数" class="headerlink" title="派生类构造函数"></a>派生类构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">Bulk_quote</span>(<span class="hljs-keyword">const</span> std::string &amp;book, <span class="hljs-keyword">double</span> p, std::<span class="hljs-keyword">size_t</span> qty, <span class="hljs-keyword">double</span> disc) : <span class="hljs-built_in">Quote</span>(book, p), <span class="hljs-built_in">min_qty</span>(qty), <span class="hljs-built_in">discount</span>(disc)&#123;&#125;<br></code></pre></div></td></tr></table></figure>

<p>初始化列表中调用了Quote的构造函数，用来负责初始化基类部分。</p>
<p>除非特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。如果想使用其他的基类构造函数，我们需要以类名加圆括号内的实参列表的形式为构造函数提供初始值。</p>
<p>派生类的构造器总是先初始化基类部分，再按声明顺序依次初始化派生类成员。</p>
<h3 id="派生类使用基类的成员"><a href="#派生类使用基类的成员" class="headerlink" title="派生类使用基类的成员"></a>派生类使用基类的成员</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Bulk_quote::net_price</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> cnt)</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(cnt &gt;= min_qty)<br>      	<span class="hljs-keyword">return</span> cnt * (<span class="hljs-number">1</span> - discount) * price;<br>  	<span class="hljs-keyword">else</span><br>      	<span class="hljs-keyword">return</span> cnt * price;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="继承与静态成员"><a href="#继承与静态成员" class="headerlink" title="继承与静态成员"></a>继承与静态成员</h3><p>如果基类定义了静态成员，则整个继承体系中只存在该成员的唯一定义。不论基类中派生出多少个派生类，对每个静态成员来说都只存在唯一的一个实例。</p>
<blockquote>
<p>因为静态成员实际上是全局的，当然是单例。只是语法上为了关系结构，把它放在类中定义。</p>
</blockquote>
<p>另外，静态成员也遵循访问控制权限。</p>
<p>派生类的声明不能包含派生列表，直接<code>class Bulk_quote;</code>就行了。</p>
<p>C++11可以定义一种不允许其他类继承的类。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoDerived</span> <span class="hljs-keyword">final</span>&#123;</span><span class="hljs-comment">/* */</span>&#125;;	<span class="hljs-comment">//NoDerived不能做基类</span><br></code></pre></div></td></tr></table></figure>

<p>嗯，C++居然反向抄袭了java。</p>
<h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><p>通常当把引用或指针绑定到一个对象时，引用或指针的类型得和对象的类型一致，或者对象类型含有一个可接受的const类型转换规则。但对于继承类来说还有一个特例，那就是可以把基类的指针或引用绑定到派生类对象上，为了实现多态。</p>
<blockquote>
<p>智能指针也支持这一类型转换，所以可以将派生类对象指针存在基类智能指针之内。</p>
</blockquote>
<ul>
<li>从派生类向基类的类型转换只对指针或引用类型有效。</li>
<li>基类向派生类不存在隐式类型转换。</li>
<li>派生类向基类的类型转换也可能会由于访问受限而变得不可行。</li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>对虚函数的调用在运行时被解析。派生类覆盖虚函数定义需要保证型别完全一致。</p>
<blockquote>
<p>有一个例外就是虚函数在基类中如果返回基类指针或引用时，派生类中是可以返回派生类的指针或引用的，这是唯一的一个可行的型别不一致的地方，但这种不一致也有前提条件，即派生类到基类的类型转换是可访问的（不能访问受限）。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span>&#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-keyword">const</span></span>;<br>  	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>  	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-comment">//这个例子可以看出override的用处，可以直观的找出错误，没有override编译器会曲解原本的意图</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">D1</span> :</span> B&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//正确，f1与基类型别一致</span><br>  	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//错误，B没有该函数</span><br>  	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;		<span class="hljs-comment">//错误，f3不是虚函数</span><br>  	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f4</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;		<span class="hljs-comment">//错误，B没有f4</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">D2</span> :</span> B&#123;<br>  	<span class="hljs-comment">//继承B的f2(),f3(),覆盖f1(int)</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">final</span></span>;	<span class="hljs-comment">//不允许后续的其他类覆盖f1(int)</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">D3</span> :</span> D2&#123;<br>  	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>;				<span class="hljs-comment">//正确：覆盖从间接基类B继承而来的f2()</span><br>  	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-keyword">const</span></span>;		<span class="hljs-comment">//错误，D2已经声明f1为final了</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>虚函数也可以声明final来阻止派生类覆盖。</p>
<h3 id="回避虚函数的机制"><a href="#回避虚函数的机制" class="headerlink" title="回避虚函数的机制"></a>回避虚函数的机制</h3><p>有时候不希望动态绑定，而是调用某个虚函数的特定版本，可以通过作用域运算符来实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> undiscounted = baseP-&gt;Quote::<span class="hljs-built_in">net_price</span>(<span class="hljs-number">42</span>);<br></code></pre></div></td></tr></table></figure>

<p>无论baseP实际上是啥类型，最后调用的都是Quote的net_price，这是编译时期确定的。</p>
<p>通常只有成员函数(或友元)的代码才需要这种hack技巧。比如派生类虚函数想要调用父类的虚函数版本。</p>
<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p>有时候父类指向声明一个函数接口，不想实际定义，希望由派生类来定义。C++允许这种设计，可以在virtual的基础上定义纯虚函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Disc_quote</span> :</span> <span class="hljs-keyword">public</span> Quote&#123;<br><span class="hljs-keyword">public</span>:<br>  	<span class="hljs-built_in">Disc_quote</span>() = <span class="hljs-keyword">default</span>;<br>  	<span class="hljs-built_in">Disc_quote</span>(<span class="hljs-keyword">const</span> std::string &amp;book, <span class="hljs-keyword">double</span> price, std:<span class="hljs-keyword">size_t</span> qty, <span class="hljs-keyword">double</span> disc):<span class="hljs-built_in">Quote</span>(book, price), <span class="hljs-built_in">quantity</span>(qty), <span class="hljs-built_in">discount</span>(disc) &#123;&#125;<br>  	<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span>)</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-comment">//=0表示纯虚函数</span><br><span class="hljs-keyword">protected</span>:<br>  	std::<span class="hljs-keyword">size_t</span> quantity = <span class="hljs-number">0</span>;<br>  	<span class="hljs-keyword">double</span> discount = <span class="hljs-number">0.0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>纯虚函数无需定义，=0只能出现在类内部的虚函数声明语句处。</p>
<p>纯虚函数也可以定义，但必须在类外部定义，大部分情况不会定义，因为这与我们的使用意图相悖。</p>
<p>类只要含有纯虚函数，就是一个抽象基类，抽象基类负责定义接口，后续的其他类来覆盖接口。不能创建抽象基类的对象，抽象基类需要派生类去继承。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bulk_quote</span> :</span> <span class="hljs-keyword">public</span> Disc_quote&#123;<br><span class="hljs-keyword">public</span>:<br>  	<span class="hljs-built_in">Bulk_quote</span>() = <span class="hljs-keyword">default</span>;<br>  	<span class="hljs-built_in">Bulk_quote</span>(<span class="hljs-keyword">const</span> std::string &amp;book, <span class="hljs-keyword">double</span> price, std::<span class="hljs-keyword">size_t</span> qty, <span class="hljs-keyword">double</span> disc):<span class="hljs-built_in">Disc_quote</span>(book, price, qty, disc)&#123;&#125;<br>  	<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>直接基类是Disc_quote，间接基类是Quote。各个类控制自己的构造器，构造器会递归下去，先执行根基类构造器，最后执行自身的构造。继承链的构造器形成了层的概念。</p>
<h2 id="访问控制与继承-1"><a href="#访问控制与继承-1" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><p>protected的一个坑：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span>&#123;</span><br><span class="hljs-keyword">protected</span>:<br>  	<span class="hljs-keyword">int</span> prot_mem;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sneaky</span> :</span> <span class="hljs-keyword">public</span> Base&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clobber</span><span class="hljs-params">(Sneaky&amp;)</span></span>;	<span class="hljs-comment">//可以访问Sneaky::prot_mem</span><br>  	<span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clobber</span><span class="hljs-params">(Base&amp;)</span></span>;	<span class="hljs-comment">//不能访问Base::prot_mem</span><br>  	<span class="hljs-keyword">int</span> j;	<span class="hljs-comment">//j默认是private</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clobber</span><span class="hljs-params">(Sneaky &amp;s)</span></span>&#123;s.j = s.prot_mem = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//clobber可以访问Sneaky的private和protected成员</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clobber</span><span class="hljs-params">(Base &amp;b)</span></span>&#123;b.prot_mem = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//clobber不能访问Base的protected成员</span><br></code></pre></div></td></tr></table></figure>

<p>之所以有这种限制，是因为如果第二个用法合法的话，那么就可以通过定义一个形如Sneaky的新类来规避掉protected提供的访问保护了。</p>
<p>所以，派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员，而不能访问普通的基类对象中的成员。</p>
<h3 id="public、private和protected"><a href="#public、private和protected" class="headerlink" title="public、private和protected"></a>public、private和protected</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pub_mem</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">protected</span>:</span><br><span class="hljs-function">  	int prot_mem;</span><br><span class="hljs-keyword">private</span>:<br>  	<span class="hljs-keyword">char</span> priv_mem;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pub_Derv</span> :</span> <span class="hljs-keyword">public</span> Base&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> prot_mem;&#125;<span class="hljs-comment">//正确：派生类能访问protected成员</span><br>  	<span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> priv_mem;&#125;<span class="hljs-comment">//错误：private成员对于派生类来说是不可访问的</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Priv_Derv</span> :</span> <span class="hljs-keyword">private</span> Base&#123;<br>    <span class="hljs-comment">//private不影响派生类的访问权限</span><br>  	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>&#123;<span class="hljs-keyword">return</span> prot_mem;&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Prot_Derv</span> :</span> <span class="hljs-keyword">protected</span> Base&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>&#123;<span class="hljs-keyword">return</span> prot_mem;&#125;	<span class="hljs-comment">//依然是protected</span><br>&#125;<br>Pub_Derv d1;	<span class="hljs-comment">//继承自Base的成员遵循原有的访问说明符</span><br>Priv_Derv d2;	<span class="hljs-comment">//继承自Base的成员无论此前是什么权限，都变成private</span><br>d1.<span class="hljs-built_in">pub_mem</span>();	<span class="hljs-comment">//正确：pub_mem在派生类中是public的</span><br>d2.<span class="hljs-built_in">pub_mem</span>();	<span class="hljs-comment">//错误：pub_mem在派生类中是private的</span><br><br>Prot_Derv d3;	<span class="hljs-comment">//继承自Base的成员如果是public，会变成protected，其他不变</span><br>d3.<span class="hljs-built_in">pub_mem</span>();	<span class="hljs-comment">//错误，pub_mem是protected，只能成员和友元访问，外部不行</span><br></code></pre></div></td></tr></table></figure>

<h3 id="派生类向基类转换的可访问性"><a href="#派生类向基类转换的可访问性" class="headerlink" title="派生类向基类转换的可访问性"></a>派生类向基类转换的可访问性</h3><ul>
<li>只有当D公有继承B时，用户代码才能使用派生类向基类的转换，如果D继承B的方式是受保护或私有继承，则用户代码不能使用该转换。</li>
<li>无论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换，派生类向直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。</li>
<li>如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的类型转换；反之，如果D继承B的方式是私有的，则不能使用。</li>
</ul>
<p>说白了就一个规则：</p>
<p><strong>对代码中某个给定节点，如果基类的公有成员是可访问的，则派生类向基类的转换就是可访问的，反之则不行。</strong></p>
<p><strong>友元关系不能继承。</strong></p>
<p>class默认继承权限是private，struct是public。这一点和类成员权限很相似。</p>
<h2 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h2><p>派生类的作用域位于基类作用域之内，因此才可以实现派生类访问基类成员。</p>
<p>如果派生类重用了基类的成员名字，那么基类的对应成员就会被隐藏。此时想要访问隐藏的成员，就要通过域运算符，这一手法类似调用特定虚函数版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fcn</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D1</span> :</span> <span class="hljs-keyword">public</span> Base&#123;<br><span class="hljs-keyword">public</span>:<br>  	<span class="hljs-comment">//隐藏基类的fcn，这个fcn不是虚函数</span><br>  	<span class="hljs-comment">//D1继承了Base::fcn()的定义</span><br>  	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fcn</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;	<span class="hljs-comment">//形参列表与Base中的fcn不一致</span><br>  	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>;	<span class="hljs-comment">//新的虚函数，在Base中不存在</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D2</span> :</span> <span class="hljs-keyword">public</span> D1&#123;<br><span class="hljs-keyword">public</span>:<br>  	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fcn</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;	<span class="hljs-comment">//非虚函数，隐藏了D1::fcn(int)</span><br>  	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fcn</span><span class="hljs-params">()</span></span>;		<span class="hljs-comment">//覆盖了Base的虚函数fcn</span><br>  	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>;		<span class="hljs-comment">//覆盖了D1的虚函数f2</span><br>&#125;;<br><br>Base bobj;<br>D1 d1obj;<br>D2 d2obj;<br><br>Base *bp1 = &amp;bobj, *bp2 = &amp;d1obj, *bp3 = &amp;d2obj;<br>bp1-&gt;<span class="hljs-built_in">fcn</span>();	<span class="hljs-comment">//虚调用，运行时调用Base::fcn</span><br>bp2-&gt;<span class="hljs-built_in">fcn</span>();	<span class="hljs-comment">//虚调用，运行时调用Base::fcn</span><br>bp3-&gt;<span class="hljs-built_in">fcn</span>();	<span class="hljs-comment">//虚调用，运行时调用D2::fcn</span><br><br>D1 *d1p = &amp;d1obj; D2 *d2p = &amp;d2obj;<br>bp2-&gt;<span class="hljs-built_in">f2</span>();	<span class="hljs-comment">//错误，Base没有f2成员</span><br>d1p-&gt;<span class="hljs-built_in">f2</span>();	<span class="hljs-comment">//虚调用，运行时调用D1::f2()</span><br>d2p-&gt;<span class="hljs-built_in">f2</span>();	<span class="hljs-comment">//虚调用，运行时调用D2::f2()</span><br><br>Base *p1 = &amp;d2obj; D1 *p2 = &amp;d2obj; D2 *p3 = &amp;d2obj;<br>p1-&gt;<span class="hljs-built_in">fcn</span>(<span class="hljs-number">42</span>);	<span class="hljs-comment">//错误：Base中没有接受一个int的fcn</span><br>p2-&gt;<span class="hljs-built_in">fcn</span>(<span class="hljs-number">42</span>);	<span class="hljs-comment">//静态绑定，调用D1::fcn(int)</span><br>p3-&gt;<span class="hljs-built_in">fcn</span>(<span class="hljs-number">42</span>);	<span class="hljs-comment">//静态绑定，调用D2::fcn(int)</span><br></code></pre></div></td></tr></table></figure>

<h2 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h2><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>这一点已经说过了，如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义行为。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">Quote *itemP = <span class="hljs-keyword">new</span> Quote;<br><span class="hljs-keyword">delete</span> itemP;	<span class="hljs-comment">//调用Quote的析构</span><br>itemP = <span class="hljs-keyword">new</span> Bulk_quote;	<span class="hljs-comment">//静态类型与动态类型不一致</span><br><span class="hljs-keyword">delete</span> itemP;	<span class="hljs-comment">//如果Quote析构是虚函数，则调用Bulk_quote，否则调用Quote析构</span><br></code></pre></div></td></tr></table></figure>

<p>三五准则中曾言，如果类需要析构函数，往往也需要拷贝构造和赋值操作，但对虚析构函数来说不遵守该准侧。</p>
<p><strong>虚析构函数将阻止合成移动操作。</strong></p>
<h3 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h3><p>构造器的调用链：</p>
<ul>
<li>合成的Bulk_quote默认构造函数运行Disc_quote的默认构造函数，后者又运行Quote的默认构造函数。</li>
<li>Quote的默认构造函数将bookNo成员默认初始化为空串，同时使用类内初始化值将price初始化为0。</li>
<li>Quote的构造函数完成后，继续执行Disc_quote的构造函数，它使用类内初始化qty和discount。</li>
<li>Disc_quote的构造函数完成后，继续执行Bulk_quote的构造函数，但什么具体工作也没做。</li>
</ul>
<p>类似的，合成的Bulk_quote的拷贝构造也一样，调用Disc_quote的拷贝构造，后者又调用了Quote的拷贝构造。</p>
<ul>
<li>如果基类的默认构造、拷贝构造、拷贝赋值运算符或析构函数是被删除的函数或不可访问，则派生类中对应的成员也将是删除的。</li>
<li>如果基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数是删除的，因为编译器无法销毁派生类对象的基类部分。</li>
<li>编译器不会合成一个删除掉的移动操作。使用=default请求一个移动操作时，如果基类中对应的操作是删除的或不可访问的，那么派生类中该函数将是被删除的，因为派生类对象的基类部分不可移动。同理，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。</li>
</ul>
<p>如果确实需要移动操作，那就应该在基类中自己去定义，否则会因为虚析构的存在而默认被delete。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span>&#123;</span>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> :</span> <span class="hljs-keyword">public</span> Base&#123;<br><span class="hljs-keyword">public</span>:<br>  	<span class="hljs-built_in">D</span>(<span class="hljs-keyword">const</span> D&amp; d) : <span class="hljs-built_in">Base</span>(d)<br>    <span class="hljs-built_in">D</span>(D&amp;&amp; d) : <span class="hljs-built_in">Base</span>(std::<span class="hljs-built_in">move</span>(d))<br>  	D &amp;D::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> D &amp;rhs)&#123;<br>        Base::<span class="hljs-keyword">operator</span>=(rhs);<br>      	<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<h3 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h3><p>C++11可以让派生类重用基类定义的构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bulk_quote</span> :</span> <span class="hljs-keyword">public</span> Disc_quote&#123;<br><span class="hljs-keyword">public</span>:<br>  	<span class="hljs-keyword">using</span> Disc_quote::Disc_quote;	<span class="hljs-comment">//继承了Disc_quote的构造函数</span><br>  	<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span>)</span> <span class="hljs-keyword">const</span></span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>编译器会生成形如:<code>derived(params) : base(args)&#123;&#125;</code>的构造函数。这里的using作用给编译器，而不是当前作用域。</p>
<p>using声明语句不能指定constexpr或explicit，所以它继承基类的修饰。</p>
<p>基类构造函数含有默认实参时，默认实参不会被继承。相反，派生类或获得多个继承的构造函数，每个构造函数分别省略掉一个含有默认实参的形参。</p>
<p>如果基类有好几个构造函数，则大多数情况下派生类继承所有构造函数。除了两个例外，其一是派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本。如果派生类定义的构造函数与基类构造函数具有相同的参数列表，则这些构造函数不会被继承。其二是默认、拷贝和移动构造不会被继承。它们按照正常规则来合成，游离于三界之外。</p>
<h2 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vector&lt;Quote&gt; basket;<br>basket.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Quote</span>(<span class="hljs-string">&quot;0-201-82470-1&quot;</span>, <span class="hljs-number">50</span>));<br><span class="hljs-comment">//正确，但是只能把对象的Quote部分拷贝给basket</span><br>basket.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Bulk_quote</span>(<span class="hljs-string">&quot;0-201-54858-8&quot;</span>, <span class="hljs-number">50</span>, <span class="hljs-number">10</span>, <span class="hljs-number">.25</span>));<br><span class="hljs-comment">//调用Quote定义的版本</span><br>cout &lt;&lt; basket.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">net_price</span>(<span class="hljs-number">15</span>) &lt;&lt; endl;<br></code></pre></div></td></tr></table></figure>

<p>因为存放的是对象，所以类型转换上会阉割。</p>
<p>想要多态必须要间接访问，对容器来说也一样，我们要存放指针而不是对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vector&lt;shared_ptr&lt;Quote&gt;&gt; basket;<br>basket.<span class="hljs-built_in">push_back</span>(make_shared&lt;Quote&gt;(<span class="hljs-string">&quot;0-201-82470-1&quot;</span>, <span class="hljs-number">50</span>));<br>basket.<span class="hljs-built_in">push_back</span>(make_shared&lt;Bulk_quote&gt;(<span class="hljs-string">&quot;0-201-54848-8&quot;</span>, <span class="hljs-number">50</span>, <span class="hljs-number">10</span>, <span class="hljs-number">.25</span>));<br>cout &lt;&lt; basket.<span class="hljs-built_in">back</span>()-&gt;<span class="hljs-built_in">net_price</span>(<span class="hljs-number">15</span>) &lt;&lt; endl;<br></code></pre></div></td></tr></table></figure>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/c/">c++</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/10/20/c++/12.%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/">
                        <span class="hidden-mobile">C++ primer 读书笔记 chapter 12 动态内存与智能指针</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>





  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
