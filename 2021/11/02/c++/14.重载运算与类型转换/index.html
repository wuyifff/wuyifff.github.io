

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://img1.baidu.com/it/u=4218313265,1883370397&amp;fm=26&amp;fmt=auto">
  <link rel="icon" href="https://img1.baidu.com/it/u=4218313265,1883370397&amp;fm=26&amp;fmt=auto">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="运算符重载实质上是函数的重载">
  <meta name="author" content="wuyifff">
  <meta name="keywords" content="">
  <meta name="description" content="运算符重载实质上是函数的重载">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ primer 读书笔记 chapter 14 重载运算与类型转换">
<meta property="og:url" content="https://wuyifff.github.io/2021/11/02/c++/14.%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/index.html">
<meta property="og:site_name" content="wuyifff&#39;s blog">
<meta property="og:description" content="运算符重载实质上是函数的重载">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-11-02T03:16:00.000Z">
<meta property="article:modified_time" content="2021-11-02T03:16:43.499Z">
<meta property="article:author" content="wuyifff">
<meta name="twitter:card" content="summary_large_image">
  
  <title>C++ primer 读书笔记 chapter 14 重载运算与类型转换 - wuyifff&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"wuyifff.github.io","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":" ","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="wuyifff's blog" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>wuyifff&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://img0.baidu.com/it/u=336294190,1675821935&fm=26&fmt=auto') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="C++ primer 读书笔记 chapter 14 重载运算与类型转换">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      wuyifff
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-11-02 11:16" pubdate>
        2021年11月2日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.5k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      24 分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span>
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C++ primer 读书笔记 chapter 14 重载运算与类型转换</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2021年11月2日 上午
                
              </p>
            
            <div class="markdown-body">
              <h1 id="C-Primer-重载运算与类型转换"><a href="#C-Primer-重载运算与类型转换" class="headerlink" title="C++ Primer - 重载运算与类型转换"></a>C++ Primer - 重载运算与类型转换</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>重载的运算符是具有<strong>特殊名字的函数</strong>（关键字operator接要定义的运算符号）。</p>
<p>既然是函数，所以也有<strong>返回类型、参数列表和函数体</strong>。其中参数数量与该运算符作用的运算对象一样多。一元运算符有一个参数，二元运算符有两个（唯一的一个三元运算符不能重载）。对二元运算符来说，左侧运算对象传递给第一个参数，而右侧运算对象传递给第二个参数。<strong>除了重载的函数调用运算符<code>operator()</code>之外，其他重载运算符不能含有默认实参</strong>。</p>
<blockquote>
<p>有的运算符既可以当一元也可以当二元，这个时候要根据重载参数个数来判断语义。</p>
</blockquote>
<p>如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的this指针上，因此，<strong>成员运算符函数（显式）的参数数量比运算符的运算对象总是少一个。</strong></p>
<p>运算符函数要么是类的成员，要么至少含有一个类类型参数，这就意味着无法对内置类型的运算对象进行运算符重载。</p>
<blockquote>
<p>比如<code>int operator+(int, int);</code>就是错误的语法，不能改变内置类型的运算符行为。</p>
</blockquote>
<p>只能重载已有的运算符，不能搞新发明。不是所有的运算符都能重载。</p>
<table>
<thead>
<tr>
<th align="left">可重载运算符</th>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">+</td>
<td align="left">-</td>
<td align="left">*</td>
<td align="left">/</td>
<td align="left">%</td>
<td align="left">^</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">&amp;</td>
<td align="left">\</td>
<td align="left"></td>
<td align="left">~</td>
<td align="left">!</td>
<td align="left">,</td>
<td>=</td>
<td></td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">&gt;</td>
<td align="left">&lt;=</td>
<td align="left">&gt;=</td>
<td align="left">++</td>
<td align="left">–</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">&lt;&lt;</td>
<td align="left">&gt;&gt;</td>
<td align="left">==</td>
<td align="left">!=</td>
<td align="left">&amp;&amp;</td>
<td align="left">\</td>
<td>\</td>
<td></td>
</tr>
<tr>
<td align="left">+=</td>
<td align="left">-=</td>
<td align="left">/=</td>
<td align="left">%=</td>
<td align="left">^=</td>
<td align="left">&amp;=</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">\</td>
<td align="left">=</td>
<td align="left">*=</td>
<td align="left">&lt;&lt;=</td>
<td align="left">&gt;&gt;=</td>
<td align="left">[]</td>
<td>()</td>
<td></td>
</tr>
<tr>
<td align="left">-&gt;</td>
<td align="left">-&gt;*</td>
<td align="left">new</td>
<td align="left">new[]</td>
<td align="left">delete</td>
<td align="left">delete[]</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left"><strong>不能重载运算符</strong></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">::</td>
<td align="left">.*</td>
<td align="left">.</td>
<td align="left">? :</td>
<td align="left"></td>
<td align="left"></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>运算符函数一般通过间接调用，当然也可以直接调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">data1 + data2;<br><span class="hljs-keyword">operator</span>+(data1, data2);	<br><br>data1 += data2;<br>data1.<span class="hljs-keyword">operator</span>+=(data2);<br></code></pre></div></td></tr></table></figure>

<p>尽管有些运算符可以重载，但大多数情况下不建议重载，它们是<code>, &amp; || &amp;&amp;</code>。</p>
<p>运算符重载虽然可以为所欲为，但最好让他们的含义与内置类型一致，不要违直觉定义。</p>
<ul>
<li><strong>如果类执行IO操作，那么&lt;&lt;和&gt;&gt;就应该与内置类型的IO一致。</strong></li>
<li><strong>如果类的某个操作是检查相等性，则定义operator==，通常也应该有operator!=。</strong></li>
<li><strong>如果类包含一个内在的单序比较操作，则定义operator&lt;，如果有了&lt;，一般也有其他关系操作。</strong></li>
<li><strong>重载运算符的返回类型通常应与内置版本的返回类型兼容：逻辑运算符和关系运算符应该返回bool，算术运算符应该返回类类型的值，赋值运算符和复合赋值运算符应该返回左侧运算对象的一个引用。</strong></li>
</ul>
<p>定义重载运算符时，必须要先决定是声明为类成员函数还是普通的非成员函数。对此，有一些准则：</p>
<ul>
<li><strong>赋值、下标、调用和成员访问箭头运算符必须是成员。</strong></li>
<li><strong>复合赋值运算符一般来说应该是成员，但并非必须。</strong></li>
<li><strong>改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，应该是成员。</strong></li>
<li><strong>具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，它们应该是普通的非成员函数（成员函数则会引发<code>string u = &quot;hi&quot; + s;</code>错误的灾难）。</strong></li>
<li><strong>输入输出运算符必须是非成员函数。</strong></li>
</ul>
<table>
<thead>
<tr>
<th>是否成员函数</th>
<th>运算符类型</th>
</tr>
</thead>
<tbody><tr>
<td>必须是成员函数</td>
<td>赋值运算、下标运算、调用、箭头运算符</td>
</tr>
<tr>
<td>应该是成员函数</td>
<td>复合赋值、递增递减、解引用</td>
</tr>
<tr>
<td>应该非成员函数（应该友元函数）</td>
<td>算术运算符、关系运算符、位运算</td>
</tr>
<tr>
<td>必须非成员函数（必须友元函数）</td>
<td>输入输出</td>
</tr>
</tbody></table>
<h2 id="输入和输出运算符"><a href="#输入和输出运算符" class="headerlink" title="输入和输出运算符"></a>输入和输出运算符</h2><h3 id="重载-lt-lt"><a href="#重载-lt-lt" class="headerlink" title="重载&lt;&lt;"></a>重载&lt;&lt;</h3><p>通常输出运算符的第一个形参是一个<strong>非常量ostream对象引用</strong>。非常量是因为向流写入内容会改变其状态，而引用则是因为ostream不能拷贝。第二个形参一般是一个<strong>常量的引用</strong>，该常量是我们想要打印的类类型。这里的引用是因为我们希望避免复制实参，常量则是因为打印对象通常不会改变对象内容。</p>
<p>为了与其他&lt;&lt;一致，operator&lt;&lt;一般返回它的ostream形参。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">ostream &amp;Sales_data::<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="hljs-keyword">const</span> Sales_data &amp;item)<br>&#123;<br>    os &lt;&lt; item.<span class="hljs-built_in">isbn</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; item.revenue &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; item.<span class="hljs-built_in">avg_price</span>();<br>  	<span class="hljs-keyword">return</span> os;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>IO运算符往往需要读写类的非公有数据成员，所以IO运算符一般被声明为<strong>友元</strong>。</p>
<h3 id="重载-gt-gt"><a href="#重载-gt-gt" class="headerlink" title="重载&gt;&gt;"></a>重载&gt;&gt;</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;is, Sales_data &amp;item)<br>&#123;<br>    <span class="hljs-keyword">double</span> price;<br>  	is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;<br>  	<span class="hljs-keyword">if</span>(is)	<span class="hljs-comment">//检查输入是否成功</span><br>      	item.revenue = item.units_sold * price;<br>  	<span class="hljs-keyword">else</span><br>      	item = <span class="hljs-built_in">Sales_data</span>();	<span class="hljs-comment">//输入失败，对象被赋予默认的状态</span><br>  	<span class="hljs-keyword">return</span> is;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>和&lt;&lt;类似，但&gt;&gt;要额外考虑失败的情况。</p>
<blockquote>
<p>流含有错误类型的数据读取操作，或是到达文件末尾或遇到输入流的其他错误时会失败。</p>
</blockquote>
<h2 id="算术和关系运算符"><a href="#算术和关系运算符" class="headerlink" title="算术和关系运算符"></a>算术和关系运算符</h2><h3 id="重载-、"><a href="#重载-、" class="headerlink" title="重载==、!="></a>重载==、!=</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> Sales_data &amp;lhs, <span class="hljs-keyword">const</span> Sales_data &amp;rhs)<br>&#123;<br>    <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">isbn</span>() == rhs.<span class="hljs-built_in">isbn</span>() &amp;&amp; lhs.units_sold == rhs.units_sold &amp;&amp; lhs.revenue == rhs.revenue;<br>&#125;<br><br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> Sales_data &amp;lhs, <span class="hljs-keyword">const</span> Sales_data &amp;rhs)<br>&#123;<br>    <span class="hljs-keyword">return</span> !(lhs == rhs);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="重载关系运算符"><a href="#重载关系运算符" class="headerlink" title="重载关系运算符"></a>重载关系运算符</h3><p>定义了相等运算符的类一般也包含关系运算符。特别的，关联容器需要用到小于运算符，所以定义operator&lt;很有用。</p>
<p>通常情况下，关系运算符应该：</p>
<ol>
<li>定义顺序关系，令其与关联容器中对关键字的要求一致，并且</li>
<li>如果类同时含有<code>==</code>运算符的话，则定义一种关系令其与<code>==</code>保持一致。特别是，如果两个对象是<code>!=</code>的，那么一个对象应该<code>&lt;</code>另一个。</li>
</ol>
<p>对Sales_data类来说，关系运算符没有什么必要，因为语义上违直觉。</p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>除了拷贝赋值和移动赋值运算符以外，类还可以定义其他赋值运算符，把别的类型作为右侧运算对象。</p>
<p>比如vector支持操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vector&lt;string&gt; v;<br>v = &#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;the&quot;</span>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>之所以可以这样赋值，是因为vector类似这样重载了=运算符：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrVec</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  	StrVec &amp;<span class="hljs-keyword">operator</span>=(std::initializer_list&lt;std::string&gt;);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>复合赋值运算符虽然不一定非要是类成员，但语义上作为类成员函数更符合直觉。</p>
<h2 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a>下标运算符</h2><p>如果一个类包含下标运算符，则<strong>通常会定义两个版本</strong>：一个返回普通引用，另一个是类的常量成员并且返回常量引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrVec</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  	std::string&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-keyword">size_t</span> n)<br>    &#123;<br>        <span class="hljs-keyword">return</span> elements[n];<br>    &#125;<br>  	<span class="hljs-keyword">const</span> std::string&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-keyword">size_t</span> n) <span class="hljs-keyword">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> elements[n];<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>  	std::string *elements;	<span class="hljs-comment">//指向数组首元素的指针</span><br>&#125;；<br></code></pre></div></td></tr></table></figure>

<p>常量对象取下标会匹配调用const版本。</p>
<h2 id="递增和递减"><a href="#递增和递减" class="headerlink" title="递增和递减"></a>递增和递减</h2><p>这个比较特别，有前置版本和后置版本，所以也要定义两个版本。语义上建议作为成员函数。</p>
<h3 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrBlobPtr</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  	StrBlobPtr&amp; <span class="hljs-keyword">operator</span>++();	<span class="hljs-comment">//前置</span><br>  	strBlobPtr&amp; <span class="hljs-keyword">operator</span>--();<br>&#125;;<br><br>StrBlobPtr&amp; StrBlobPtr::<span class="hljs-keyword">operator</span>++()<br>&#123;<br>    <span class="hljs-built_in">check</span>(curr, <span class="hljs-string">&quot;increment past end of StrBlobPtr&quot;</span>);<br>  	++curr;<br>  	<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>StrBlobPtr&amp; StrBlobPtr::<span class="hljs-keyword">operator</span>--()<br>&#123;<br>  	--curr;<br>    <span class="hljs-built_in">check</span>(curr, <span class="hljs-string">&quot;decrement past bgin of StrBlobPtr&quot;</span>);<br>  	<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>前置运算符返回的是递增或递减后的对象引用。</p>
<h3 id="后置"><a href="#后置" class="headerlink" title="后置"></a>后置</h3><p>为了区分前置和后置，<strong>后置接受一个额外的不被使用的int型形参。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrBlobPtr</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  	StrBlobPtr <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>);	<span class="hljs-comment">//后置</span><br>  	StrBlobPtr <span class="hljs-keyword">operator</span>--(<span class="hljs-keyword">int</span>);	<br>&#125;;<br>StrBlobPtr StrBlobPtr::<span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>)<br>&#123;<br>    StrBlobPtr ret = *<span class="hljs-keyword">this</span>;<br>  	++*<span class="hljs-keyword">this</span>;<br>  	<span class="hljs-keyword">return</span> ret;<br>&#125;<br>StrBlobPtr StrBlobPtr::<span class="hljs-keyword">operator</span>--(<span class="hljs-keyword">int</span>)<br>&#123;<br>  	StrBlobPtr ret = *<span class="hljs-keyword">this</span>;<br>    --*<span class="hljs-keyword">this</span>;<br>  	<span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="重载-gt"><a href="#重载-gt" class="headerlink" title="重载*/-&gt;"></a>重载*/-&gt;</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrBlobPtr</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  	std::string&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span><br>    &#123;<br>        <span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">check</span>(curr, <span class="hljs-string">&quot;dereference past end&quot;</span>);<br>      	<span class="hljs-keyword">return</span> (*p)[curr];	<span class="hljs-comment">//(*p)是对象所指的vector</span><br>    &#125;<br>  	std::string* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> &amp; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">operator</span>*();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="重载"><a href="#重载" class="headerlink" title="重载()"></a>重载()</h2><p>最特别的一个。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">absInt</span>&#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> <span class="hljs-keyword">const</span></span>&#123;<br>        <span class="hljs-keyword">return</span> val &lt; <span class="hljs-number">0</span> ? -val : val;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">-42</span>;<br>absInt absObj;<br><span class="hljs-keyword">int</span> ui = <span class="hljs-built_in">absObj</span>(i);	<span class="hljs-comment">//i传递给absObj.operator()</span><br></code></pre></div></td></tr></table></figure>

<p>只能作为类成员定义，可以重载多个函数，以参数区分。</p>
<p><strong>类如果定义了调用运算符，那么该类的对象就被称为函数对象。</strong></p>
<p>lambda会被编译器翻译成一个未命名类的未命名对象。lambda表达式产生的类中含有一个重载的函数调用运算符，所以lambda表达式实际上是函数对象。</p>
<p>标准库也定义了一组函数对象，plus类定义了一个函数调用运算符用于对一对运算对象执行+操作，modules类定义了调用运算符执行二元%操作，equal_to类执行==等。</p>
<p>这些类都是类模板，需要使用时指定具体应用类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">plus&lt;<span class="hljs-keyword">int</span>&gt; intAdd;<br>negate&lt;<span class="hljs-keyword">int</span>&gt; intNegate;<br><span class="hljs-keyword">int</span> sum = <span class="hljs-built_in">intAdd</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>sum = <span class="hljs-built_in">intNegate</span>(<span class="hljs-built_in">intAdd</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>));<br>sum = <span class="hljs-built_in">intAdd</span>(<span class="hljs-number">10</span>, <span class="hljs-built_in">intNegate</span>(<span class="hljs-number">10</span>));<br></code></pre></div></td></tr></table></figure>

<p>它们定义在functional头文件中。</p>
<table>
<thead>
<tr>
<th align="left">算术</th>
<th align="left">关系</th>
<th align="left">逻辑</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>plus&lt;Type&gt;</code></td>
<td align="left"><code>equal_to&lt;Type&gt;</code></td>
<td align="left"><code>logical_and&lt;Type&gt;</code></td>
</tr>
<tr>
<td align="left"><code>minus&lt;Type&gt;</code></td>
<td align="left"><code>not_equal_to&lt;Type&gt;</code></td>
<td align="left"><code>logical_or&lt;Type&gt;</code></td>
</tr>
<tr>
<td align="left"><code>multiplies&lt;Type&gt;</code></td>
<td align="left"><code>greater&lt;Type&gt;</code></td>
<td align="left"><code>logical_not&lt;Type&gt;</code></td>
</tr>
<tr>
<td align="left"><code>divides&lt;Type&gt;</code></td>
<td align="left"><code>greater_equal&lt;Type&gt;</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>modules&lt;Type&gt;</code></td>
<td align="left"><code>less&lt;Type&gt;</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>negate&lt;Type&gt;</code></td>
<td align="left"><code>less_equal&lt;Type&gt;</code></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>函数对象的一个坑：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vector&lt;string *&gt; nameTable;<br><span class="hljs-built_in">sort</span>(nameTable.<span class="hljs-built_in">begin</span>(), nameTable.<span class="hljs-built_in">end</span>(), [](string *a, string *b)&#123;<span class="hljs-keyword">return</span> a &lt; b;&#125;);<span class="hljs-comment">//错误，nameTable中指针彼此之间没有关系，所以&lt;将产生未定义行为</span><br><span class="hljs-built_in">sort</span>(nameTable.<span class="hljs-built_in">begin</span>(), nameTable.<span class="hljs-built_in">end</span>(), less&lt;string*&gt;());<span class="hljs-comment">//正确，标准库规定指针的less是定义良好的</span><br></code></pre></div></td></tr></table></figure>

<p>后者可以用指针地址值来排序，标准库规定其函数对象对于指针同样适用，而手写的lambda就不行了。</p>
<p>C++语言中几种可调用的对象：函数、函数指针、lambda表达式、bind创建的对象以及重载了函数调用运算符的类。调用形式指明了调用返回的类型以及传递给调用的实参类型。不同的可调用对象可能具有相同的调用形式。</p>
<p>标准库<code>function</code>类型是一个模板，定义在头文件<em>functional</em>中，用来表示对象的调用形式。</p>
<table>
<thead>
<tr>
<th align="left">function的操作</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>function&lt;T&gt; f;</code></td>
<td align="left">f是一个用来存储可调用对象的空function，这些可调用对象的调用形式应该与函数类型T相同（即T是<code>retType(args)</code>）</td>
</tr>
<tr>
<td align="left"><code>function&lt;T&gt; f(nullptr);</code></td>
<td align="left">显式地构造一个空function</td>
</tr>
<tr>
<td align="left"><code>function&lt;T&gt; f(obj);</code></td>
<td align="left">在f中存储可调用对象obj的副本</td>
</tr>
<tr>
<td align="left"><code>f</code></td>
<td align="left">将f作为条件：当f含有一个可调用对象时为真，否则为假</td>
</tr>
<tr>
<td align="left"><code>f(args)</code></td>
<td align="left">调用f中的对象，参数是args</td>
</tr>
<tr>
<td align="left">定义为<code>function&lt;T&gt;</code>的成员的类型</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">result_type</td>
<td align="left">该function类型的可调用对象返回的类型</td>
</tr>
<tr>
<td align="left">argument_type</td>
<td align="left">T有一个或两个实参时定义的类型。如果T只有一个实参，</td>
</tr>
<tr>
<td align="left">first_argument_type</td>
<td align="left">则argument_type是该类型的同义词；如果T有两个实参，</td>
</tr>
<tr>
<td align="left">second_argument_type</td>
<td align="left">则first_argument_type和second_argument_type分别代表两个实参的类型</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">function&lt;<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)&gt; f1 = add;		<span class="hljs-comment">//函数指针</span><br>function&lt;<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)&gt; f2 = <span class="hljs-built_in">devide</span>();	<span class="hljs-comment">//函数对象类的对象</span><br>function&lt;<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)&gt; f3 = [](<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)&#123;<span class="hljs-keyword">return</span> i * j;&#125;;	<span class="hljs-comment">//lambda</span><br><br>cout &lt;&lt; <span class="hljs-built_in">f1</span>(<span class="hljs-number">4</span>,<span class="hljs-number">2</span>) &lt;&lt; endl;	<span class="hljs-comment">//6</span><br>cout &lt;&lt; <span class="hljs-built_in">f2</span>(<span class="hljs-number">4</span>,<span class="hljs-number">2</span>) &lt;&lt; endl;	<span class="hljs-comment">//2</span><br>cout &lt;&lt; <span class="hljs-built_in">f3</span>(<span class="hljs-number">4</span>,<span class="hljs-number">2</span>) &lt;&lt; endl;	<span class="hljs-comment">//8</span><br></code></pre></div></td></tr></table></figure>

<h2 id="重载、类型转换与运算符"><a href="#重载、类型转换与运算符" class="headerlink" title="重载、类型转换与运算符"></a>重载、类型转换与运算符</h2><p>转换构造函数和类型转换运算符共同定义了类类型转换（class-type conversion）。</p>
<h3 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h3><p>这是类的一种特殊成员函数，负责将一个类类型的值转为其他类型。<strong>它不能声明返回类型，形参列表也必须为空</strong>，形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br></code></pre></div></td></tr></table></figure>

<p>类型转换运算符可以面向除了void以外的任意类型进行定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmallInt</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SmallInt</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>): <span class="hljs-built_in">val</span>(i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt; <span class="hljs-number">255</span>)<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Bad SmallInt value&quot;</span>);<br>    &#125;   <br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> val; &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    std::<span class="hljs-keyword">size_t</span> val;<br>&#125;;<br><br><span class="hljs-comment">// 内置类型转换将double实参转换成int</span><br>SmallInt si = <span class="hljs-number">3.14</span>;     <span class="hljs-comment">// 调用SmallInt(int)构造函数</span><br><span class="hljs-comment">// SmallInt类型转换运算符将si转换成int</span><br>si + <span class="hljs-number">3.14</span>;     <span class="hljs-comment">// 内置类型转换将所得的int继续转换成double</span><br></code></pre></div></td></tr></table></figure>

<p>应该避免过度使用类型转换函数。如果在类类型和转换类型之间不存在明显的映射关系，则这样的类型转换可能具有误导性。</p>
<p>C++11引入了显示的类型转换运算符（explicit conversion operator）。和显式构造函数一样，编译器通常不会将显式类型转换运算符用于隐式类型转换。</p>
<p><strong>一旦给了类型转换运算符explicit标志</strong>，那么：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">SmallInt si = <span class="hljs-number">3</span>;	<span class="hljs-comment">//正确，SmallInt的构造函数不是显式的</span><br>si + <span class="hljs-number">3</span>;				<span class="hljs-comment">//错误：此处需要隐式的类型转换，但类型转换运算符是显式的</span><br><span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(si)+<span class="hljs-number">3</span>;	<span class="hljs-comment">//正确，显式地请求类型转换</span><br></code></pre></div></td></tr></table></figure>

<p><strong>如果表达式被用作条件，则编译器会隐式地执行显式类型转换。</strong></p>
<ul>
<li><strong>if、while、do语句的条件部分。</strong></li>
<li><strong>for语句头的条件表达式。</strong></li>
<li><strong>条件运算符<code>? :</code>的条件表达式。</strong></li>
<li><strong>逻辑非运算符<code>!</code>、逻辑或运算符<code>||</code>、逻辑与运算符<code>&amp;&amp;</code>的运算对象。</strong></li>
</ul>
<p>在两种情况下可能产生多重转换路径：</p>
<ul>
<li>A类定义了一个接受B类对象的转换构造函数，同时B类定义了一个转换目标是A类的类型转换运算符。</li>
<li>类定义了多个类型转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起。</li>
</ul>
<p>可以通过显式调用类型转换运算符或转换构造函数解决二义性问题，但不能使用强制类型转换，因为强制类型转换本身也存在二义性。</p>
<p><strong>所以，请避免有二义性的类型转换。</strong></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/c/">c++</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/09/Distributed%20System/ch1/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">分布式系统:1.introduction to Distributed Systems</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/10/27/c++/effect%201-4/">
                        <span class="hidden-mobile">effective C++ 第三版 第一章</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>





  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  








  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
