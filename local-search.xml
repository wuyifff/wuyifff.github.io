<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++ primer 读书笔记 chapter 15 面向对象程序设计</title>
    <link href="/2021/10/24/15.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2021/10/24/15.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="C-Primer-chapter-15"><a href="#C-Primer-chapter-15" class="headerlink" title="C++ Primer  chapter 15"></a>C++ Primer  chapter 15</h1><h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1><h2 id="OOP概述"><a href="#OOP概述" class="headerlink" title="OOP概述"></a>OOP概述</h2><p><strong>OOP三大核心思想：抽象、继承和多态（动态绑定）。</strong></p><ul><li><strong>数据抽象将类的接口与实现分离</strong></li><li><strong>继承可以定义相似的类型并对其相似关系建模</strong></li><li><strong>多态则在一定程度上忽略相似类型的区别，实现统一方式来使用一组对象</strong></li></ul><p>对继承来说，层次关系的根部类叫基类，其他类可以直接或间接从基类继承而来，它们叫派生类。基类负责定义在层次关系中所有类共同拥有的成员，派生类定义各自特有的成员。</p><p>而一旦有了继承，也就可以应用多态。想要解释继承和多态，再多的语言也是苍白无力。不如从一个例子说起：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Quote</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">std::string <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span> n)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-comment">//定义为虚函数，实现多态</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bulk_quote</span> :</span> <span class="hljs-keyword">public</span> Quote&#123;<span class="hljs-comment">// Bulk_quote继承了Quote</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Quote为基类，Bulk_quote为Quote的派生类（子类）。派生类通过类派生列表(class derivation list)明确指出从哪个(哪些)基类继承而来。其中关键字public表示公有继承，先不解释其作用。</p><p>基类的函数net_price前面加上virtual表示其是一个虚函数，虚函数的作用是为了实现多态。一旦基类定义了虚函数，那么派生的子类就可以通过重新定义来覆盖基类的虚函数实现。派生类可以省略virtual关键字，尽管子类中不声明virtual，覆盖函数定义仍然还是虚函数。(<strong>但是还是应该带上virtual,这样间接继承就免得去看基类的实现</strong>)</p><p>C++11标准允许派生类<strong>显式地注明</strong>它将使用哪个成员函数改写基类的虚函数，这就是上例中override关键字的作用。==（好处是万一同名参数形参列表不同将会overrid失败，编译器将会报错帮助你发现）==</p><p>virtual实现的动态绑定怎么用呢？<a href="https://www.bilibili.com/video/BV1dE41167hJ?p=22&share_source=copy_web"><strong>（翁恺c++ p23-24）</strong></a></p><iframe src="//player.bilibili.com/player.html?aid=71983220&bvid=BV1dE41167hJ&cid=124727443&page=22" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">print_total</span><span class="hljs-params">(ostream &amp;os, <span class="hljs-keyword">const</span> Quote &amp;item, <span class="hljs-keyword">size_t</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//如果item是Quote对象，调用Quote::net_price</span><br>  <span class="hljs-comment">//如果item是Bulk_quote对象，调用Bulk_quote::net_price</span><br>    <span class="hljs-keyword">double</span> ret = item.<span class="hljs-built_in">net_price</span>(n);<br>  os &lt;&lt; <span class="hljs-string">&quot;ISBN: &quot;</span> &lt;&lt; item.<span class="hljs-built_in">isbn</span>()<span class="hljs-comment">//调用Quote::isbn</span><br>      &lt;&lt; <span class="hljs-string">&quot; # sold: &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; total due: &quot;</span> &lt;&lt; ret &lt;&lt; endl;<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-built_in">print_total</span>(cout, basic, <span class="hljs-number">20</span>);<span class="hljs-comment">//basic是Quote对象</span><br><span class="hljs-built_in">print_total</span>(cout, bulk, <span class="hljs-number">20</span>);<span class="hljs-comment">//bulk是Bulk_quote对象</span><br></code></pre></td></tr></table></figure><p>可以看到尽管形参是一个const Quote对象的引用，但可以传入一个派生类对象作为实参，而一旦如此，对形参调用类成员函数时，就会进行动态绑定，即派生类调用派生类重新定义的虚函数体，基类调用基类定义的虚函数体。</p><blockquote><p>如果net_price不是虚函数，即使子类中重新定义了一模一样的net_price，对该例来说，无论传给item的对象是子类还是派生类，最终调用的都是父类的net_price。所以说<strong>虚函数才支持动态绑定</strong>。深入一点说，拥有虚函数的类对象都有虚表，忽略基类型别动态绑定到子类成员函数的过程实际上是依赖于类对象的虚表指针，因为无论对象被看成基类还是子类，它的虚表指针始终是指向正确的解绑函数的。</p></blockquote><p>所以，多态的存在可以让我们在程序设计上使用父类指针（或引用）指向子类对象，也就是所谓的“一定程度上忽略相似类型的区别，实现统一方式来使用一组对象”。</p><h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Quote</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Quote</span>() = <span class="hljs-keyword">default</span>;<span class="hljs-comment">//合成默认构造函数</span><br>  <span class="hljs-built_in">Quote</span>(<span class="hljs-keyword">const</span> std::string &amp;book, <span class="hljs-keyword">double</span> sales_price):<span class="hljs-built_in">bookNo</span>(book), <span class="hljs-built_in">price</span>(sales_price)&#123;&#125;<br>  <span class="hljs-function">std::string <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> bookNo;&#125;<br>  <span class="hljs-comment">//返回给定数量的书籍的销售总额</span><br>  <span class="hljs-comment">//派生类负责改写并使用不同的折扣计算算法</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span> n)</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">    </span>&#123;<span class="hljs-keyword">return</span> n * price;&#125;<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Quote</span>() = <span class="hljs-keyword">default</span>;<span class="hljs-comment">//对析构函数进行动态绑定</span><br><span class="hljs-keyword">private</span>:<br>  std::string bookNo;<span class="hljs-comment">//书籍的ISBN编号</span><br><span class="hljs-keyword">protected</span>:<br>  <span class="hljs-keyword">double</span> price = <span class="hljs-number">0.0</span>;<span class="hljs-comment">//代表普通状态下不打折的价格</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>为什么析构函数要定义成虚函数呢？因为我们往往使用多态时，会使用父类指针指向子类对象，而后续可能会delete父类指针，如果析构函数不是虚函数，那么delete一个子类对象不会调用子类对象的析构，而是直接调用父类的析构了，这与预期不符。</strong></p><p>所以，==拥有虚函数的父类的析构函数往往也是虚函数==（因为多态需要虚函数来实现）。</p><p>这里的一个疑点：类成员protected权限是什么？</p><h3 id="成员函数与继承"><a href="#成员函数与继承" class="headerlink" title="成员函数与继承"></a>成员函数与继承</h3><p>派生类可以继承基类的成员，基类的成员函数有两种：希望派生类进行覆盖而被声明为virtual的虚函数、希望派生类直接使用的函数。</p><p>任何构造函数之外的非静态函数都可以是虚函数。==构造函数不能virtual！==</p><blockquote><p>构造函数为什么不能virtual呢？很简单，因为构造子类理应递归的调用父类的构造器，如果父类构造器被virtual化了，那么子类就无法调用到父类的构造器了。</p></blockquote><p>普通的成员函数的解析过程发生在编译阶段，虚函数的解析过程发生在运行时(从虚表(virtual table)取函数地址)。</p><p>所以有虚函数的类会大一点，在<strong>类的开头有一个指针指向virtual table。</strong></p><p><img src="https://i.loli.net/2021/10/24/qG3HOzX9Q4kTyhs.png" alt="image-20211024153527689"></p><h3 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h3><p>派生类可以继承基类的成员，但这并不意味着派生类内部可以随意使用基类的成员。在public继承条件下，如果父类的成员是private权限，那么派生类内部无法访问，如果父类的成员是public权限，那么派生类内部可以访问。</p><p>那么，有的时候我们希望父类的一些成员也可以被子类访问，但不希望被其他外部非亲非戚的访问，private和public就都不好用了，于是，就有了protected权限。protected修饰的成员意味着派生类可以访问，外部不行。</p><p>继续定义派生类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bulk_quote</span> :</span> <span class="hljs-keyword">public</span> Quote&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Bulk_quote</span>() = <span class="hljs-keyword">default</span>;<br>  <span class="hljs-built_in">Bulk_quote</span>(<span class="hljs-keyword">const</span> std::string &amp;, <span class="hljs-keyword">double</span>, std::<span class="hljs-keyword">size_t</span>, <span class="hljs-keyword">double</span>);<br>  <span class="hljs-comment">//覆盖基类的虚函数，隐式virtual</span><br>  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-keyword">private</span>:<br>  std::<span class="hljs-keyword">size_t</span> min_qty = <span class="hljs-number">0</span>;<span class="hljs-comment">//自己的成员，折扣政策下最低购买量</span><br>  <span class="hljs-keyword">double</span> discount = <span class="hljs-number">0.0</span>;<span class="hljs-comment">//折扣额</span><br>&#125;<br></code></pre></td></tr></table></figure><p>派生类对象包含多个组成部分：含有派生类自己定义的(非静态)成员的子对象，以及一个与该类继承的基类对应的子对象，如果有多个基类，那么也就有对应多个子对象。</p><p>Bulk_quote对象</p><p>| bookNo | 从Quote继承</p><p>| price |</p><p>| min_qty | Bulk_quote自定义的成员</p><p>| discount |</p><p>之所以能完成继承，本质上是因为派生类对象中拥有基类对象。</p><p>C++标准没有规定派生类对象的内存如何分布，有兴趣可以看看《深度探索C++对象模型》，当然由于这本书比较老了，所以现在主流编译器的设计和书中内容有较大差异，但仍然极有价值，毕竟授人以渔。</p><p>因为派生类对象中含有与其基类对应的组成部分，所以可以把派生类对象当成基类对象使用，也能将基类指针或引用绑定到派生类对象的基类部分上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">Quote item;<span class="hljs-comment">//基类对象</span><br>Bulk_quote bulk;<span class="hljs-comment">//派生类对象</span><br>Quote *p = &amp;item;<span class="hljs-comment">//p指向Quote对象</span><br>p = &amp;bulk;<span class="hljs-comment">//p指向bulk的Quote部分</span><br>Quote &amp;r = bulk;<span class="hljs-comment">//r绑定到bulk的Quote部分</span><br></code></pre></td></tr></table></figure><p>这种称为派生类到基类的类型转换，编译器会隐式执行派生类到基类的转换。</p><h3 id="派生类构造函数"><a href="#派生类构造函数" class="headerlink" title="派生类构造函数"></a>派生类构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Bulk_quote</span>(<span class="hljs-keyword">const</span> std::string &amp;book, <span class="hljs-keyword">double</span> p, std::<span class="hljs-keyword">size_t</span> qty, <span class="hljs-keyword">double</span> disc) : <span class="hljs-built_in">Quote</span>(book, p), <span class="hljs-built_in">min_qty</span>(qty), <span class="hljs-built_in">discount</span>(disc)&#123;&#125;<br></code></pre></td></tr></table></figure><p>初始化列表中调用了Quote的构造函数，用来负责初始化基类部分。</p><p>除非特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。如果想使用其他的基类构造函数，我们需要以类名加圆括号内的实参列表的形式为构造函数提供初始值。</p><p>派生类的构造器总是先初始化基类部分，再按声明顺序依次初始化派生类成员。</p><h3 id="派生类使用基类的成员"><a href="#派生类使用基类的成员" class="headerlink" title="派生类使用基类的成员"></a>派生类使用基类的成员</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Bulk_quote::net_price</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> cnt)</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(cnt &gt;= min_qty)<br>      <span class="hljs-keyword">return</span> cnt * (<span class="hljs-number">1</span> - discount) * price;<br>  <span class="hljs-keyword">else</span><br>      <span class="hljs-keyword">return</span> cnt * price;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="继承与静态成员"><a href="#继承与静态成员" class="headerlink" title="继承与静态成员"></a>继承与静态成员</h3><p>如果基类定义了静态成员，则整个继承体系中只存在该成员的唯一定义。不论基类中派生出多少个派生类，对每个静态成员来说都只存在唯一的一个实例。</p><blockquote><p>因为静态成员实际上是全局的，当然是单例。只是语法上为了关系结构，把它放在类中定义。</p></blockquote><p>另外，静态成员也遵循访问控制权限。</p><p>派生类的声明不能包含派生列表，直接<code>class Bulk_quote;</code>就行了。</p><p>C++11可以定义一种不允许其他类继承的类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoDerived</span> <span class="hljs-keyword">final</span>&#123;</span><span class="hljs-comment">/* */</span>&#125;;<span class="hljs-comment">//NoDerived不能做基类</span><br></code></pre></td></tr></table></figure><p>嗯，C++居然反向抄袭了java。</p><h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><p>通常当把引用或指针绑定到一个对象时，引用或指针的类型得和对象的类型一致，或者对象类型含有一个可接受的const类型转换规则。但对于继承类来说还有一个特例，那就是可以把基类的指针或引用绑定到派生类对象上，为了实现多态。</p><blockquote><p>智能指针也支持这一类型转换，所以可以将派生类对象指针存在基类智能指针之内。</p></blockquote><ul><li>从派生类向基类的类型转换只对指针或引用类型有效。</li><li>基类向派生类不存在隐式类型转换。</li><li>派生类向基类的类型转换也可能会由于访问受限而变得不可行。</li></ul><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>对虚函数的调用在运行时被解析。派生类覆盖虚函数定义需要保证型别完全一致。</p><blockquote><p>有一个例外就是虚函数在基类中如果返回基类指针或引用时，派生类中是可以返回派生类的指针或引用的，这是唯一的一个可行的型别不一致的地方，但这种不一致也有前提条件，即派生类到基类的类型转换是可访问的（不能访问受限）。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span>&#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-keyword">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-comment">//这个例子可以看出override的用处，可以直观的找出错误，没有override编译器会曲解原本的意图</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">D1</span> :</span> B&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span>;<span class="hljs-comment">//正确，f1与基类型别一致</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-keyword">override</span></span>;<span class="hljs-comment">//错误，B没有该函数</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<span class="hljs-comment">//错误，f3不是虚函数</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f4</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<span class="hljs-comment">//错误，B没有f4</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">D2</span> :</span> B&#123;<br>  <span class="hljs-comment">//继承B的f2(),f3(),覆盖f1(int)</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">final</span></span>;<span class="hljs-comment">//不允许后续的其他类覆盖f1(int)</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">D3</span> :</span> D2&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//正确：覆盖从间接基类B继承而来的f2()</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-comment">//错误，D2已经声明f1为final了</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>虚函数也可以声明final来阻止派生类覆盖。</p><h3 id="回避虚函数的机制"><a href="#回避虚函数的机制" class="headerlink" title="回避虚函数的机制"></a>回避虚函数的机制</h3><p>有时候不希望动态绑定，而是调用某个虚函数的特定版本，可以通过作用域运算符来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> undiscounted = baseP-&gt;Quote::<span class="hljs-built_in">net_price</span>(<span class="hljs-number">42</span>);<br></code></pre></td></tr></table></figure><p>无论baseP实际上是啥类型，最后调用的都是Quote的net_price，这是编译时期确定的。</p><p>通常只有成员函数(或友元)的代码才需要这种hack技巧。比如派生类虚函数想要调用父类的虚函数版本。</p><h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p>有时候父类指向声明一个函数接口，不想实际定义，希望由派生类来定义。C++允许这种设计，可以在virtual的基础上定义纯虚函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Disc_quote</span> :</span> <span class="hljs-keyword">public</span> Quote&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Disc_quote</span>() = <span class="hljs-keyword">default</span>;<br>  <span class="hljs-built_in">Disc_quote</span>(<span class="hljs-keyword">const</span> std::string &amp;book, <span class="hljs-keyword">double</span> price, std:<span class="hljs-keyword">size_t</span> qty, <span class="hljs-keyword">double</span> disc):<span class="hljs-built_in">Quote</span>(book, price), <span class="hljs-built_in">quantity</span>(qty), <span class="hljs-built_in">discount</span>(disc) &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span>)</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-comment">//=0表示纯虚函数</span><br><span class="hljs-keyword">protected</span>:<br>  std::<span class="hljs-keyword">size_t</span> quantity = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">double</span> discount = <span class="hljs-number">0.0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>纯虚函数无需定义，=0只能出现在类内部的虚函数声明语句处。</p><p>纯虚函数也可以定义，但必须在类外部定义，大部分情况不会定义，因为这与我们的使用意图相悖。</p><p>类只要含有纯虚函数，就是一个抽象基类，抽象基类负责定义接口，后续的其他类来覆盖接口。不能创建抽象基类的对象，抽象基类需要派生类去继承。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bulk_quote</span> :</span> <span class="hljs-keyword">public</span> Disc_quote&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Bulk_quote</span>() = <span class="hljs-keyword">default</span>;<br>  <span class="hljs-built_in">Bulk_quote</span>(<span class="hljs-keyword">const</span> std::string &amp;book, <span class="hljs-keyword">double</span> price, std::<span class="hljs-keyword">size_t</span> qty, <span class="hljs-keyword">double</span> disc):<span class="hljs-built_in">Disc_quote</span>(book, price, qty, disc)&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>直接基类是Disc_quote，间接基类是Quote。各个类控制自己的构造器，构造器会递归下去，先执行根基类构造器，最后执行自身的构造。继承链的构造器形成了层的概念。</p><h2 id="访问控制与继承-1"><a href="#访问控制与继承-1" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><p>protected的一个坑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span>&#123;</span><br><span class="hljs-keyword">protected</span>:<br>  <span class="hljs-keyword">int</span> prot_mem;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sneaky</span> :</span> <span class="hljs-keyword">public</span> Base&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clobber</span><span class="hljs-params">(Sneaky&amp;)</span></span>;<span class="hljs-comment">//可以访问Sneaky::prot_mem</span><br>  <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clobber</span><span class="hljs-params">(Base&amp;)</span></span>;<span class="hljs-comment">//不能访问Base::prot_mem</span><br>  <span class="hljs-keyword">int</span> j;<span class="hljs-comment">//j默认是private</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clobber</span><span class="hljs-params">(Sneaky &amp;s)</span></span>&#123;s.j = s.prot_mem = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//clobber可以访问Sneaky的private和protected成员</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clobber</span><span class="hljs-params">(Base &amp;b)</span></span>&#123;b.prot_mem = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//clobber不能访问Base的protected成员</span><br></code></pre></td></tr></table></figure><p>之所以有这种限制，是因为如果第二个用法合法的话，那么就可以通过定义一个形如Sneaky的新类来规避掉protected提供的访问保护了。</p><p>所以，派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员，而不能访问普通的基类对象中的成员。</p><h3 id="public、private和protected"><a href="#public、private和protected" class="headerlink" title="public、private和protected"></a>public、private和protected</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pub_mem</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">protected</span>:</span><br><span class="hljs-function">  int prot_mem;</span><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">char</span> priv_mem;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pub_Derv</span> :</span> <span class="hljs-keyword">public</span> Base&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> prot_mem;&#125;<span class="hljs-comment">//正确：派生类能访问protected成员</span><br>  <span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> priv_mem;&#125;<span class="hljs-comment">//错误：private成员对于派生类来说是不可访问的</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Priv_Derv</span> :</span> <span class="hljs-keyword">private</span> Base&#123;<br>    <span class="hljs-comment">//private不影响派生类的访问权限</span><br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>&#123;<span class="hljs-keyword">return</span> prot_mem;&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Prot_Derv</span> :</span> <span class="hljs-keyword">protected</span> Base&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>&#123;<span class="hljs-keyword">return</span> prot_mem;&#125;<span class="hljs-comment">//依然是protected</span><br>&#125;<br>Pub_Derv d1;<span class="hljs-comment">//继承自Base的成员遵循原有的访问说明符</span><br>Priv_Derv d2;<span class="hljs-comment">//继承自Base的成员无论此前是什么权限，都变成private</span><br>d1.<span class="hljs-built_in">pub_mem</span>();<span class="hljs-comment">//正确：pub_mem在派生类中是public的</span><br>d2.<span class="hljs-built_in">pub_mem</span>();<span class="hljs-comment">//错误：pub_mem在派生类中是private的</span><br><br>Prot_Derv d3;<span class="hljs-comment">//继承自Base的成员如果是public，会变成protected，其他不变</span><br>d3.<span class="hljs-built_in">pub_mem</span>();<span class="hljs-comment">//错误，pub_mem是protected，只能成员和友元访问，外部不行</span><br></code></pre></td></tr></table></figure><h3 id="派生类向基类转换的可访问性"><a href="#派生类向基类转换的可访问性" class="headerlink" title="派生类向基类转换的可访问性"></a>派生类向基类转换的可访问性</h3><ul><li>只有当D公有继承B时，用户代码才能使用派生类向基类的转换，如果D继承B的方式是受保护或私有继承，则用户代码不能使用该转换。</li><li>无论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换，派生类向直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。</li><li>如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的类型转换；反之，如果D继承B的方式是私有的，则不能使用。</li></ul><p>说白了就一个规则：</p><p><strong>对代码中某个给定节点，如果基类的公有成员是可访问的，则派生类向基类的转换就是可访问的，反之则不行。</strong></p><p><strong>友元关系不能继承。</strong></p><p>class默认继承权限是private，struct是public。这一点和类成员权限很相似。</p><h2 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h2><p>派生类的作用域位于基类作用域之内，因此才可以实现派生类访问基类成员。</p><p>如果派生类重用了基类的成员名字，那么基类的对应成员就会被隐藏。此时想要访问隐藏的成员，就要通过域运算符，这一手法类似调用特定虚函数版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fcn</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D1</span> :</span> <span class="hljs-keyword">public</span> Base&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">//隐藏基类的fcn，这个fcn不是虚函数</span><br>  <span class="hljs-comment">//D1继承了Base::fcn()的定义</span><br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fcn</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-comment">//形参列表与Base中的fcn不一致</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//新的虚函数，在Base中不存在</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D2</span> :</span> <span class="hljs-keyword">public</span> D1&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fcn</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-comment">//非虚函数，隐藏了D1::fcn(int)</span><br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fcn</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//覆盖了Base的虚函数fcn</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//覆盖了D1的虚函数f2</span><br>&#125;;<br><br>Base bobj;<br>D1 d1obj;<br>D2 d2obj;<br><br>Base *bp1 = &amp;bobj, *bp2 = &amp;d1obj, *bp3 = &amp;d2obj;<br>bp1-&gt;<span class="hljs-built_in">fcn</span>();<span class="hljs-comment">//虚调用，运行时调用Base::fcn</span><br>bp2-&gt;<span class="hljs-built_in">fcn</span>();<span class="hljs-comment">//虚调用，运行时调用Base::fcn</span><br>bp3-&gt;<span class="hljs-built_in">fcn</span>();<span class="hljs-comment">//虚调用，运行时调用D2::fcn</span><br><br>D1 *d1p = &amp;d1obj; D2 *d2p = &amp;d2obj;<br>bp2-&gt;<span class="hljs-built_in">f2</span>();<span class="hljs-comment">//错误，Base没有f2成员</span><br>d1p-&gt;<span class="hljs-built_in">f2</span>();<span class="hljs-comment">//虚调用，运行时调用D1::f2()</span><br>d2p-&gt;<span class="hljs-built_in">f2</span>();<span class="hljs-comment">//虚调用，运行时调用D2::f2()</span><br><br>Base *p1 = &amp;d2obj; D1 *p2 = &amp;d2obj; D2 *p3 = &amp;d2obj;<br>p1-&gt;<span class="hljs-built_in">fcn</span>(<span class="hljs-number">42</span>);<span class="hljs-comment">//错误：Base中没有接受一个int的fcn</span><br>p2-&gt;<span class="hljs-built_in">fcn</span>(<span class="hljs-number">42</span>);<span class="hljs-comment">//静态绑定，调用D1::fcn(int)</span><br>p3-&gt;<span class="hljs-built_in">fcn</span>(<span class="hljs-number">42</span>);<span class="hljs-comment">//静态绑定，调用D2::fcn(int)</span><br></code></pre></td></tr></table></figure><h2 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h2><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>这一点已经说过了，如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义行为。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">Quote *itemP = <span class="hljs-keyword">new</span> Quote;<br><span class="hljs-keyword">delete</span> itemP;<span class="hljs-comment">//调用Quote的析构</span><br>itemP = <span class="hljs-keyword">new</span> Bulk_quote;<span class="hljs-comment">//静态类型与动态类型不一致</span><br><span class="hljs-keyword">delete</span> itemP;<span class="hljs-comment">//如果Quote析构是虚函数，则调用Bulk_quote，否则调用Quote析构</span><br></code></pre></td></tr></table></figure><p>三五准则中曾言，如果类需要析构函数，往往也需要拷贝构造和赋值操作，但对虚析构函数来说不遵守该准侧。</p><p><strong>虚析构函数将阻止合成移动操作。</strong></p><h3 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h3><p>构造器的调用链：</p><ul><li>合成的Bulk_quote默认构造函数运行Disc_quote的默认构造函数，后者又运行Quote的默认构造函数。</li><li>Quote的默认构造函数将bookNo成员默认初始化为空串，同时使用类内初始化值将price初始化为0。</li><li>Quote的构造函数完成后，继续执行Disc_quote的构造函数，它使用类内初始化qty和discount。</li><li>Disc_quote的构造函数完成后，继续执行Bulk_quote的构造函数，但什么具体工作也没做。</li></ul><p>类似的，合成的Bulk_quote的拷贝构造也一样，调用Disc_quote的拷贝构造，后者又调用了Quote的拷贝构造。</p><ul><li>如果基类的默认构造、拷贝构造、拷贝赋值运算符或析构函数是被删除的函数或不可访问，则派生类中对应的成员也将是删除的。</li><li>如果基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数是删除的，因为编译器无法销毁派生类对象的基类部分。</li><li>编译器不会合成一个删除掉的移动操作。使用=default请求一个移动操作时，如果基类中对应的操作是删除的或不可访问的，那么派生类中该函数将是被删除的，因为派生类对象的基类部分不可移动。同理，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。</li></ul><p>如果确实需要移动操作，那就应该在基类中自己去定义，否则会因为虚析构的存在而默认被delete。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span>&#123;</span>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> :</span> <span class="hljs-keyword">public</span> Base&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">D</span>(<span class="hljs-keyword">const</span> D&amp; d) : <span class="hljs-built_in">Base</span>(d)<br>    <span class="hljs-built_in">D</span>(D&amp;&amp; d) : <span class="hljs-built_in">Base</span>(std::<span class="hljs-built_in">move</span>(d))<br>  D &amp;D::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> D &amp;rhs)&#123;<br>        Base::<span class="hljs-keyword">operator</span>=(rhs);<br>      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h3><p>C++11可以让派生类重用基类定义的构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bulk_quote</span> :</span> <span class="hljs-keyword">public</span> Disc_quote&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">using</span> Disc_quote::Disc_quote;<span class="hljs-comment">//继承了Disc_quote的构造函数</span><br>  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span>)</span> <span class="hljs-keyword">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>编译器会生成形如:<code>derived(params) : base(args)&#123;&#125;</code>的构造函数。这里的using作用给编译器，而不是当前作用域。</p><p>using声明语句不能指定constexpr或explicit，所以它继承基类的修饰。</p><p>基类构造函数含有默认实参时，默认实参不会被继承。相反，派生类或获得多个继承的构造函数，每个构造函数分别省略掉一个含有默认实参的形参。</p><p>如果基类有好几个构造函数，则大多数情况下派生类继承所有构造函数。除了两个例外，其一是派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本。如果派生类定义的构造函数与基类构造函数具有相同的参数列表，则这些构造函数不会被继承。其二是默认、拷贝和移动构造不会被继承。它们按照正常规则来合成，游离于三界之外。</p><h2 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;Quote&gt; basket;<br>basket.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Quote</span>(<span class="hljs-string">&quot;0-201-82470-1&quot;</span>, <span class="hljs-number">50</span>));<br><span class="hljs-comment">//正确，但是只能把对象的Quote部分拷贝给basket</span><br>basket.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Bulk_quote</span>(<span class="hljs-string">&quot;0-201-54858-8&quot;</span>, <span class="hljs-number">50</span>, <span class="hljs-number">10</span>, <span class="hljs-number">.25</span>));<br><span class="hljs-comment">//调用Quote定义的版本</span><br>cout &lt;&lt; basket.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">net_price</span>(<span class="hljs-number">15</span>) &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>因为存放的是对象，所以类型转换上会阉割。</p><p>想要多态必须要间接访问，对容器来说也一样，我们要存放指针而不是对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;shared_ptr&lt;Quote&gt;&gt; basket;<br>basket.<span class="hljs-built_in">push_back</span>(make_shared&lt;Quote&gt;(<span class="hljs-string">&quot;0-201-82470-1&quot;</span>, <span class="hljs-number">50</span>));<br>basket.<span class="hljs-built_in">push_back</span>(make_shared&lt;Bulk_quote&gt;(<span class="hljs-string">&quot;0-201-54848-8&quot;</span>, <span class="hljs-number">50</span>, <span class="hljs-number">10</span>, <span class="hljs-number">.25</span>));<br>cout &lt;&lt; basket.<span class="hljs-built_in">back</span>()-&gt;<span class="hljs-built_in">net_price</span>(<span class="hljs-number">15</span>) &lt;&lt; endl;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ primer 读书笔记 chapter 12 动态内存与智能指针</title>
    <link href="/2021/10/20/12.%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"/>
    <url>/2021/10/20/12.%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="C-primer-chapter-12"><a href="#C-primer-chapter-12" class="headerlink" title="C++ primer chapter 12"></a>C++ primer chapter 12</h1><h1 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h1><h2 id="动态内存与智能指针"><a href="#动态内存与智能指针" class="headerlink" title="动态内存与智能指针"></a>动态内存与智能指针</h2><p>C++中的动态内存管理通过一对运算符完成：<code>new</code>在动态内存中为对象分配空间并返回指向该对象的指针，可以选择对对象进行初始化；<code>delete</code>接受一个<strong>动态对象的指针</strong>，销毁该对象并释放与之关联的内存。</p><p>如果忘记释放内存，就会产生内存泄露。而如果在<strong>尚有指针引用内存的情况下释放内存</strong>，可能产生野指针的使用。</p><p>为了安全，标准库提供了两种智能指针(smart pointer)类型来管理动态对象。智能指针的行为类似常规指针，区别在于它负责自动释放所指向的对象。新标准库提供的这两种智能指针的区别在于管理底层指针的方式：<strong>shared_ptr</strong> 允许多个指针指向同一个对象；<strong>unique_pt</strong>r则独占所指向的对象。标准库还定义了名为<strong>weak_ptr</strong>的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。三者均在memory头文件中定义。</p><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>智能指针也是<strong>类模板</strong>（具有析构函数，在离开作用域析构阶段自动销毁）。</p><p>默认初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">shared_ptr&lt;string&gt; p1;<span class="hljs-comment">//shared_ptr，可以指向string</span><br>shared_ptr&lt;list&lt;<span class="hljs-keyword">int</span>&gt;&gt; p2;<span class="hljs-comment">//shared_ptr, 可以指向int的list</span><br></code></pre></td></tr></table></figure><p>默认初始化的智能指针保存<strong>空指针</strong>。</p><p>使用方式类似普通指针，通过解引用返回对象。</p><table><thead><tr><th align="left">shared_ptr与unique_ptr都支持的操作</th><th align="left"></th></tr></thead><tbody><tr><td align="left"><code>shared_ptr&lt;T&gt; sp</code> / <code>unique_ptr&lt;T&gt; up</code></td><td align="left">空智能指针，可以指向类型为T的对象</td></tr><tr><td align="left"><code>p</code></td><td align="left">将p用作一个条件判断，若p指向一个对象，则为true</td></tr><tr><td align="left"><code>*p</code></td><td align="left">解引用p，获得它指向的对象</td></tr><tr><td align="left"><code>p-&gt;mem</code></td><td align="left">等价于(*p).mem</td></tr><tr><td align="left"><code>p.get()</code></td><td align="left">返回p中保存的指针。要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了</td></tr><tr><td align="left"><code>swap(p, q) </code>/<code>p.swap(q)</code></td><td align="left">交换p和q中的指针</td></tr></tbody></table><table><thead><tr><th align="left">shared_ptr独有的操作</th><th align="left"></th></tr></thead><tbody><tr><td align="left"><strong><code>make_shared&lt;T&gt;(args)</code></strong></td><td align="left">返回一个shared_ptr，指向一个动态分配的类型为T的对象。使用args初始化此对象</td></tr><tr><td align="left"><code>shared_ptr&lt;T&gt; p(q)</code></td><td align="left">p是shared_ptr q的拷贝；此操作会递增q中的计数器。q中的指针必须能转换为T*</td></tr><tr><td align="left"><code>p = q</code></td><td align="left">p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0，则将其管理的原内存释放</td></tr><tr><td align="left"><code>p.unique()</code></td><td align="left">若p.use_count()为1，返回true；否则返回false</td></tr><tr><td align="left"><code>p.use_count()</code></td><td align="left">返回与p共享对象的智能指针数量；可能很慢，主要用于调试</td></tr></tbody></table><p>make_shared标准库函数是<strong>分配使用动态内存最安全的方式</strong>，在内存中创建一个对象并初始化它。定义在memory头文件中。</p><p>make_shared用其参数来构造给定类型的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; p3 = make_shared&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">42</span>);<span class="hljs-comment">//42</span><br>shared_ptr&lt;string&gt; p4 = make_shared&lt;string&gt;(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;9&#x27;</span>);<span class="hljs-comment">//&quot;9999999999&quot;，体现args</span><br>shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; p5 = make_shared&lt;<span class="hljs-keyword">int</span>&gt;();<span class="hljs-comment">//值初始化，即为0</span><br><span class="hljs-keyword">auto</span> p6 = make_shared&lt;vector&lt;string&gt;&gt;();<span class="hljs-comment">//更通用的定义</span><br></code></pre></td></tr></table></figure><h3 id="shared-ptr的拷贝和赋值"><a href="#shared-ptr的拷贝和赋值" class="headerlink" title="shared_ptr的拷贝和赋值"></a>shared_ptr的拷贝和赋值</h3><p>拷贝或赋值时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> p = make_shared&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">42</span>);<span class="hljs-comment">//p指向的对象只有p一个引用者</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">q</span><span class="hljs-params">(p)</span></span>;<span class="hljs-comment">//p和q指向相同对象，此对象有两个引用者</span><br></code></pre></td></tr></table></figure><p>每个shared_ptr都有一个<strong>引用计数</strong>。<strong>拷贝shared_ptr会递增计数器</strong>。用一个shared_ptr初始化另一个shared_ptr，或作为参数传递给一个函数或作为函数的返回值时，引用计数都会递增。而shared_ptr赋予其他值时或是shared_ptr被销毁时（比如局部的shared_ptr离开其作用域），计<strong>数器会递减</strong>。</p><p>一旦shared_ptr计数器变为0，它会<strong>自动释放自己管理的对象</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> r = make_shared&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">42</span>);<span class="hljs-comment">//r指向的int只有一个引用者</span><br>r = q;<span class="hljs-comment">//给r赋值，令它指向另一个地址</span><br><span class="hljs-comment">//递增q指向的对象的引用计数</span><br><span class="hljs-comment">//递减r原本指向对象的引用计数</span><br><span class="hljs-comment">//r原本指向对象的引用计数变为0，自动释放</span><br></code></pre></td></tr></table></figure><p>shared_ptr类的自动销毁对象是通过其析构函数完成的。析构函数会递减它所指向对象的引用计数，如果引用计数变为0，shared_ptr的析构函数会销毁对象并释放空间。</p><p>如果将shared_ptr存放于容器中，一段时间过后不需要全部元素，而只使用其中一部分，应该用erase删除不再需要的元素，如此才能得以释放内存（如果没有其他的引用的话）。</p><p>程序使用动态内存通常出于以下三种原因之一：</p><ul><li>不确定需要使用多少对象。</li><li>不确定所需对象的准确类型。</li><li>需要在多个对象间共享数据。</li></ul><h3 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h3><p>直接使用new和delete是C++的一把双刃剑。</p><p>默认情况下，动态分配的对象是默认初始化的。所以内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">string *ps = <span class="hljs-keyword">new</span> string;<span class="hljs-comment">//初始化为空字符串</span><br><span class="hljs-keyword">int</span> *pi = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<span class="hljs-comment">//pi指向未初始化int</span><br></code></pre></td></tr></table></figure><p>可以使用<strong>值初始化方式、直接初始化方式、传统构造方式（圆括号<code>()</code>）或新标准下的列表初始化方式（花括号<code>&#123;&#125;</code>）</strong>初始化动态分配的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *pi = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-number">1024</span>);<br>string *ps = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;9&#x27;</span>);<br>vector&lt;<span class="hljs-keyword">int</span>&gt; *pv = <span class="hljs-keyword">new</span> vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br>string *ps1 = <span class="hljs-keyword">new</span> string;<span class="hljs-comment">//默认初始化，空串</span><br>string *ps = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>();<span class="hljs-comment">//值初始化，空串</span><br><span class="hljs-keyword">int</span> *pi1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<span class="hljs-comment">//默认初始化，值未定义</span><br><span class="hljs-keyword">int</span> *pi2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>();<span class="hljs-comment">//值初始化为0</span><br></code></pre></td></tr></table></figure><p>对定义了构造函数的类类型来说，无论是值初始化还是默认初始化，都会调用默认构造函数。<strong>而内置类型则不同，值初始化有着良好定义的值，默认初始化则未定义。</strong></p><p>可以用new分配const对象，返回指向const类型的指针。<strong>动态分配的const对象必须初始化</strong>。</p><p>如果动态内存被耗尽，new表达式就会失败，默认情况下new失败时会抛出类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//如果分配失败，new返回一个空指针</span><br><span class="hljs-keyword">int</span> *p1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<span class="hljs-comment">//分配失败，则new抛出std::bad_alloc</span><br><span class="hljs-keyword">int</span> *p2 = <span class="hljs-built_in"><span class="hljs-keyword">new</span></span> (nothrow) <span class="hljs-keyword">int</span>;<span class="hljs-comment">//如果分配失败，则new返回一个空指针</span><br></code></pre></td></tr></table></figure><p>后者的new形式称为定位new。定位new表达式可以传递额外的参数，这里传递了一个标准库定义的名为nothrow的对象，意为不要抛出异常。</p><blockquote><p>nothrow和bad_alloc定义在new头文件中。</p></blockquote><p>释放内存通过delete表达式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">delete</span> p;<span class="hljs-comment">//p必须指向一个动态分配的对象或是一个空指针</span><br></code></pre></td></tr></table></figure><p>释放并非new分配的内存，或者将相同的指针值释放多次，行为是未定义的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i, *pi1 = &amp;i, *pi2 = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">double</span> *pd = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(<span class="hljs-number">33</span>), *pd2 = pd;<br><span class="hljs-keyword">delete</span> i;<span class="hljs-comment">//错误：i不是指针</span><br><span class="hljs-keyword">delete</span> pi1;<span class="hljs-comment">//未定义：pi1指向一个局部变量</span><br><span class="hljs-keyword">delete</span> pd;<span class="hljs-comment">//正确</span><br><span class="hljs-keyword">delete</span> pd2;<span class="hljs-comment">//未定义：pd2指向的内存已经被释放了</span><br><span class="hljs-keyword">delete</span> pi2;<span class="hljs-comment">//正确：释放空指针总是没有错误的</span><br></code></pre></td></tr></table></figure><p>new出来的const对象也可以delete，尽管对象本身不能改变。</p><h3 id="shared-ptr和new的联用"><a href="#shared-ptr和new的联用" class="headerlink" title="shared_ptr和new的联用"></a>shared_ptr和new的联用</h3><p>new返回的指针可以初始化智能指针，<strong>智能指针的构造函数是explicit的</strong>，因此<strong>必须使用直接初始化形式</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-number">1024</span>);<span class="hljs-comment">//错误：必须使用直接初始化</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">1024</span>))</span></span>;<span class="hljs-comment">//正确：使用了直接初始化</span><br></code></pre></td></tr></table></figure><p>默认情况下，用来初始化<strong>智能指针的内置指针必须指向动态内存</strong>，因为智能指针默认使用delete释放它所管理的对象。如果要将智能指针绑定到一个指向其他类型资源的指针上，就必须提供自定义操作来代替delete。</p><table><thead><tr><th align="left">定义和改变shared_ptr的其他方法</th><th align="left"></th></tr></thead><tbody><tr><td align="left"><code>shared_ptr&lt;T&gt; p(q)</code></td><td align="left">p管理内置指针q所指向的对象；q必须指向new分配的内存，且能够转换为T*类型</td></tr><tr><td align="left"><code>shared_ptr&lt;T&gt; p(u)</code></td><td align="left">p从unique_ptr u那里接管了对象的所有权；将u置为空</td></tr><tr><td align="left"><code>shared_ptr&lt;T&gt; p(q, d)</code></td><td align="left">p接管了内置指针q所指向的对象的所有权。q必须能转为T*类型。p将使用可调用对象d来代替delete</td></tr><tr><td align="left"><code>shared_ptr&lt;T&gt; p(p2, d)</code></td><td align="left">p是shared_ptr p2的拷贝，唯一的区别是p将用可调用对象d来代替delete</td></tr><tr><td align="left"><code>p.reset()</code></td><td align="left">置p为空，若p是唯一指向其对象的shared_ptr，reset会释放此对象。</td></tr><tr><td align="left"><code>p.reset(q)</code></td><td align="left">若传递了可选的参数内置指针q，会令p指向q，否则会将p置空。</td></tr><tr><td align="left"><code>p.reset(q, d)</code></td><td align="left">若还传递了参数d，将会调用d而不是delete来释放q</td></tr></tbody></table><p>区分<code>shared_ptr&lt;T&gt; p(q, d)</code> 和 <code>p.reset(q, d)</code> 中参数 d 的语义</p><p><strong>不要混合使用内置指针和智能指针</strong>。当将shared_ptr绑定到内置指针后，资源管理就应该交由shared_ptr负责。不应该再使用内置指针访问shared_ptr指向的内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 函数被调用时ptr被创建并初始化</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 使用ptr</span><br>&#125;   <span class="hljs-comment">// ptr离开作用域，被销毁</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">1024</span>))</span></span>;   <span class="hljs-comment">// 危险：x是一个普通指针，不是智能指针</span><br><span class="hljs-built_in">process</span>(x);     <span class="hljs-comment">// 错误：无法转换 int* 到 shared_ptr&lt;int&gt;</span><br><span class="hljs-built_in">process</span>(shared_ptr&lt;<span class="hljs-keyword">int</span>&gt;(x));    <span class="hljs-comment">// 合法，但是内存会被释放</span><br><span class="hljs-keyword">int</span> j = *x;     <span class="hljs-comment">// 未定义的：x是悬垂指针</span><br><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>))</span></span>;   <span class="hljs-comment">// 引用计数为1</span><br><span class="hljs-built_in">process</span>(p);     <span class="hljs-comment">// 拷贝p会增加它的引用计数，process中引用计数为2</span><br><span class="hljs-keyword">int</span> i = *p;     <span class="hljs-comment">// 正确：引用计数为1</span><br></code></pre></td></tr></table></figure><p>智能指针的<code>get</code>函数<strong>返回一个内置指针</strong>，指向智能指针管理的对象。主要<strong>用于向不能使用智能指针的代码传递内置指针</strong>。使用get返回指针的代码不能delete此指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>))</span></span>;<span class="hljs-comment">//引用计数为1</span><br><span class="hljs-keyword">int</span> *q = p.<span class="hljs-built_in">get</span>();<span class="hljs-comment">//正确：但使用q要注意，不要让它管理的指针被释放</span><br>&#123;<span class="hljs-comment">//新程序块</span><br>    <span class="hljs-comment">//未定义：两个独立的shared_ptr指向相同的内存</span><br>  shared_ptr&lt;<span class="hljs-keyword">int</span>&gt;(q);<br>&#125;<span class="hljs-comment">//程序块结束，q被销毁，它指向的内存被释放</span><br><span class="hljs-keyword">int</span> foo = *p;<span class="hljs-comment">//未定义：p指向的内存已经被释放了</span><br></code></pre></td></tr></table></figure><p>花式作死的另一种用法。</p><blockquote><p>永远不要用get初始化另一个智能指针或为另一个智能指针赋值。</p></blockquote><p>reset可以将新指针赋予shared_ptr：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">p = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-number">1024</span>);<span class="hljs-comment">//错误：不能将一个指针赋予shared_ptr</span><br>p.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-number">1024</span>));<span class="hljs-comment">//正确：p指向一个新对象</span><br></code></pre></td></tr></table></figure><p>与赋值类似，reset会更新引用计数，如果需要的话，会释放p指向的对象。reset成员经常与unique一起用，来控制多个shared_ptr共享的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(!p.<span class="hljs-built_in">unique</span>())<br>  p.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(*p));<span class="hljs-comment">//不是唯一用户；分配新的拷贝</span><br>*p += newVal;<span class="hljs-comment">//现在我们知道自己是唯一的用户，可以改变对象的值</span><br></code></pre></td></tr></table></figure><h3 id="智能指针和异常"><a href="#智能指针和异常" class="headerlink" title="智能指针和异常"></a>智能指针和异常</h3><p>如果使用智能指针，<strong>即使程序块过早结束</strong>，智能指针类也能确保在内存不再需要时将其释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> *ip = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-number">42</span>);<br>  <span class="hljs-comment">//这段代码抛出异常，且在f中未被捕获</span><br>  <span class="hljs-keyword">delete</span> ip;<span class="hljs-comment">//退出之前释放内存</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>标准的内存泄露</strong>。</p><p>而如果:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sp</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>))</span></span>;<br>  <span class="hljs-comment">//这段代码抛出异常，且在f中未捕获</span><br>&#125;<span class="hljs-comment">//函数结束时shared_ptr自动释放内存</span><br></code></pre></td></tr></table></figure><p>默认情况下shared_ptr假定其指向动态内存，使用delete释放对象。创建shared_ptr时可以传递一个（可选）指向删除函数的指针参数，用来代替delete。这个删除器(deleter)函数必须能够完成对shared_ptr中保存的指针进行释放的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">destination</span>;</span>  <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">connection</span>;</span>     <br><span class="hljs-function">connection <span class="hljs-title">connect</span><span class="hljs-params">(destination*)</span></span>;   <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">disconnect</span><span class="hljs-params">(connection)</span></span>;   <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">end_connection</span><span class="hljs-params">(connection *p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">disconnect</span>(*p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(destination &amp;d <span class="hljs-comment">/* 其他参数 */</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    connection c = <span class="hljs-built_in">connect</span>(&amp;d);<br>    <span class="hljs-function">shared_ptr&lt;connection&gt; <span class="hljs-title">p</span><span class="hljs-params">(&amp;c, end_connection)</span></span>;<br>    <span class="hljs-comment">// 使用连接</span><br>    <span class="hljs-comment">// f退出时（即使是异常退出），connection会被正确关闭</span><br>&#125;<br></code></pre></td></tr></table></figure><p>==<strong>智能指针规范</strong>：==</p><ul><li><strong>不使用相同的内置指针值初始化或reset多个智能指针。</strong></li><li><strong>不释放get返回的指针。</strong></li><li>==<strong>不使用get初始化或reset另一个智能指针。</strong>==</li><li><strong>使用get返回的指针时，如果最后一个对应的智能指针被销毁，指针就无效了。</strong></li><li><strong>使用shared_ptr管理并非new分配的资源时，应该传递删除函数。</strong></li></ul><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>与shared_ptr不同，同一时刻只能有一个unique_ptr指向给定的对象。当unique_ptr被销毁时，它指向的对象也会被销毁。</p><p><code>make_unique</code>函数（C++14新增，定义在头文件<em>memory</em>中）在动态内存中分配一个对象并初始化它，返回指向此对象的unique_ptr。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>))</span></span>;<br><span class="hljs-comment">// C++14  C11没有make_unique</span><br>unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; p2 = make_unique&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">42</span>);<br></code></pre></td></tr></table></figure><p>由于unique_ptr<strong>独占</strong>其指向的对象，因此<strong>unique_ptr不支持普通的拷贝或赋值操作</strong>。</p><table><thead><tr><th align="left">unique_ptr操作</th><th align="left"></th></tr></thead><tbody><tr><td align="left"><code>unique_ptr&lt;T&gt; u1</code></td><td align="left">空unique_ptr，可以指向类型为T的对象。u1会使用delete来释放它的指针；u2会使用一个类型为D的可调用对象来释放它的指针</td></tr><tr><td align="left"><code>unique_ptr&lt;T, D&gt; u2</code></td><td align="left"></td></tr><tr><td align="left"><code>unique_ptr&lt;T, D&gt; u(d)</code></td><td align="left">空unique_ptr，指向类型为T的对象，用类型为D的对象d代替delete</td></tr><tr><td align="left"><code>u = nullptr</code></td><td align="left">释放u指向的对象，将u置空</td></tr><tr><td align="left"><code>u.release()</code></td><td align="left">u放弃对指针的控制权，返回指针，并将u置空</td></tr><tr><td align="left"><code>u.reset()</code></td><td align="left">释放u指向的对象</td></tr><tr><td align="left"><code>u.reset(q)</code></td><td align="left">如果提供了内置指针q，令u指向这个对象，否则u置空</td></tr><tr><td align="left"><code>u.reset(nullptr)</code></td><td align="left"></td></tr></tbody></table><p>unique_ptr<strong>不能拷贝或赋值，但可以转移</strong>：(release 和 reset)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//将所有权从p1转移给p2</span><br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p2</span><span class="hljs-params">(p1.release())</span></span>;<span class="hljs-comment">//release将p1置空</span><br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;Trex&quot;</span>))</span></span>;<br><span class="hljs-comment">//将所有权从p3转移给p2</span><br>p2.<span class="hljs-built_in">reset</span>(p3.<span class="hljs-built_in">release</span>());<span class="hljs-comment">//reset释放了p2原来指向的内存</span><br><br>p2.<span class="hljs-built_in">release</span>();<span class="hljs-comment">//错误：p2不会释放内存，而且我们弄丢了指针</span><br><span class="hljs-keyword">auto</span> p = p2.<span class="hljs-built_in">release</span>();<span class="hljs-comment">//正确，但我们必须记得delete(p)</span><br></code></pre></td></tr></table></figure><p>不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">clone</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>&#123;<br>    <span class="hljs-comment">//正确：从int*创建一个unique_ptr&lt;int&gt;</span><br>  <span class="hljs-keyword">return</span> unique_ptr&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(p));<br>&#125;<br></code></pre></td></tr></table></figure><p>还可以返回一个局部对象的拷贝：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">clone</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>&#123;<br>    <span class="hljs-function">unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ret</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(p))</span></span>;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似shared_ptr，默认情况下unique_ptr用delete释放其指向的对象。unique_ptr的删除器同样可以重载，但unique_ptr管理删除器的方式与shared_ptr不同。<strong>定义unique_ptr时必须在尖括号中提供删除器类型</strong>。创建或reset这种unique_ptr类型的对象时，必须提供一个指定类型的可调用对象（删除器）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//p指向一个类型为objT的对象，并使用一个类型为delT的对象释放objT对象</span><br><span class="hljs-comment">//它会调用一个名为fcn的delT类型对象</span><br><span class="hljs-function">unique_ptr&lt;objT, delT&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> objT, fcn)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(destination &amp;d<span class="hljs-comment">/* 其他参数 */</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    connection c = <span class="hljs-built_in">connect</span>(&amp;d);<br>  <span class="hljs-function">unique_ptr&lt;connection, <span class="hljs-title">decltype</span><span class="hljs-params">(end_connection)</span>*&gt; <span class="hljs-title">p</span><span class="hljs-params">(&amp;c, end_connection)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr是一种不控制所指向对象生存期的智能指针，它指向一个由shared_ptr管理的对象。将weak_ptr绑定到shared_ptr不会改变shared_ptr的引用计数。<strong>如果shared_ptr被销毁，即使有weak_ptr指向对象，对象仍然有可能被释放</strong>。</p><table><thead><tr><th align="left">weak_ptr</th><th align="left"></th></tr></thead><tbody><tr><td align="left"><code>weak_ptr&lt;T&gt; w</code></td><td align="left">空weak_ptr可以指向类型为T的对象</td></tr><tr><td align="left"><code>weak_ptr&lt;T&gt; w(sp)</code></td><td align="left">与shared_ptr sp指向相同对象的weak_ptr。T必须能转换为sp指向的类型</td></tr><tr><td align="left">w = p</td><td align="left">p可以是一个shared_ptr或一个weak_ptr。赋值后w与p共享对象</td></tr><tr><td align="left">w.reset()</td><td align="left">w置空</td></tr><tr><td align="left">w.use_count()</td><td align="left">与w共享对象的<strong>shared_ptr的数量</strong></td></tr><tr><td align="left">w.expired()</td><td align="left">若w.use_count()为0，返回true，否则返回false</td></tr><tr><td align="left">w.lock()</td><td align="left">如果expired为true，返回空shared_ptr；否则返回一个指向w的对象的shared_ptr</td></tr></tbody></table><p>创建一个weak_ptr时，<strong>需要使用shared_ptr来初始化它</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> p = make_shared&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">42</span>);<br><span class="hljs-function">weak_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">wp</span><span class="hljs-params">(p)</span></span>;    <span class="hljs-comment">// wp弱共享p，p引用计数不变</span><br></code></pre></td></tr></table></figure><p>由于对象可能不存在，所以<strong>weak_ptr访问对象前，要先lock</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; np = wp.<span class="hljs-built_in">lock</span>())&#123;<span class="hljs-comment">//np不为空则条件成立</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><h3 id="new和数组"><a href="#new和数组" class="headerlink" title="new和数组"></a>new和数组</h3><p>数组是个很特别的存在，对于数组的动态分配和释放C++定义了相应的手法。</p><h4 id="new"><a href="#new" class="headerlink" title="new []"></a>new []</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *pia = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-built_in">get_size</span>()];<span class="hljs-comment">// pia指向第一个int，调用get_size确定分配多少个int</span><br></code></pre></td></tr></table></figure><p>方括号中的大小必须是整型，但不一定非要常量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> arrT[<span class="hljs-number">42</span>];<br><span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> arrT;<span class="hljs-comment">//实际上还是用的new[]而非new</span><br></code></pre></td></tr></table></figure><p>new返回的是一个元素类型的指针，指向第一个分配的成员。</p><p>C++中，<strong>动态数组不是数组类型</strong>，所以begin或end是不可以使用的，也不能用范围for语句来处理动态数组。</p><p>默认情况下，new分配的对象是默认初始化的。可以对数组中的元素进行<strong>值初始化</strong>，方法是在大小**后面跟一对空括号<code>()</code>**。在新标准中，还可以提供一个元素初始化器的花括号列表。如果初始化器数量大于元素数量，则new表达式失败，不会分配任何内存，并抛出bad_array_new_length异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *pia = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];     <span class="hljs-comment">// 10个未初始化的int</span><br><span class="hljs-keyword">int</span> *pia2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>]();    <span class="hljs-comment">// 10个值初始化为的int</span><br>string *psa = <span class="hljs-keyword">new</span> string[<span class="hljs-number">10</span>];    <span class="hljs-comment">// 10个空string</span><br>string *psa2 = <span class="hljs-keyword">new</span> string[<span class="hljs-number">10</span>]();    <span class="hljs-comment">// 10个空string</span><br><span class="hljs-comment">//10个int分别用列表中对应的初始化器初始化</span><br><span class="hljs-keyword">int</span> *pia3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>] &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span> &#125;;<br><span class="hljs-comment">//10个string，前4个用给定的初始化器初始化，剩余的进行值初始化</span><br>string *psa3 = <span class="hljs-keyword">new</span> string[<span class="hljs-number">10</span>] &#123; <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;the&quot;</span>, <span class="hljs-built_in">string</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;x&#x27;</span>) &#125;;<br></code></pre></td></tr></table></figure><p>虽然可以使用空括号对new分配的数组元素进行值初始化，但不能在括号中指定初始化器。这意味着不能用auto分配数组。</p><p>动态分配一个空数组是合法的，此时new会返回一个合法的非空指针。对于零长度的数组来说，该指针类似尾后指针，不能解引用。</p><h4 id="delete"><a href="#delete" class="headerlink" title="delete []"></a>delete []</h4><p>对应<code>new[]</code>，使用==<code>delete[]</code>==释放动态数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">delete</span> p;<span class="hljs-comment">//p必须指向一个动态分配的对象或空</span><br><span class="hljs-keyword">delete</span> [] pa;<span class="hljs-comment">//pa必须指向动态分配的数组或空</span><br></code></pre></td></tr></table></figure><p>数组中元素按逆序销毁。如果忽略了方括号，那么行为未定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> arrT[<span class="hljs-number">42</span>];<br><span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> arrT;<br><span class="hljs-keyword">delete</span> [] p;<span class="hljs-comment">//这个方括号是必须的。</span><br></code></pre></td></tr></table></figure><h4 id="智能指针和动态数组"><a href="#智能指针和动态数组" class="headerlink" title="智能指针和动态数组"></a>智能指针和动态数组</h4><p>unique_ptr可以直接管理动态数组，**定义时需要在对象类型后添加一对空方括号<code>[]</code>**。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">unique_ptr&lt;<span class="hljs-keyword">int</span>[]&gt; <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>])</span></span>;<br>up.<span class="hljs-built_in">release</span>();<span class="hljs-comment">//自动使用delete []来销毁指针</span><br></code></pre></td></tr></table></figure><p>指向数组的unique_ptr的操作有些不同：</p><table><thead><tr><th align="left">指向数组的unique_ptr</th><th align="left"></th></tr></thead><tbody><tr><td align="left"><code>unique_ptr&lt;T[]&gt; u</code></td><td align="left">u可以指向一个动态分配的数组，数组元素类型为T</td></tr><tr><td align="left"><code>unique_ptr&lt;T[]&gt; u(p)</code></td><td align="left">u指向内置指针p所指向的动态分配的数组。p必须能转换为类型T*</td></tr><tr><td align="left">u[i]</td><td align="left">返回u拥有的数组中i处的对象，u必须指向一个数组</td></tr></tbody></table><p>指向数组的unique_ptr不支持成员访问运算符(.和-&gt;)。</p><p>shared_ptr不直接支持管理动态数组，如果希望使用shared_ptr管理动态数组，必须提供自定义的删除器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sp</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>], [](<span class="hljs-keyword">int</span> *p)&#123;<span class="hljs-keyword">delete</span>[] p;&#125;)</span></span>;<br>sp.<span class="hljs-built_in">reset</span>();<span class="hljs-comment">//使用我们提供的lambda释放数组，它使用delete []</span><br></code></pre></td></tr></table></figure><p>如果未提供删除器，则代码是未定义的。</p><p>shared_ptr不支持下标运算符，且不支持指针的算数运算，所以需要借助get。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span>;i!=<span class="hljs-number">10</span>;++i)&#123;<br>    *(sp.<span class="hljs-built_in">get</span>() + i) = i;<span class="hljs-comment">//使用get获取一个内置指针</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a>allocator类</h3><p>allocator类也是一个类模板，定义时必须指定其分配的对象类型。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">allocator&lt;<span class="hljs-built_in">string</span>&gt; alloc;    <span class="hljs-comment">// 可以分配string的allocator对象</span><br><span class="hljs-built_in">auto</span> <span class="hljs-keyword">const</span> p = alloc.allocate(n);   <span class="hljs-comment">// 分配n个未初始化的string</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">标准库allocator类及其算法</th><th align="left"></th></tr></thead><tbody><tr><td align="left"><code>allocator&lt;T&gt; a</code></td><td align="left">定义了一个名为a的allocator对象，它可以为类型为T的对象分配内存</td></tr><tr><td align="left"><code>a.allocate(n)</code></td><td align="left">分配一段原始的、未构造的内存，保存n个类型为T的对象</td></tr><tr><td align="left"><code>a.deallocate(p, n)</code></td><td align="left">释放从T*指针p中地址开始的内存，这块内存保存了n个类型为T的对象；p必须是一个先前由allocate返回的指针，且n必须是p创建时所要求的大小。调用deallocate前，用户必须对每个在这块内存中创建的对象调用destroy</td></tr><tr><td align="left"><code>a.construct(p, args)</code></td><td align="left">p必须是一个类型为T<em>的指针，指向一块原始内存；*<em>arg被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象</em></em></td></tr><tr><td align="left"><code>a.destroy(p)</code></td><td align="left">p为T*类型的指针，此算法对p指向的对象执行析构函数</td></tr></tbody></table><p>allocator分配的内存是未构造的，程序需要在此内存中构造对象。新标准库的<code>construct</code>函数接受一个指针和零或多个额外参数，在给定位置构造一个元素。额外参数用来初始化构造的对象，必须与对象类型相匹配。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> q = p;     <span class="hljs-comment">// q指向最后构造的元素之后的位置</span><br>alloc.<span class="hljs-built_in">construct</span>(q++);    <span class="hljs-comment">// *q为空字符串</span><br>alloc.<span class="hljs-built_in">construct</span>(q++, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;c&#x27;</span>);  <span class="hljs-comment">// *q为cccccccccc</span><br>alloc.<span class="hljs-built_in">construct</span>(q++, <span class="hljs-string">&quot;hi&quot;</span>);     <span class="hljs-comment">// *q为hi</span><br></code></pre></td></tr></table></figure><p>在未构造对象前使用原始内存是错误的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; *p &lt;&lt; endl;<span class="hljs-comment">//正确：使用string的输出运算符</span><br>cout &lt;&lt; *q &lt;&lt; endl;<span class="hljs-comment">//灾难：q指向未构造的内存！</span><br></code></pre></td></tr></table></figure><p>用完对象后，需要对每个构造的元素调用destroy来销毁它们。函数destroy接受一个指针，对指向的对象执行析构函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(q != p)<br>  alloc.<span class="hljs-built_in">destroy</span>(--q);<span class="hljs-comment">//释放我们真正构造的string</span><br></code></pre></td></tr></table></figure><p>注意只能对已构造的对象进行destroy。</p><p>destroy后的内存可以重用。</p><p>全部destroy后，可以调用deallocate来归还内存给系统。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">alloc.<span class="hljs-built_in">deallocate</span>(p, n);<br></code></pre></td></tr></table></figure><p>标准库还为allocator类定义了两个伴随算法，可以在未初始化内存中创建对象。</p><table><thead><tr><th align="left">allocator算法</th><th align="left"></th></tr></thead><tbody><tr><td align="left">uninitialized_copy(b,e,b2)</td><td align="left">从迭代器b和e指定的输入范围中拷贝元素到迭代器b2指定的未构造的原始内存中。b2指向的内存必须足够大。</td></tr><tr><td align="left">uninitialized_copy_n(b,n,b2)</td><td align="left">从迭代器b指向的元素开始，拷贝n个元素到b2开始的内存中</td></tr><tr><td align="left">uninitialized_fill(b,e,t)</td><td align="left">在迭代器b和e指定的原始内存范围中创建对象，对象的值均为t的拷贝</td></tr><tr><td align="left">uninitialized_fill_n(b,n,t)</td><td align="left">从迭代器b指向的内存地址开始创建n个对象。b必须指向足够大的未构造的原始内存</td></tr></tbody></table><p>这些函数在给定目的位置创建元素，而不是由系统分配内存给它们。它们在memory头文件中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> p = alloc.<span class="hljs-built_in">allocate</span>(vi.<span class="hljs-built_in">size</span>() * <span class="hljs-number">2</span>);<br><span class="hljs-keyword">auto</span> q = <span class="hljs-built_in">uninitialized_copy</span>(vi.<span class="hljs-built_in">begin</span>(), vi.<span class="hljs-built_in">end</span>(), p);<span class="hljs-comment">//返回递增后的目的位置迭代器。</span><br><span class="hljs-built_in">uninitialized_fill_n</span>(q, vi.<span class="hljs-built_in">size</span>(), <span class="hljs-number">42</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ primer 读书笔记 chapter 7 类</title>
    <link href="/2021/10/19/7.%E7%B1%BB/"/>
    <url>/2021/10/19/7.%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="C-primer-chapter-7"><a href="#C-primer-chapter-7" class="headerlink" title="C++ primer chapter 7"></a>C++ primer chapter 7</h1><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类的基本思想是<strong>数据抽象（data abstraction）</strong>和<strong>封装（encapsulation）</strong>。数据抽象是一种依赖于<strong>接口（interface）</strong>和<strong>实现（implementation）</strong>分离的编程及设计技术。<strong>类的接口</strong>包括用户所能执行的操作；<strong>类的实现</strong>包括类的数据成员、负责接口实现的函数体以及其他私有函数。</p><h2 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h2><p>使用class或是struct关键字可以定义类类型，struct是为了兼容旧式C风格结构体，对于定义类类型来说，struct和class的<strong>唯一区别在于默认访问权限不同</strong>。</p><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>成员函数通过一个名为this的<strong>隐式参数</strong>来访问调用它的对象。this是一个<strong>常量指针</strong>，无法改变this中保存的地址。</p><h3 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h3><p>isbn函数的参数列表后跟随了一个const关键字，这里的const是用来<strong>修改隐式this指针的类型</strong>。</p><p>默认情况下，this类型是指向类类型非常量版本的常量指针。比如Sales_data类成员函数中，this的类型是<code>Sales_data *const</code>。尽管this是隐式的，但它仍然需要遵守初始化规则，这就意味着我们不能把this绑定到一个常量对象上。因此，受这一限制，我们无法在一个常量对象上调用普通的成员函数。</p><p>因为this是隐式的，我们没有办法像修饰其他参数一样，去声明其为指向常量的指针，所以C++的语法只好提供实现途径——把const关键字放在成员函数的参数列表之后，此时，this就是一个<strong>指向常量的指针</strong>，这种const成员函数被叫做<strong>常量成员函数</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//伪代码，说明隐式this指针是如何使用的</span><br><span class="hljs-comment">//下面的代码非法：我们不能显式地定义自己的this指针</span><br><span class="hljs-comment">//此处的this是一个指向常量的指针，因为isbn是一个常量成员</span><br><span class="hljs-function">std::string <span class="hljs-title">Sales_data::isbn</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Sales_data *<span class="hljs-keyword">const</span> <span class="hljs-keyword">this</span>)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;isbn;&#125;<br></code></pre></td></tr></table></figure><p>因为this指向常量，所以常量成员函数不能改变调用它的对象的内容。只读不可写。</p><h3 id="外部定义成员函数"><a href="#外部定义成员函数" class="headerlink" title="外部定义成员函数"></a>外部定义成员函数</h3><p>注意需要加作用域运算符，否则谁知道你定义的是谁的成员。</p><p>为了实现<strong>连续调用链</strong>，可以令成员函数返回this对象本身：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Sales_data &amp;<span class="hljs-title">Sales_data::combine</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Sales_data &amp;rhs)</span></span><br><span class="hljs-function"></span>&#123;<br>    units_sold += rhs.units_sold;<br>  revenue += rhs.revenue;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">// 返回调用该函数的对象</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>类的作者往往还需要定义一些辅助函数，这些函数不作为类的成员函数，但也作为类的接口的一部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">istream &amp;<span class="hljs-title">read</span><span class="hljs-params">(istream &amp;is, Sales_data &amp;item)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">double</span> price = <span class="hljs-number">0</span>;<br>  is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;<br>  item.revenue = price * item.units_sold;<br>  <span class="hljs-keyword">return</span> is;<br>&#125;<br><span class="hljs-function">ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(ostream &amp;os, <span class="hljs-keyword">const</span> Sales_data &amp;item)</span></span><br><span class="hljs-function"></span>&#123;<br>    os &lt;&lt; item.<span class="hljs-built_in">isbn</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="hljs-string">&quot; &quot;</span><br>      &lt;&lt; item.revenue &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt; item.<span class="hljs-built_in">avg_price</span>();<br>  <span class="hljs-keyword">return</span> os;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>每个类都定义了对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫构造函数。构造函数的任务是<strong>初始化类对象的数据成员</strong>，无论何时只要类的对象被创建，就会执行构造函数。</p><p>==构造函数的名字和类名一致，没有返回类型==，构造函数可以重载，不能被声明成const（因为创建一个const对象时，会先调用构造函数，再得到const属性）。</p><h4 id="合成的默认构造函数"><a href="#合成的默认构造函数" class="headerlink" title="合成的默认构造函数"></a>合成的默认构造函数</h4><p>如果类不定义任何构造函数，编译器会提供一个没有任何实参的默认构造函数。编译器创建的构造函数也叫合成的默认构造函数。</p><p>合成的默认构造函数完成以下任务：</p><ul><li>如果存在类内的初始值，用它来初始化成员。</li><li>否则，默认初始化该成员。</li></ul><p><strong>一旦</strong>定义了一个构造函数，那么编译器不再合成默认构造函数，即使我们定义的构造函数并不是没有参数的默认构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Sales_data</span>&#123;</span><br>    <span class="hljs-built_in">Sales_data</span>() = <span class="hljs-keyword">default</span>;<br>  <span class="hljs-built_in">Sales_data</span>(<span class="hljs-keyword">const</span> std::string &amp;s):<span class="hljs-built_in">bookNo</span>(s)&#123;&#125;<br>  <span class="hljs-built_in">Sales_data</span>(<span class="hljs-keyword">const</span> std::string &amp;s, <span class="hljs-keyword">unsigned</span> n, <span class="hljs-keyword">double</span> p):<span class="hljs-built_in">bookNo</span>(s), <span class="hljs-built_in">units_sold</span>(n), <span class="hljs-built_in">revenue</span>(p*n)&#123;&#125;<br>  <span class="hljs-built_in">Sales_data</span>(std::istream &amp;);<br>  std::string bookNo;<br>  <span class="hljs-keyword">unsigned</span> units_sold = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">double</span> revenue = <span class="hljs-number">0.0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>=default</strong>是<strong>C11</strong>引入的， 用于<strong>显式要求</strong>编译器合成默认构造函数（因为定义了其他构造函数，编译器不会自动合成默认构造函数，但我们又想要编译器提供的默认构造函数，所以这是一种偷懒的语法糖）。</p><p>=default可以出现在类的内部，<strong>也可以出现在外部</strong>，内部意味着inline。</p><p>紧跟在构造函数参数列表之后在花括号之前的部分是初始值列表。它负责为新创建的对象的一个或几个数据成员赋初值。被忽略的成员则将以合成默认构造函数相同的方式隐式初始化。</p><p>C++的编译器并不都支持类内初始值。为了可移植性，最好用初始值列表。</p><h3 id="拷贝、赋值和析构"><a href="#拷贝、赋值和析构" class="headerlink" title="拷贝、赋值和析构"></a>拷贝、赋值和析构</h3><p>除了构造函数以外，类还有3个特殊的成员函数：拷贝构造、赋值操作和析构。</p><p>拷贝构造会在拷贝初始化变量和值传递方式传递或返回一个对象时被调用。</p><p>赋值操作则在对类对象使用赋值运算符时会被调用。</p><p>而析构函数则在对象被销毁时被调用。</p><p>与构造函数类似，如果不去定义这3个成员，编译器也会默认合成。关于这一议题，后面第13章会单独讲解。</p><h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><p>C++用访问说明符加强了类的封装性：</p><ul><li>定义在public说明符之后的成员在整个程序内都可以被访问，<strong>public成员定义类的接口</strong>。</li><li>定义在private说明符之后的成员<strong>仅可以被类的内部成员函数访问</strong>，外部代码无法访问，private封装了类的实现细节。</li><li>struct的默认访问权限是public，class的默认访问权限是private。</li></ul><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>加上了权限之后，一些外部接口函数就无法访问类的private成员，这种情况要么提供public接口，要么就使用友元。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sales_data</span>&#123;</span><br><span class="hljs-function"><span class="hljs-keyword">friend</span> Sales_data <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Sales_data&amp;, <span class="hljs-keyword">const</span> Sales_data&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> std::istream &amp;<span class="hljs-title">read</span><span class="hljs-params">(std::istream&amp;, Sales_data&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> std::ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(std::ostream&amp;, <span class="hljs-keyword">const</span> Sales_data&amp;)</span></span>;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>friend关键字用于表示这三个函数是类Sales_data的友元函数，如此这三个函数可以访问类的private成员。friend相当于白名单，除了友元函数以外，<strong>还可以定义友元类</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span>&#123;</span><br>  <span class="hljs-comment">// Window_mgr的成员可以访问Screen类的private成员</span><br><span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Window_mgr</span>;</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>每个类负责控制自己的友元类和友元函数。</p><p>有时候整个类作为友元比较冒险，可以只对类的几个成员函数声明为友元：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span>&#123;</span><br>  <span class="hljs-comment">// Window_mgr::clear必须在Screen类之前被声明</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Window_mgr::clear</span><span class="hljs-params">(ScreenIndex)</span></span>;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>但是要注意声明的前后关系</strong></p><h2 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h2><p>在外部定义的成员函数也可以通过inline关键字来显式内联。</p><p>成员函数也是可以重载的。</p><h3 id="可变数据成员"><a href="#可变数据成员" class="headerlink" title="可变数据成员"></a>可变数据成员</h3><p>使用关键字<code>mutable</code>可以声明可变数据成员（mutable data member）。可变数据成员永远不会是const的，即使它在const对象内。因此const成员函数可以修改可变成员的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span> </span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">some_member</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-keyword">size_t</span> access_ctr;  <span class="hljs-comment">// may change even in a const object</span><br>    <span class="hljs-comment">// other members as before</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Screen::some_member</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function"></span>&#123;<br>    ++access_ctr;   <span class="hljs-comment">// keep a count of the calls to any member function</span><br>    <span class="hljs-comment">// whatever other work this member needs to do</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类内初始值花括号初始化"><a href="#类内初始值花括号初始化" class="headerlink" title="类内初始值花括号初始化"></a>类内初始值花括号初始化</h3><p>类内初始值除了=初始化形式以外，还可以用花括号形式（C++11）：</p><p>（对screens对象列表初始化）（类内初始值的两种初始化方式）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Window_mgr</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">//默认情况下，一个Window_mgr包含一个标准尺寸的空白Screen</span><br>  std::vector&lt;Screen&gt; screens&#123;<span class="hljs-built_in">Screen</span>(<span class="hljs-number">24</span>, <span class="hljs-number">80</span>, <span class="hljs-string">&#x27; &#x27;</span>)&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="为什么要返回-this"><a href="#为什么要返回-this" class="headerlink" title="为什么要返回*this"></a>为什么要返回*this</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//返回引用成为左值</span><br>myScreen.<span class="hljs-built_in">move</span>(<span class="hljs-number">4</span>,<span class="hljs-number">0</span>).<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;#&#x27;</span>);<br><span class="hljs-comment">//返回的是拷贝,只能改变临时副本</span><br>Screen temp = myScreen.<span class="hljs-built_in">move</span>(<span class="hljs-number">4</span>,<span class="hljs-number">0</span>);<br>temp.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;#&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>const成员函数</strong>以引用形式返回*this，则它的返回类型将是<strong>常量引用</strong>。</p><h3 id="成员函数可以基于const重载"><a href="#成员函数可以基于const重载" class="headerlink" title="成员函数可以基于const重载"></a>成员函数可以基于const重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">Screen &amp;<span class="hljs-title">display</span><span class="hljs-params">(std::ostream &amp;os)</span></span><br><span class="hljs-function">    </span>&#123;<span class="hljs-built_in">do_display</span>(os);<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125; <br>    <span class="hljs-comment">//非常量版本调用do_display时，this指针将隐式的从指向非常量的指针转换成指向常量的指针</span><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> Screen &amp;<span class="hljs-title">display</span><span class="hljs-params">(std::ostream &amp;os)</span> <span class="hljs-keyword">const</span> </span><br><span class="hljs-function">    </span>&#123;<span class="hljs-built_in">do_display</span>(os);<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">do_display</span><span class="hljs-params">(std::ostream &amp;os)</span> <span class="hljs-keyword">const</span> </span>&#123;os &lt;&lt; contents;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>因为<strong>非常量版本的函数对于常量对象是不可用的</strong>，所以只能在常量对象上调用const成员函数。尽管明面上参数列表相同，<strong>但实际上隐式的this指针类型是不同的，区别在于是否有底层const</strong>。</p><p>当我们在对象上调用display()时，该对象是否const决定了应该调用display的哪个版本。</p><h3 id="友元-1"><a href="#友元-1" class="headerlink" title="友元"></a>友元</h3><ul><li><p>允许特定的<strong>非成员函数</strong>访问一个类的<strong>私有成员</strong>.</p></li><li><p>友元的声明以关键字 <code>friend</code>开始。</p><p><code>friend Sales_data add(const Sales_data&amp;, const Sales_data&amp;);</code>表示非成员函数<code>add</code>可以访问类的非公有成员。</p></li><li><p>通常将友元声明成组地放在<strong>类定义的开始或者结尾</strong>。</p></li><li><p>类之间的友元：</p><p>如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。</p></li><li><p><strong>友元不具有传递性</strong></p></li><li><p>声明重载函数为友元必须指明参数</p></li><li><p>可以把另一个类的公有成员函数声明为自己的友元函数。</p><p>必须按照三步走，很容易出错。（<strong>前向声明、不完全类型</strong>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span> <span class="hljs-comment">//提前引用声明，因为友元A中要用到B，必须让编译器知道B为一个类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">disp</span><span class="hljs-params">(B &amp;b)</span></span>;<span class="hljs-comment">//只能声明不能定义，因为类B内部还没有定义</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">A::disp</span><span class="hljs-params">(B &amp;b)</span></span>;  <span class="hljs-comment">//声明友元函数</span><br>&#125;;<br><span class="hljs-comment">//这时候才可以去定义友元函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">A::disp</span><span class="hljs-params">(B &amp;b)</span></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;B::val=&quot;</span>&lt;&lt;b.val&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><ul><li>每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由引用、对象、指针使用成员访问运算符来访问。</li><li>函数的<strong>返回类型</strong>通常在函数名前面，因此<strong>当成员函数定义在类的外部</strong>时，返回类型中使用的名字都位于类的作用域之外。</li><li>如果成员使用了外层作用域中的某个名字，而该名字代表一种<strong>类型</strong>，则类不能在之后重新定义该名字。</li><li>类中的<strong>类型名定义</strong>都要放在一开始。</li></ul><h2 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a>构造函数再探</h2><h3 id="构造函数和初始化列表"><a href="#构造函数和初始化列表" class="headerlink" title="构造函数和初始化列表"></a>构造函数和初始化列表</h3><p>初始值列表提供了成员初始化的机会，如果在构造函数体内对成员进行赋值，那执行的就是赋值操作了（**==区分初始化和赋值==*），对于类类型来说，<strong>初始化和赋值操作可能行为不一致</strong>。</p><p>如果成员是<strong>const、引用，或者是某种未定义默认构造函数的类类型</strong>，==必须==在初始值列表中将其初始化。（因为const不能用赋值来初始化）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConstRef</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ConstRef</span>(<span class="hljs-keyword">int</span> ii);<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci;<br>    <span class="hljs-keyword">int</span> &amp;ri;<br>&#125;;<br><br>ConstRef::<span class="hljs-built_in">ConstRef</span>(<span class="hljs-keyword">int</span> ii): <span class="hljs-built_in">i</span>(ii), <span class="hljs-built_in">ci</span>(ii), <span class="hljs-built_in">ri</span>(i) &#123; &#125; <br></code></pre></td></tr></table></figure><p>最好令构造函数初始值的顺序与成员声明的<strong>顺序一致</strong>，并且尽量避免使用某些成员初始化其他成员。因为类成员的初始化顺序与它们在类定义中出现的顺序一致。</p><p>如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。</p><h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>C++11引入了委托构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sales_data</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-comment">//非委托构造函数使用对应实参初始化成员</span><br>  <span class="hljs-built_in">Sales_data</span>(std:string s, <span class="hljs-keyword">unsigned</span> cnt, <span class="hljs-keyword">double</span> price):<span class="hljs-built_in">bookNo</span>(s), <span class="hljs-built_in">units_sold</span>(cnt), <span class="hljs-built_in">revenue</span>(cnt*price)&#123;&#125; <span class="hljs-comment">//该构造函数函数体为空</span><br>  <span class="hljs-comment">//其余构造函数全都委托给另一个构造函数</span><br>  <span class="hljs-built_in">Sales_data</span>():<span class="hljs-built_in">Sales_data</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)&#123;&#125;  <span class="hljs-comment">//默认构造函数委托给第一个constructor</span><br>  <span class="hljs-built_in">Sales_data</span>(std::string s):<span class="hljs-built_in">Sales_data</span>(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)&#123;&#125;<br>  <span class="hljs-built_in">Sales_data</span>(std::istream &amp;is):<span class="hljs-built_in">Sales_data</span>()&#123;<span class="hljs-built_in">read</span>(is, *<span class="hljs-keyword">this</span>);&#125;<br>    <span class="hljs-comment">//委托给默认构造函数，默认构造函数委托给第一个constructor</span><br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数值被依次执行，然后控制权才会交还给委托者的函数体（例子中恰好函数体为空）。</p><h4 id="默认构造函数的作用"><a href="#默认构造函数的作用" class="headerlink" title="默认构造函数的作用"></a>默认构造函数的作用</h4><p>默认初始化的发生情况：</p><ul><li>在块作用域内不使用初始值定义非静态变量或数组。</li><li>类本身含有类类型的成员且使用合成默认构造函数。</li><li>类类型的成员没有在构造函数初始值列表中显式初始化。</li></ul><p>值初始化的发生情况：</p><ul><li>数组初始化时提供的初始值数量少于数组大小。</li><li>不使用初始值定义局部静态变量。</li><li>通过<code>T()</code>形式（<em>T</em>为类型）的表达式显式地请求值初始化。</li></ul><p>类必须包含一个默认构造函数以便在上述情况下使用。</p><h3 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h3><p>如果构造函数<strong>只接受一个实参</strong>，则它实际上<strong>定义了转换为此类类型的隐式转换机制</strong>（从构造函数的参数类型向类类型隐式转换）。这种构造函数被称为转换构造函数（converting constructor）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">string null_book = <span class="hljs-string">&quot;9-999-99999-9&quot;</span>;<br><span class="hljs-comment">// 构造一个临时的Sales_data对象</span><br><span class="hljs-comment">// 该对象的units_sold和revenue等于0，bookNo等于null_book</span><br>item.<span class="hljs-built_in">combine</span>(null_book);<br></code></pre></td></tr></table></figure><p>类类型转换<strong>只允许一步</strong>，这意味着：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//错误，需要两次转换</span><br>item.<span class="hljs-built_in">combine</span>(<span class="hljs-string">&quot;9-999-99999-9&quot;</span>);<br><span class="hljs-comment">//正确，显式转换为string，隐式转为Sales_data</span><br>item.<span class="hljs-built_in">combine</span>(<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;9-999-99999-9&quot;</span>));<br></code></pre></td></tr></table></figure><p><strong>只有一个参数的构造函数，或者构造函数有n个参数，但有n-1个参数提供了默认值，这样的情况才能进行类型转换。</strong></p><p>如果构造函数声明为<strong>explicit</strong>，就可以抑制隐式的类类型转换。同样的，需要多个实参的构造函数不能执行隐式转换，所以无须将这些构造函数指定为explicit的。</p><p>explicit关键字只允许出现在类内的构造函数声明处，不允许在类外部定义函数时重复。</p><h4 id="c-的初始化类型"><a href="#c-的初始化类型" class="headerlink" title="c++的初始化类型"></a>c++的初始化类型</h4><table><thead><tr><th>初始化类型</th><th>举例</th></tr></thead><tbody><tr><td>默认初始化</td><td>例如<code>T t;</code></td></tr><tr><td>直接（非列表）初始化</td><td>例如<code>T t(args...);</code></td></tr><tr><td>复制（非列表）初始化</td><td>例如<code>T t = init;</code>）</td></tr><tr><td>直接列表初始化</td><td>例如<code>T t&#123; args... &#125;;</code></td></tr><tr><td>复制列表初始化</td><td>例如<code>T t = &#123; args... &#125;;</code></td></tr></tbody></table><p><a href="https://www.zhihu.com/question/403578855/answer/1306943217">为什么C++的初始化规则这么复杂？ - d41d8c的回答 - 知乎</a> </p><h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><p>使用关键字<code>static</code>可以声明类的静态成员。静态成员可以是public的或是private的，类型可以是常量、引用、指针类类型等。静态成员<strong>存在于任何对象之外</strong>，对象中<strong>不包含与静态成员相关的数据</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span> </span>&#123; amount += amount * interestRate; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">rate</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> interestRate; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rate</span><span class="hljs-params">(<span class="hljs-keyword">double</span>)</span></span>;<br>    <br><span class="hljs-keyword">private</span>:<br>    std::string owner;<br>    <span class="hljs-keyword">double</span> amount;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> interestRate;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">initRate</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>静态成员实际上是全局变量，只不过通过语法的封装，让他和所属类建立了耦合的关系。</p></blockquote><p>每个<code>static</code>数据成员<strong>是与类关联的对象</strong>，<strong>并不与该类的对象相关联</strong>。</p><p>由于静态成员不与任何对象绑定，因此静态成员函数不能声明为const，也不能在静态成员函数内使用this指针。</p><p>用户代码可以使用作用域运算符访问静态成员，也可以通过类对象、引用或指针访问。类的成员函数可以直接访问静态成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//成员函数无需作用域运算符即可使用静态成员</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span></span>&#123;amount += amount * interestRate;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">rate</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> interestRate;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rate</span><span class="hljs-params">(<span class="hljs-keyword">double</span>)</span></span>;<br><span class="hljs-keyword">private</span>:<br>  std::string owner;<br>  <span class="hljs-keyword">double</span> amount;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> interestRate;<br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">initRate</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">double</span> r;<br>r = Account::<span class="hljs-built_in">rate</span>(); <span class="hljs-comment">//用户代码可以使用作用域运算符访问静态成员</span><br><span class="hljs-comment">//可以通过类对象、引用或指针访问</span><br>Account ac1;<br>Account *ac2 = &amp;ac1;<br>r = ac1.<span class="hljs-built_in">rate</span>();<br>r = ac2-&gt;<span class="hljs-built_in">rate</span>();<br></code></pre></td></tr></table></figure><p>在类外部定义静态成员时，<strong>不能重复static关键字</strong>，其只能用于类内部的声明语句。（在类外部定义时不用加<code>static</code>）</p><p>由于静态数据成员不属于类的任何一个对象，因此它们并不是在创建类对象时被定义的。通常情况下，<strong>不应该在类内部初始化静态成员</strong>。而<strong>必须在类外部定义并初始化每个静态成员</strong>。一个静态成员<strong>只能被定义一次</strong>。一旦它被定义，就会一直存在于程序的整个生命周期中。</p><blockquote><p>想要保证对象只被定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一个文件中</p></blockquote><p>如果一定要<strong>在类内部定义</strong>，则要求<strong>必须是字面值常量类型</strong>的<code>constexpr</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>UNIX环境高级编程 阅读笔记</title>
    <link href="/2021/10/17/apue/"/>
    <url>/2021/10/17/apue/</url>
    
    <content type="html"><![CDATA[<h1 id="0-tips"><a href="#0-tips" class="headerlink" title="0.tips"></a>0.tips</h1><h2 id="输入输出问题"><a href="#输入输出问题" class="headerlink" title="输入输出问题"></a>输入输出问题</h2><ul><li><p>在linux系统下使用printf发现有时没有立即输出，有时又能立即输出</p><p>原因是printf使用行缓冲，没有刷新缓冲区，故没有输出。</p><p><strong>缓冲区刷新的条件：</strong><br>1.进程结束。<br>2.遇到\n。<br>3.缓冲区满。<br>4.手动刷新缓冲区fflush(stdout)。</p></li></ul><h2 id="一些有用的函数"><a href="#一些有用的函数" class="headerlink" title="一些有用的函数"></a>一些有用的函数</h2><h3 id="lt-stdlib-h-gt"><a href="#lt-stdlib-h-gt" class="headerlink" title="&lt;stdlib.h&gt;"></a>&lt;stdlib.h&gt;</h3><ul><li><p>atoi(str)</p><p>用法：将字符串里的数字字符转化为整形数。返回整形值。</p><p>注意：转化时跳过前面的空格字符，直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(’/0’)才结束转换，并将结果返回。</p><p>用于转化argv[]的参数</p></li></ul><h2 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h2><ul><li>C/C++规定，一个数如果要指明它采用八进制，必须在它前面加上一个0（数字0），如：123是十进制，但0123则表示采用八进制。这就是八进制数在C、C++中的表达方法。（<strong>很多宏的掩码就是八进制与</strong>）</li></ul><h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h1><h1 id="1-1what-is-os"><a href="#1-1what-is-os" class="headerlink" title="1.1what is os"></a>1.1what is os</h1><h2 id="1-1-1内核"><a href="#1-1-1内核" class="headerlink" title="1.1.1内核"></a>1.1.1内核</h2><ul><li><p>进程线程管理</p><p>进程管理主要为linux，windows只是壳子</p></li><li><p>内存管理</p></li><li><p>设备驱动</p><p>windows  .sys文件    linux .ko文件</p></li><li><p>文件系统</p></li><li><p>中断子系统</p></li></ul><h3 id="1-1-2内核-用户态"><a href="#1-1-2内核-用户态" class="headerlink" title="1.1.2内核/用户态"></a>1.1.2内核/用户态</h3><ul><li><p>ring0/ring3    环0内核态，环3用户态</p><p>ring1/ring2暂时没用到</p></li><li><p>系统调用 内核为应用程序提供的接口   用户态-&gt;内核态</p></li><li><p>体系结构</p><p><img src="https://i.loli.net/2021/10/07/I9bfymOhG5PSKnX.png" alt="image-20211007104949635"></p><p>shell    sh/bash/csh/ksh </p><p>库函数    库函数到系统调用</p></li></ul><h2 id="1-2登录"><a href="#1-2登录" class="headerlink" title="1.2登录"></a>1.2登录</h2><h3 id="1-2-1-tty-psedo-tty"><a href="#1-2-1-tty-psedo-tty" class="headerlink" title="1.2.1 tty/psedo-tty"></a>1.2.1 tty/psedo-tty</h3><p>TTY是电传打字机Teletypewriter的缩写，在带显示屏的视频终端出现之前，TTY是最流行的终端设备</p><h3 id="1-2-2-etc-password"><a href="#1-2-2-etc-password" class="headerlink" title="1.2.2 /etc/password"></a>1.2.2 /etc/password</h3><ul><li>密码可以在etc/password看到</li><li>shadow文件</li><li>起始目录</li><li>用户id</li><li>组id</li><li>shell</li></ul><h2 id="1-3-文件"><a href="#1-3-文件" class="headerlink" title="1.3 文件"></a>1.3 文件</h2><h3 id="1-3-1-一切皆为文件"><a href="#1-3-1-一切皆为文件" class="headerlink" title="1.3.1 一切皆为文件"></a>1.3.1 一切皆为文件</h3><ul><li>目录</li><li>文本文件/二进制文件一视同仁</li><li>设备文件：字符设备、块设备、网络设备（在/dev下ll看第一位）</li><li>socket   linux与windows不同</li><li>管道、消息队列等</li></ul><h3 id="1-3-2-相对路径-绝对路径"><a href="#1-3-2-相对路径-绝对路径" class="headerlink" title="1.3.2 相对路径/绝对路径"></a>1.3.2 相对路径/绝对路径</h3><p> /    ..     .</p><h2 id="1-4-I-O"><a href="#1-4-I-O" class="headerlink" title="1.4 I/O"></a>1.4 I/O</h2><ul><li>文件描述符fd</li><li>stdin/stdout/stderr  对应0/1/2</li></ul><h2 id="1-5-进程"><a href="#1-5-进程" class="headerlink" title="1.5 进程"></a>1.5 进程</h2><ul><li><p>进程与程序的关系</p></li><li><p>进程id</p><p>windows下为4的倍数（复用原因）</p><p>linux下用ps命令查看</p></li><li><p>进程控制</p><p>fork 子进程都是由父进程fork出来的（写时复制）</p><p>exec  fork之后调用，类似windows的winexecute api</p><p>waitpid</p></li></ul><h2 id="1-6-出错处理"><a href="#1-6-出错处理" class="headerlink" title="1.6 出错处理"></a>1.6 出错处理</h2><ul><li><p>errno</p><p>windows下有geterrornumber</p></li><li><p>strerror</p></li></ul><h2 id="1-7信号"><a href="#1-7信号" class="headerlink" title="1.7信号"></a>1.7信号</h2><p>可以理解为用户层的中断，异步打断执行流</p><ul><li><p>信号的处理</p><p>系统默认处理： 忽略/中止进程</p><p>为指定信号注册处理函数</p></li></ul><p>是Linux编程重点，也容易踩坑</p><h2 id="1-8-时间"><a href="#1-8-时间" class="headerlink" title="1.8 时间"></a>1.8 时间</h2><h3 id="日历时间"><a href="#日历时间" class="headerlink" title="日历时间"></a>日历时间</h3><p>UTC</p><p>time-t</p><h3 id="进程时间"><a href="#进程时间" class="headerlink" title="进程时间"></a>进程时间</h3><p>clock_t</p><p>用户CPU时间</p><p>系统CPU时间</p><h1 id="2-UNIX标准"><a href="#2-UNIX标准" class="headerlink" title="2.UNIX标准"></a>2.UNIX标准</h1><h2 id="2-1-标准"><a href="#2-1-标准" class="headerlink" title="2.1 标准"></a>2.1 标准</h2><h3 id="ISO-C组成"><a href="#ISO-C组成" class="headerlink" title="ISO C组成"></a>ISO C组成</h3><ul><li>语法、语义</li><li>标准库</li></ul><h3 id="ISO-C历史"><a href="#ISO-C历史" class="headerlink" title="ISO C历史"></a>ISO C历史</h3><ul><li>ANSI C89</li><li>C99<ul><li>restrict</li><li>long long</li><li>单行注释</li><li>分散代码与声明</li></ul></li><li>C11</li></ul><h3 id="POSIX标准"><a href="#POSIX标准" class="headerlink" title="POSIX标准"></a>POSIX标准</h3><ul><li>提升各种应用程序在各种UNIX系统环境间的可移植性</li><li>只定义接口而非实现</li></ul><h3 id="SUS-single-UNIX-specification"><a href="#SUS-single-UNIX-specification" class="headerlink" title="SUS(single UNIX specification)"></a>SUS(single UNIX specification)</h3><ul><li>POSIX的超集</li><li>扩展了功能</li></ul><h2 id="2-2-实现"><a href="#2-2-实现" class="headerlink" title="2.2 实现"></a>2.2 实现</h2><ul><li>FreeBSD</li><li>Linux</li><li>Mac OS X</li><li>Solaris</li></ul><h2 id="2-3限制"><a href="#2-3限制" class="headerlink" title="2.3限制"></a>2.3限制</h2><h3 id="编译时限制"><a href="#编译时限制" class="headerlink" title="编译时限制"></a>编译时限制</h3><ul><li><p>ISO C</p><p>limits.h    各种最大最小值(宏内定义了，include直接用)</p><p>float.h    浮点数相关</p><p>stdio.h</p></li><li><p>POSIX 限制</p></li></ul><h3 id="运行时限制"><a href="#运行时限制" class="headerlink" title="运行时限制"></a>运行时限制</h3><p>只有运行时才能拿到，例如系统调用给出</p><ul><li>sysconf</li><li>pathconf/fpathconf</li></ul><h1 id="3-无缓冲I-O（文件IO）"><a href="#3-无缓冲I-O（文件IO）" class="headerlink" title="3. 无缓冲I/O（文件IO）"></a>3. 无缓冲I/O（文件IO）</h1><h2 id="3-1-文件描述符fd"><a href="#3-1-文件描述符fd" class="headerlink" title="3.1 文件描述符fd"></a>3.1 文件描述符fd</h2><ul><li><p>所有打开文件都由fd引用，fd为非负int（出错时为负）</p></li><li><p>类似windows的HANDLE</p></li><li><p>STDIN_FILENO  STDOUT_FILENO  STDERR_FILENO</p></li><li><p>OPEN_MAX（文件打开的极限值）</p></li><li><p><img src="https://i.loli.net/2021/10/08/Uto3clnhVJEy12D.png" alt="image-20211008102820346"></p></li><li><p><img src="https://i.loli.net/2021/10/08/gsyILjapZ29F7t6.png" alt="image-20211008103035519"></p><ul><li><strong>进程各自维护自己的文件描述符表，文件描述符表记录文件描述符标志，和一个指向文件表项的指针</strong></li><li><strong>文件表项由内核为每一个打开的文件维护，包括文件状态标志、当前文件偏移、以及指向v结点的指针</strong><ul><li><strong>==不同进程打开同一个文件、同一进程调用多次open同一个文件==并不共享file table entry（文件表项）</strong> 因为各自的偏移可能不同，也可以理解为调用一次open打开一个文件表项，而复制fd与之无关<ul><li>但是fork出来的子进程的fd指向同一个文件表项（因为文件描述符表也copy，p397）</li></ul></li></ul></li></ul></li><li><p>/dev/fd</p><p>/prof/self/fd</p></li></ul><h2 id="3-2-API"><a href="#3-2-API" class="headerlink" title="3.2 API"></a>3.2 API</h2><h3 id="open-openat-create"><a href="#open-openat-create" class="headerlink" title="open/openat/create"></a>open/openat/create</h3><ul><li><p>oflag    <strong>文件状态标志</strong></p><ul><li><p>O_RDONLY    O_WRONLY    O_RDWR</p><p>必须指定且互斥</p></li><li><p>O_APPEND    O_CLOEXEC    O_CREAT    O_DIRECTORY    O_EXCL    O_SYNC    O_DSYNC    O_TRUNC</p></li><li><p>O_CREAT | O_EXCL 配合测试创建文件的原子性</p></li></ul></li><li><p>openat的path可以为相对路径</p></li><li><p>creat只写创建，想要创建写之后再读必须close之后再open，用open实现：</p><p>open(path, O_RDWR | O_CREAT | O_TRUNC, mode)</p></li></ul><h3 id="close"><a href="#close" class="headerlink" title="close"></a>close</h3><ul><li><p>会关闭记录锁</p></li><li><p>进程终止，内核会自动关闭文件对象</p><p>RAII的思想</p></li></ul><h3 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h3><ul><li>当前文件偏移量</li><li>文件空洞</li></ul><h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><ul><li>返回值 &lt; 待读字节数的情景<ul><li>eof</li><li>终端设备/行缓冲</li><li>管道/FIFO</li><li>中断</li></ul></li></ul><h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><ul><li>返回值 &lt; 待写字节数的情景<ul><li>磁盘满</li><li>超过了给定进程的文件长度限制</li></ul></li></ul><h3 id="pread-pwrite"><a href="#pread-pwrite" class="headerlink" title="pread/pwrite"></a>pread/pwrite</h3><p>原子lseek + read/write</p><h3 id="dup-dup2"><a href="#dup-dup2" class="headerlink" title="dup/dup2"></a>dup/dup2</h3><ul><li><img src="https://i.loli.net/2021/10/08/I9dk2Rxzu4bLwXe.png" alt="image-20211008212224736"></li><li>新描述符的FD_CLOEXEC总是被清除 （即fd flag）</li><li>dup(fd) = fcntl(fd, F_DUPFD, 0);</li><li>dup2(fd) = close(fd2); fcntl(fd, F_DUPFD, fd2); //且为<strong>原子操作</strong></li><li>dup 和 fcntl 的 errno 不同</li></ul><h3 id="sync-fsync-fdatasync"><a href="#sync-fsync-fdatasync" class="headerlink" title="sync/fsync/fdatasync"></a>sync/fsync/fdatasync</h3><ul><li>内核维护高速缓存</li><li>延迟写</li><li>update守护进程周期性调用sync</li></ul><h3 id="fcntl（重点）"><a href="#fcntl（重点）" class="headerlink" title="fcntl（重点）"></a>fcntl（重点）</h3><p>#include&lt;fcntl.h&gt;</p><p><strong>int fcntl(int fd, int cmd, … );</strong>  </p><ul><li><p>复制一个已有的描述符</p><ul><li>F_DUPFD/F_DUPFD_CLOEXEC</li></ul></li><li><p>获取/设置文件描述符标志**(fd flag)**</p><ul><li><p>F_GETFD/F_SETFD</p></li><li><p>仅有的就是FD_CLOEXEC标志</p><p>fcntl(fd, F_SETFD, 1);    默认为0，即不关闭</p></li></ul></li><li><p>获取/设置文件状态标志</p><ul><li><p>F_GETFL/F_SETFL</p><p>==注意GETFL与GETFD的区别==</p></li></ul></li><li><p>获取/设置异步I/O所有权</p><ul><li>F_GETOWN/F_SETOWN</li></ul></li><li><p>获取/设置记录锁</p><ul><li>F_GETLK/F_SETLK/F_SETLKW</li></ul></li></ul><h3 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h3><ul><li><p>设备驱动</p><p>某个特定操作的接口</p></li><li><p>类比于windows的 DeviceControl</p><p>应用程序到设备驱动的万用接口</p></li></ul><h1 id="4-文件和目录"><a href="#4-文件和目录" class="headerlink" title="4. 文件和目录"></a>4. 文件和目录</h1><h2 id="4-1-struct-stat"><a href="#4-1-struct-stat" class="headerlink" title="4.1 struct stat"></a>4.1 struct stat</h2><p>POSIX标准 + XSI扩展定义的字段</p><p>描述一个特定文件相关的信息</p><h3 id="linux下的struct-stat"><a href="#linux下的struct-stat" class="headerlink" title="linux下的struct stat"></a>linux下的struct stat</h3><ul><li><p>st_mode</p><ul><li><p>文件类型</p><table><thead><tr><th>文件类型</th><th>宏</th></tr></thead><tbody><tr><td>普通文件 regular file</td><td>S_ISREG()</td></tr><tr><td>目录文件 directory file</td><td>S_ISDIR()</td></tr><tr><td>符号链接 symbolic link</td><td>S_ISLINK()</td></tr><tr><td>块特殊文件 block special file</td><td>S_ISCHR()</td></tr><tr><td>字符特殊文件 character special file</td><td>S_ISBLK()</td></tr><tr><td>FIFO 命名管道</td><td>S_ISFIFO()</td></tr><tr><td>socket</td><td>S_ISSOCK()</td></tr><tr><td>消息队列</td><td>S_TYPEISMQ()</td></tr><tr><td>信号量</td><td>S_TYPEISEM()</td></tr><tr><td>共享内存</td><td>S_TYPEISSHM()</td></tr></tbody></table></li><li><p>mode</p><p>set-user-id bit            S_ISUID</p><p>set-group-id bit         S_ISGID</p><p>进程关联ID：</p><ol><li>实际用户/组ID</li><li>有效用户/组ID  附属组ID</li></ol></li><li><p>文件和目录的权限位</p><ul><li><code>S_ISUID</code>：执行时设置用户ID</li><li><code>S_ISGID</code>：执行时设置组ID</li><li><code>S_ISVTX</code>：粘着位</li><li><code>S_IRWXU</code>：用户读、写和执行</li><li><code>S_IRUSR</code>：用户读</li><li><code>S_IWUSR</code>：用户写</li><li><code>S_IXUSR</code>：用户执行</li><li><code>S_IRWXG</code>：组读、写和执行</li><li><code>S_IRGRP</code>：用户读</li><li><code>S_IWGRP</code>：用户写</li><li><code>S_IXGRP</code>：用户执行</li><li><code>S_IRWXO</code>：其他读、写和执行</li><li><code>S_IROTH</code>：用户读</li><li><code>S_IWOTH</code>：用户写</li><li><code>S_IXOTH</code>：用户执行</li></ul><p><img src="https://i.loli.net/2021/10/10/2q7eFnO8j6xHNyY.png" alt="image-20211010161123024"></p></li><li><p>鉴权流程</p></li></ul></li></ul><h2 id="4-2-文件系统"><a href="#4-2-文件系统" class="headerlink" title="4.2 文件系统"></a>4.2 文件系统</h2><h3 id="VFS"><a href="#VFS" class="headerlink" title="VFS"></a>VFS</h3><ul><li>superblock</li><li>incode<ul><li>与文件一一对应，相当于身份证号</li><li>包含文件的元数据，<strong>不包含名称</strong></li><li>内存中的inode和磁盘中的inode</li><li>名称-&gt;inode-&gt;disk block</li></ul></li><li>dentry<ul><li>文件的逻辑属性</li><li>一个dentry对应一个inode</li><li>多个dentry可能对应一个inode(硬链接/软链接)</li></ul></li><li>file object</li></ul><h2 id="4-3-API"><a href="#4-3-API" class="headerlink" title="4.3 API"></a>4.3 API</h2><h3 id="状态相关"><a href="#状态相关" class="headerlink" title="状态相关"></a>状态相关</h3><ul><li><p>stat / fstat / statat / lstat</p></li><li><p>ls - l命令</p><p>注意是否跟踪符号链接</p></li></ul><h3 id="权限相关"><a href="#权限相关" class="headerlink" title="权限相关"></a>权限相关</h3><ul><li><p>access / faccessat</p><p>探测文件是否存在</p><p><strong>以实际用户</strong>ID和实际组ID测试访问能力</p><p>faccessat提供了 AT_EACCESS  和 AT_SYMLINK_NOFOLLOW</p></li><li><p>umask</p><p>创建新目录或文件时，屏蔽字中置1的权限都会被关闭</p><p>区分umask命令</p></li><li><p>chmod / fchmod / fchmodat</p><ul><li>S_ISUID / S_ISGID</li><li>S_IRWXU / S_IRWXG / S_IRWXO</li><li>S_ISVTX(粘着位在linux无效)</li></ul></li><li><p>chown / fchown / fchownat / lchown</p><p>chown命令</p><p>注意符号链接的处理</p></li></ul><h3 id="变更相关"><a href="#变更相关" class="headerlink" title="变更相关"></a>变更相关</h3><ul><li><p>truncate / ftruncate</p><p>截断/扩充</p></li><li><p>link / linkat</p></li><li><p>unlink / unlinkat</p><p>用于确保临时文件被删除</p><p>标准库的remove</p></li><li><p>rename / renameat</p><ul><li>oldname 非目录<ul><li>newname存在</li><li>newname不存在</li></ul></li><li>oldname 为目录<ul><li>newname 存在</li><li>newname 不存在</li></ul></li><li>符号链接</li><li>. 和 .. 不允许</li></ul></li><li><p>symlink / symlinkat</p></li><li><p>readlink / readlinkat</p><p>open的局限：不能打开link本身</p></li><li><p>mkdir / mkdirat</p></li><li><p>rmdir</p></li></ul><h3 id="控制相关"><a href="#控制相关" class="headerlink" title="控制相关"></a>控制相关</h3><ul><li><p>opendir /  fopendir </p><p>readdir / rewinddir / closedir / telldir / seekdir </p><p>类比文件/标准I/O的接口</p></li><li><p>chdir / fchdir</p></li><li><p>getcwd</p></li></ul><h3 id="时间相关"><a href="#时间相关" class="headerlink" title="时间相关"></a>时间相关</h3><ul><li>futimens</li><li>utimensat</li><li>utimes</li></ul><h1 id="5-标准I-O"><a href="#5-标准I-O" class="headerlink" title="5.标准I/O"></a>5.标准I/O</h1><p><strong>即ISO C标准I/O</strong></p><h2 id="5-1-流-stream"><a href="#5-1-流-stream" class="headerlink" title="5.1 流 (stream)"></a>5.1 流 (stream)</h2><ul><li><p>无缓冲I/O围绕fd展开</p></li><li><p>有缓冲I/O围绕stream展开</p></li><li><p>流的定向(stream’s orientation)</p><ul><li><p>单字节 字节定向</p><p>byte flow                 ASCII</p></li><li><p>多字节 宽定向</p><p>wide bytes flow      国际字符集  </p></li></ul></li><li><p>进程预定义流</p><p>stdin / stdout /stderr</p></li><li><p>流缓冲</p><ul><li><p>意义</p></li><li><p>类型</p><p>全缓冲：填满I/O缓冲区后才进行实际I/O操作</p><p>行缓冲：</p><ol><li><p>输入输出遇到换行符时执行I/O操作</p><pre><code>            2. 由于每行缓冲区固定，缓冲区满没有遇到换行符也要执行I/O            3.  任何时候只要通过标准lO库，要求从一个不带缓冲的流或者一个行缓冲的流(从内核请求数据的时机）得到输入数据，那么就会冲洗所有行缓冲输出流。(即要缓冲输入，先冲洗输出缓冲)            4. 指向终端的流通常使用行缓冲</code></pre></li></ol><p>不带缓冲：不进行缓冲</p></li></ul></li><li><p>stdin 和 stdout 并不指向交互设备时，才能使全缓冲类型 (通过重定向)</p><p>如果指向终端设备，则是行缓冲的，否则是全缓冲的</p></li><li><p><strong>stderr绝不能时全缓冲的，一般是不带缓冲</strong></p><p>表现为buffersize = 1</p></li></ul><h2 id="5-2-FILE对象"><a href="#5-2-FILE对象" class="headerlink" title="5.2 FILE对象"></a>5.2 FILE对象</h2><ul><li>不同平台的实现不同</li><li>linux<ul><li>fd    用于实际I/O</li><li>buffer指针  buffer尺寸  buffer当前字符数</li><li>出错标志  文件结束标志</li></ul></li></ul><h2 id="5-3-API"><a href="#5-3-API" class="headerlink" title="5.3 API"></a>5.3 API</h2><ul><li><p>fwide</p></li><li><p>setbuf / setvbuf    p118</p></li><li><p>fflush</p></li><li><p>fopen / freopen / fdopen</p></li><li><p>fclose</p></li><li><p>读写</p><ul><li>getc / fgetc /  getchar / ungetc</li><li>putc / fputc / putchar</li><li>fgets / (gets)</li><li>fputs / (puts)</li><li>fread / fwrite</li></ul></li><li><p>ferror / feof / clearerr</p></li><li><p>ftell / ftello / fseek / fseeko / rewind</p></li><li><p>fgetpos / fsetpos</p></li><li><p>格式化输入输出</p><ul><li>printf / fprintf / dprintf / sprintf / snprintf</li><li>scanf / fscanf / sscanf</li></ul></li><li><p>fileno</p><p>标准I/O到无缓冲I/O的adapter</p></li><li><p>tmpnam / tmpfile  临时文件</p></li><li><p>fmemopen  内存流</p></li></ul><h1 id="6-系统信息"><a href="#6-系统信息" class="headerlink" title="6. 系统信息"></a>6. 系统信息</h1><h2 id="6-1-数据文件"><a href="#6-1-数据文件" class="headerlink" title="6.1 数据文件"></a>6.1 数据文件</h2><ul><li><p>/etc/passwd</p><ul><li><p>pwd.h中定义了struct passwd结构</p><p>可以任意由用户读取</p></li><li><p>是ASCII文件，可以用标准I/O读取，但是效率太低</p><p>因此系统提供API接口</p></li></ul></li><li><p>/etc/group</p><ul><li>grp.h中定义了struct group结构</li></ul></li><li><p>/etc/shadow</p><ul><li><p>经单向加密算法处理过的用户口令副本</p></li><li><p>shadow.h中定义了struct spwd</p></li><li><p>阴影口令文件 /etc/shadow 不应该由一般用户读取</p><p>仅有少数几个程序需要访问加密口令,如login, passwd, 这些程序通常是设定 set-user-ID为root的程序</p></li></ul></li></ul><h2 id="6-2-API"><a href="#6-2-API" class="headerlink" title="6.2 API"></a>6.2 API</h2><h3 id="6-2-1-数据文件"><a href="#6-2-1-数据文件" class="headerlink" title="6.2.1 数据文件"></a>6.2.1 数据文件</h3><ul><li>getpwuid / getpwnam</li><li>getpwent / setpwent / endpwent</li><li>getspnam / getspent / setspent / endspent</li><li>getgrgid / getgenam</li><li>getgrent / setgrent / endgrent</li><li>getgroups / setgroups / initgroups</li></ul><p><strong>返回的结构都是一个静态变量，会覆盖前一次的结果，数据文件的API都提供了 get / set / end 组合技</strong></p><h3 id="6-2-2-系统信息"><a href="#6-2-2-系统信息" class="headerlink" title="6.2.2 系统信息"></a>6.2.2 系统信息</h3><ul><li><p>uname</p><p>struct utsname</p></li><li><p>gethostname</p></li><li><p>time</p><p>日历时间</p></li><li><p>clock_gettime</p><p>获取指定的时钟类型的时间</p><ol><li>实时系统时间</li><li>不带负跳数的实时系统时间</li><li>调用进程的CPU时间</li><li>调用线程的CPU时间</li></ol></li><li><p>clock_getres</p><p>时间精度调整</p></li><li><p>clock_settime</p><p>对特定的时钟设置时间（某些需要权限）</p></li><li><p>gettimeofday (deprecate)</p></li><li><p>gmtime / localtime</p><p>日历时间转换为struct tm 结构</p></li><li><p>mktime</p></li><li><p>strftime / strftime_l</p><p>格式化时间，打印字符串</p></li><li><p>strptime</p></li></ul><h1 id="7-进程环境"><a href="#7-进程环境" class="headerlink" title="7. 进程环境"></a>7. 进程环境</h1><h2 id="7-1概念"><a href="#7-1概念" class="headerlink" title="7.1概念"></a>7.1概念</h2><h3 id="1进程终止"><a href="#1进程终止" class="headerlink" title="1进程终止"></a>1进程终止</h3><ul><li><p>从main返回</p><p>exit(main(argc, argv))</p><p>return 和 exit(0) 并无区别</p></li><li><p>exit()库函数</p></li><li><p>_exit / _Exit 系统调用</p></li><li><p>这两者区别： 不同标准定义 、是否做了清理工作</p></li><li><p><img src="https://i.loli.net/2021/10/12/6ILPQsK8ROXj5CF.png" alt="image-20211012235649755"></p></li></ul><h3 id="2-终止处理程序"><a href="#2-终止处理程序" class="headerlink" title="2 终止处理程序"></a>2 终止处理程序</h3><ul><li><p>atexit函数</p><p>事先声明，反向调用，类似栈</p></li></ul><h3 id="3-命令行参数"><a href="#3-命令行参数" class="headerlink" title="3 命令行参数"></a>3 命令行参数</h3><ul><li><p>argc  argv</p></li><li><p>envp   环境表</p><p>全局变量   environ</p><p><img src="https://i.loli.net/2021/10/12/qnl1Hc9s4xKOfUY.png" alt="image-20211012235941033"></p><ul><li>函数 getenv / putenv</li><li>一般调用函数获取环境，而非读取environ</li></ul></li><li><p>进程地址空间</p><p><img src="https://i.loli.net/2021/10/13/9X1HA2xE8dQ7TrI.png" alt="image-20211013000146968"></p><p>.text / .data / .bss / stack / heap / others (so , debug , systab )</p></li></ul><h3 id="4-跨越函数跳转"><a href="#4-跨越函数跳转" class="headerlink" title="4 跨越函数跳转"></a>4 跨越函数跳转</h3><ul><li>setjmp / longjmp</li><li>靠返回值val与正常函数调用区分</li></ul><h3 id="5-进程资源限制"><a href="#5-进程资源限制" class="headerlink" title="5 进程资源限制"></a>5 进程资源限制</h3><ul><li>getrlimit / setrlimit</li></ul><h2 id="7-2-API"><a href="#7-2-API" class="headerlink" title="7.2 API"></a>7.2 API</h2><ul><li>exit / _Exit / _exit</li><li>atexit</li><li>getenv / putenv / setenv / unsetenv / clearenv</li><li>setjmp / longjmp</li></ul><h1 id="8-进程控制"><a href="#8-进程控制" class="headerlink" title="8. 进程控制"></a>8. 进程控制</h1><h2 id="8-1-概念"><a href="#8-1-概念" class="headerlink" title="8.1 概念"></a>8.1 概念</h2><h3 id="进程ID"><a href="#进程ID" class="headerlink" title="进程ID"></a>进程ID</h3><ul><li><p>循环复用</p></li><li><p>特殊的进程ID</p><ul><li><p>swapper：0    内核交换进程</p></li><li><p>init：1</p><p>普通用户进程</p><p>超级用户特权</p><p>所有孤儿进程的父进程</p></li></ul></li></ul><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><h4 id="一次调用两次返回"><a href="#一次调用两次返回" class="headerlink" title="一次调用两次返回"></a>一次调用两次返回</h4><ul><li><p>父进程中返回创建的子进程ID</p></li><li><p>子进程返回0</p><p>getppid ( get parent id) 获取父进程ID</p></li><li><p>父子进程谁先执行不确定</p></li></ul><h4 id="子进程是父进程的副本"><a href="#子进程是父进程的副本" class="headerlink" title="子进程是父进程的副本"></a>子进程是父进程的副本</h4><ul><li><p>拷贝数据空间、堆、栈</p><p>COW （copy on write）写时复制</p><p>试图修改时才真正拷贝</p><p>fork + exec 从中受益</p></li><li><p>代码段共享 （只读）</p></li><li><p>拷贝文件描述符表</p><p><img src="https://i.loli.net/2021/10/13/NQ7HU8TExiwOo3J.png" alt="image-20211013001243684"></p></li><li><p>继承父进程相关属性</p><p>实际用户ID、实际组ID、有效用户ID、有效组ID 附属组ID 进程组ID 会话ID 控制终端 设置用户ID标识和设置组ID标识 当前工作目录 根目录 文件模式创建屏蔽字 信号屏蔽和安排 对任一打开文件描述符的执行时关闭(close-on-exec)标识 环境变量 连接的共享存储段 存储映像 资源限制</p></li><li><p>父子进程的不同之处</p><ul><li>ID / PID</li><li>子进程tms_utime/tms_stime/tms_cutime/tms_ustime被清零</li><li><strong>子进程不继承父进程文件锁</strong></li><li>子进程未处理闹钟将被清除</li><li>子进程未处理信号集设置为空集</li></ul></li></ul><h3 id="父子进程的生死交互"><a href="#父子进程的生死交互" class="headerlink" title="父子进程的生死交互"></a>父子进程的生死交互</h3><h4 id="子进程先于父进程终止"><a href="#子进程先于父进程终止" class="headerlink" title="子进程先于父进程终止"></a>子进程先于父进程终止</h4><ul><li><p>通过信号SIGCHILD发送退出状态给父进程</p></li><li><p>父进程可以通过wait / waitpid获取信息</p><p>子进程ID / 子进程终止状态 / CPU耗时</p></li><li><p>未善后的终止子进程为僵死进程（zombie）</p></li></ul><h4 id="父进程先于子进程终止"><a href="#父进程先于子进程终止" class="headerlink" title="父进程先于子进程终止"></a>父进程先于子进程终止</h4><ul><li><p>子进程父亲改为init 进程（pid 1）</p></li><li><p>init进程会调用wait善后处理终止的子进程（防止全是zombie）</p></li><li><p>wait / waitpid</p><ul><li><p>如果所有子进程都还在运行，则阻塞</p></li><li><p>如果一个子进程终止，正等待父进程获取其终止状态，则取得终止状态立即返回（zombie状态也立即返回）</p></li><li><p>如果没有任何子进程则出错返回</p></li><li><p>waitpid功能补充</p><p>支持异步（需要设置options参数）</p><p>可选择性等待某个进程</p><p>​    pid == -1 / 0 / &gt;0 / &lt;-1</p></li></ul></li><li><p>更灵活的wait系列函数</p></li></ul><h3 id="exec族函数"><a href="#exec族函数" class="headerlink" title="exec族函数"></a>exec族函数</h3><ul><li><p>更进一步的封装</p><ul><li><p>popen</p></li><li><p>system</p><p>fork -&gt; exec -&gt; waitpid</p></li></ul></li></ul><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><ul><li>实际用户 / 组ID</li><li>有效用户 / 组ID</li><li>setuid / setgid<ul><li>进程拥有超级权限，二话不说直接改实际用户/组ID、有效用户/组ID为指定ID </li><li>如果没有超级权限，但是uid或gid设置为实际用户/组ID或保存的设置用户/组ID， 则只将有效用户/组ID改为指定ID </li><li>不满足前两条，通通返回错误(ret = -1, error = EPERM)</li></ul></li></ul><h3 id="解释器文件"><a href="#解释器文件" class="headerlink" title="解释器文件"></a>解释器文件</h3><ul><li>解释型语言源文件起始行标注</li></ul><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><ul><li><p>优先级</p></li><li><p>nice</p><p>0~2*NZERO-1 sysconf获取</p><p>越大越低</p></li><li><p>getpriority setpriority</p></li></ul><h3 id="进程时间-1"><a href="#进程时间-1" class="headerlink" title="进程时间"></a>进程时间</h3><ul><li>时钟时间 </li><li>用户CPU时间 </li><li>系统CPU时间 </li><li>times</li></ul><h1 id="8-2-API"><a href="#8-2-API" class="headerlink" title="8.2 API"></a>8.2 API</h1><ul><li>getpid getppid getuid geteuid getgid getegid</li><li>fork vfork</li><li>wait waitpid</li><li>waitid</li><li>wait3/wait4</li><li>execl execv execle execve execlp execvp fexecve</li><li>setuid/setgid</li><li>seteuid/setegid</li><li>system</li><li>nice</li><li>getpriority/setpriority</li><li>times</li></ul><h1 id="9-进程关系"><a href="#9-进程关系" class="headerlink" title="9. 进程关系"></a>9. 进程关系</h1><h2 id="9-1-概念"><a href="#9-1-概念" class="headerlink" title="9.1 概念"></a>9.1 概念</h2><h3 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h3><p><img src="https://i.loli.net/2021/10/15/pDU7nBhWYsqKtjm.png" alt="image-20211015155106020"></p><ul><li><p>tty1-6</p><p>CTRL ALT F1-6</p></li><li><p>图形终端</p><p>ALT F7</p></li><li><p>pseudo tty（pty） 网络终端</p></li></ul><h3 id="进程组（作业job）"><a href="#进程组（作业job）" class="headerlink" title="进程组（作业job）"></a>进程组（作业job）</h3><ul><li><p>唯一标志ID</p><ul><li><p>getpgrp / getpgid</p></li><li><p>setpgid</p><p><strong>进程只能为自己和它的子进程设置进程组ID</strong></p></li><li><p>唯一标志ID和组长的PID一致</p></li></ul></li><li><p>多个进程的集合，每个进程都有所属的进程组</p></li><li><p>同一进程组的所有进程接受同一终端的各种信号</p></li><li><p><strong>孤儿进程组</strong></p><p>每个成员的父亲要么在本组，要么在其他会话中</p></li></ul><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><ul><li><p>可以有0或一个控制终端（tty / pseudo tty)</p><p>建立与控制终端连接的会话首进程被称为控制进程</p><p>无控制终端可能为守护进程</p></li><li><p>一个到多个进程组的集合</p><ul><li><p>一个前台进程</p><p>这意味着会话有一个控制终端</p><p>接受 ctrl c / ctrl \ 产生的 SIGINT /  SIGQUIT 信号</p></li><li><p>n个后台进程组</p></li><li><p><img src="https://i.loli.net/2021/10/15/qJIVv3AE1sRPOQm.png" alt="image-20211015154131834"></p></li></ul></li><li><p>新建会话 setsid</p><ul><li><p>该进程变成新会话的会话首进程 (session leader)</p><p>此时该 leader 是会话中的唯一进程</p><p>这意味这<strong>要新建会话 要先 fork 再 setsid</strong>     这就保证了进程不是进程组的组长</p></li><li><p>该进程成为一个新进程组的组长进程</p><p>新进程组ID是调用进程的进程ID</p><p>也是会话ID</p></li><li><p>该进程没有控制终端</p><p>如果调用 setsid 前有控制终端，则切断联系</p></li></ul></li></ul><h3 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h3><p><img src="https://i.loli.net/2021/10/15/lSc1txX8ZjoD2sv.png" alt="image-20211015155022811"></p><h2 id="9-2-API"><a href="#9-2-API" class="headerlink" title="9.2 API"></a>9.2 API</h2><ul><li>getpgrp / getpgid / sepgid</li><li>setsid / getsid</li><li>tcgetpgrp / tcsetpgrp / tcgetsid</li></ul><h1 id="10-信号"><a href="#10-信号" class="headerlink" title="10. 信号"></a>10. 信号</h1><h2 id="10-1-概念"><a href="#10-1-概念" class="headerlink" title="10.1 概念"></a>10.1 概念</h2><h3 id="异步事件"><a href="#异步事件" class="headerlink" title="异步事件"></a>异步事件</h3><ul><li>信号的产生是不定时的，随机的</li><li>可以简单理解为用户态的中断（软中断）</li></ul><h3 id="产生信号的方式"><a href="#产生信号的方式" class="headerlink" title="产生信号的方式"></a>产生信号的方式</h3><ul><li>用户按键产生（ctrl C）</li><li>硬件异常产生</li><li>进程或者用户调用kill</li><li>但检测到某种软性条件已经发生，通知有关进程<ul><li>SIGURG / SIGPIPE / SIGALARM / SIGABRT</li></ul></li></ul><h3 id="进程处理信号的方式"><a href="#进程处理信号的方式" class="headerlink" title="进程处理信号的方式"></a>进程处理信号的方式</h3><ul><li><p>忽略 ignore</p><ul><li>大多数信号的默认处理方式</li><li>SIGKILL / SIGSTOP 不能被忽略</li><li>由硬件异常导致的信号最好不要被忽略</li><li>中断允许嵌套，但是一般终端过程中同一个中断会忽略</li></ul></li><li><p>捕捉 catch</p><ul><li>注册一个signal handler</li><li>信号到来时会打断当前执行流，转而去执行handler</li><li>不能捕捉SIGKILL / SIGSTOP</li></ul></li><li><p>执行默认动作</p><p><img src="https://i.loli.net/2021/10/13/oRPtp3KE8DM6zXm.png" alt="image-20211013234629726"></p></li><li><p>函数 signal / sigaction</p></li><li><p>子进程继承了父进程处理信号的方式</p></li></ul><h3 id="被中断的系统调用"><a href="#被中断的系统调用" class="headerlink" title="被中断的系统调用"></a>被中断的系统调用</h3><ul><li><p>低速系统调用</p><p>可能会使进程永久阻塞的一类</p></li><li><p>出错返回</p><p>errno EINTR</p></li><li><p>自动重新启动的系统调用</p><p>ioctl read/readv write/writev wait/waitpid</p></li></ul><h3 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h3><ul><li><p>异步信号安全</p><p><img src="https://i.loli.net/2021/10/13/mTB6qjaRNg81KUw.png" alt="image-20211013235025005"></p></li><li><p>不可重入的情况</p><p>static静态变量</p><p>global全局变量</p><p>调用了不可重入函数</p></li><li><p>malloc是线程安全的（递归锁），但是维护共享内存，故是不可重入的</p></li></ul><h3 id="可靠信号"><a href="#可靠信号" class="headerlink" title="可靠信号"></a>可靠信号</h3><ul><li><p>未决的 pending<br>产生信号和送达之间</p></li><li><p>信号屏蔽字 signal mask （signal procmask）</p><ul><li>进程可以阻塞某种信号递送sigpending<ul><li>保持未决状态</li><li>直到进程接触阻塞或设置为忽略才送达</li><li>阻塞期间同一个信号触发多次（是否排队：sigqueue）</li></ul></li><li>sigsuspend 解除了 使用 sigprocmask 和 pause 组合 的原子性问题</li></ul></li><li><p>信号集 sigset_t</p><p>相关api ： sigemptyset / sigfillset / sigaddset / sigdelset / sigismember</p><p>与 sigprocmask 相配合</p></li></ul><h3 id="递送信号"><a href="#递送信号" class="headerlink" title="递送信号"></a>递送信号</h3><ul><li><p>kill  / raise 库函数</p></li><li><p>kill命令</p></li><li><p>定时器</p><p>alarm：SIGALARM  默认动作为终止进程</p><p>一个进程只能有一个定时器</p></li></ul><h3 id="睡眠"><a href="#睡眠" class="headerlink" title="睡眠"></a>睡眠</h3><ul><li>sleep / nanosleep / clock_nanosleep</li></ul><h3 id="进程控制的延申"><a href="#进程控制的延申" class="headerlink" title="进程控制的延申"></a>进程控制的延申</h3><ul><li>信号做父子进程的同步</li><li>加入信号处理的system实现</li></ul><h3 id="非局部跳出（deprecated）"><a href="#非局部跳出（deprecated）" class="headerlink" title="非局部跳出（deprecated）"></a>非局部跳出（deprecated）</h3><ul><li><p>sigsetjmp / siglongjmp</p></li><li><p>对比 setjmp / longjmp</p><p>handler自动屏蔽某种信号</p><p>跳走后无法保存信号屏蔽字</p></li></ul><h1 id="10-2-API"><a href="#10-2-API" class="headerlink" title="10.2 API"></a>10.2 API</h1><ul><li><p>signal</p></li><li><p>kill / raise</p></li><li><p>alarm</p></li><li><p>pause</p></li><li><p>sigemptyset / sigfillset / sigaddset / sigdelset / sigismember</p></li><li><p>sigprocmask / sigpending</p></li><li><p>sigsetjmp / siglongjmp</p></li><li><p>sigsuspend</p><p>信号屏蔽字被设置为sigmask指向的值然后挂起，在捕捉一个信号之后返回恢复原来的sigmask </p></li><li><p>abort</p></li></ul><h1 id="11-线程"><a href="#11-线程" class="headerlink" title="11. 线程"></a>11. 线程</h1><h2 id="11-1-进程与线程的概念"><a href="#11-1-进程与线程的概念" class="headerlink" title="11.1 进程与线程的概念"></a>11.1 进程与线程的概念</h2><ul><li>进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位）</li><li>进程有自己的独立地址空间，线程是共享进程的地址空间</li><li>线程之间通信更方便，进程则要通过各种IPC机制</li><li>多进程更加健壮，一个进程异常挂掉不会导致其他进程挂掉</li></ul><h2 id="11-2-多线程与多核"><a href="#11-2-多线程与多核" class="headerlink" title="11.2 多线程与多核"></a>11.2 多线程与多核</h2><ul><li>单核也可以多线程</li><li>多核多线程可以达成同时run的效果</li></ul><h2 id="11-3-pthread标准"><a href="#11-3-pthread标准" class="headerlink" title="11.3 pthread标准"></a>11.3 pthread标准</h2><ul><li><p>POSIX 线程</p><p>LinuxThreads的变化（NPTL）</p></li></ul><h2 id="11-4-线程信息"><a href="#11-4-线程信息" class="headerlink" title="11.4 线程信息"></a>11.4 线程信息</h2><p><strong>以下不共享</strong></p><ul><li><p>线程ID</p><p>pthread_t / pthread_equal / pthread_self</p></li><li><p>栈</p></li><li><p>信号屏蔽字</p></li><li><p>调度优先级</p></li><li><p>errno变量</p></li><li><p>线程私有数据</p></li></ul><h2 id="11-5-线程的生与死"><a href="#11-5-线程的生与死" class="headerlink" title="11.5 线程的生与死"></a>11.5 线程的生与死</h2><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><ul><li><p>pthread_creat<strong>e</strong></p></li><li><p>线程创建不能保证哪个线程会先运行</p></li><li><p>线程继承调用线程的浮点环境和信号屏蔽字</p><p>但是 pending 信号集会被清除</p></li></ul><h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h3><ul><li><p>导致进程终止</p><ul><li>任意线程调用 exit / _exit / _Exit</li><li>发送给线程的信号（默认终止进程）</li></ul></li><li><p>单一线程终止</p><ul><li><p>线程从启动历程返回</p><p>pthread_join / pthread_datch</p></li><li><p>线程被同一进程的其他线程取消</p><p>pthread_cancel</p></li><li><p>线程调用 pthread_exit</p></li></ul></li><li><p>线程清理处理程序</p><ul><li>pthread_cleanup_push / pthread_cleanup_pop</li><li>清理情况：<ul><li>主动调用 pthread_exit</li><li>响应 pthread_cancel</li><li>调用 pthread_cleanup_pop 参数不为0的时候</li></ul></li><li>直接 return 并不会执行清理</li><li>执行顺序与注册顺序相反</li></ul></li></ul><h2 id="11-6-进程与线程原语"><a href="#11-6-进程与线程原语" class="headerlink" title="11.6 进程与线程原语"></a>11.6 进程与线程原语</h2><table><thead><tr><th>进程原语</th><th>线程原语</th><th>描述</th></tr></thead><tbody><tr><td>fork</td><td>pthread_create</td><td>创建新的控制流</td></tr><tr><td>exit</td><td>pthread_exit</td><td>从现有的控制流中退出</td></tr><tr><td>waitpid</td><td>pthread_join</td><td>从控制流中得到退出状态</td></tr><tr><td>atexit</td><td>pthread_cancel_push</td><td>注册在退出控制流时调用的函数</td></tr><tr><td>getpid</td><td>pthread_self</td><td>获取控制流的ID</td></tr><tr><td>abort</td><td>pthread_cancel</td><td>请求控制流的非正常退出</td></tr></tbody></table><h2 id="11-7-线程同步、一致性问题"><a href="#11-7-线程同步、一致性问题" class="headerlink" title="11.7 线程同步、一致性问题"></a>11.7 线程同步、一致性问题</h2><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><ul><li><p>POSIX互斥量</p><p>struct pthread_mutex_t</p><ul><li><p>初始化/销毁</p><p>pthread_mutex_init / pthread_mutex_destory</p></li><li><p>上锁</p><p>pthread_mutex_lock / pthread_mutex_timedlock / pthread_mutex_trylock / pthread_mutex_unlock</p></li><li><p>解锁</p><p>pthread_mutex_unlock</p></li></ul></li><li><p>死锁</p><ul><li><p>AB型死锁</p><p>解决方法：</p><ol><li>按序获取锁（程序复杂）</li><li>trylock / timedlock</li></ol></li></ul></li></ul><h3 id="读写锁-共享互斥锁"><a href="#读写锁-共享互斥锁" class="headerlink" title="读写锁(共享互斥锁)"></a>读写锁(共享互斥锁)</h3><ul><li><p>状态</p><ul><li><p>读锁：读请求 pass ，写请求阻塞直到读锁释放（共享锁）</p><p>引用计数实现</p><p>注意写请求的饥饿情况，通常写请求后的读请求被阻塞（FIFO)</p></li><li><p>写锁：阻塞任何的加锁请求（互斥锁）</p></li><li><p>无锁</p></li></ul></li><li><p>一次只有一个线程可以占有写锁，可以有多个线程同时占有读锁</p></li><li><p>适用于读请求&gt;&gt;写请求的情况</p></li><li><p>POSIX读写锁</p><ul><li><p>初始化 / 销毁</p><p>pthread_rwlock_init / pthread_rwlock_destroy</p></li><li><p>读锁</p><p>pthread_rwlock_rdlock / pthread_rwlock_tryrdlock / pthread_rwlock_timedrdlock</p></li><li><p>写锁</p><p>pthread_rwlock_wrlock / pthread_rwlock_trywrlock / pthread_rwlock_timedwrlock</p></li><li><p>解锁</p><p>pthread_rwlock_unlock</p></li></ul></li></ul><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><ul><li><p>配合互斥量使用，提供多线程会合的时间点</p></li><li><p>初始化 / 销毁</p><p>pthread_cond_init / pthread_cond_destroy</p></li><li><p>等待条件变量变为true</p><p>pthread_cond_wait / pthread_cond_timedwait</p></li><li><p>条件变量置信</p><p>pthread_cond_signal 唤醒一个 / pthread_cond_broadcast 唤醒所有</p></li></ul><h3 id="自旋锁-spinlock"><a href="#自旋锁-spinlock" class="headerlink" title="自旋锁 spinlock"></a>自旋锁 spinlock</h3><ul><li>特征：忙等阻塞</li><li>锁持有时间段，线程不希望被调度</li><li>用户态基本不使用自旋锁</li><li>不要调用在持有自旋锁的情况下可能会进入休眠状态的函数</li></ul><h3 id="屏障-barrier"><a href="#屏障-barrier" class="headerlink" title="屏障 barrier"></a>屏障 barrier</h3><ul><li><p>协调多个进程并行工作</p><p>每个线程等待，直到所有线程共同达到某一点</p></li><li><p>初始化 / 销毁</p><p>pthread_barrier_init / pthread_barrier_destory</p></li><li><p>等待</p><p>pthread_barrier_wait</p><p>未满足屏障计数时阻塞 、满足屏障计数时唤醒所有（最后一个线程）</p></li></ul><h1 id="12-线程控制"><a href="#12-线程控制" class="headerlink" title="12. 线程控制"></a>12. 线程控制</h1><h2 id="12-1-属性"><a href="#12-1-属性" class="headerlink" title="12.1 属性"></a>12.1 属性</h2><h3 id="pthread遵循的对于属性的模式"><a href="#pthread遵循的对于属性的模式" class="headerlink" title="pthread遵循的对于属性的模式"></a>pthread遵循的对于属性的模式</h3><ol><li>每个对象都和自己类型的属性对象相关联（互斥量与互斥量属性相关联，线程与线程属性相关联），表现为 attr 指针，每个属性对象可以代表多个属性。属性对应用不透明，便于提高可移植性，因此需要函数来进行管理</li><li>每个属性对象有一个初始化函数，它把属性设置为默认值</li><li>还有一个销毁属性对象的函数，用于释放与属性对象的资源</li><li>获取各个属性值的函数，返回存储它的内存单元</li><li>设置属性值的函数，一般来说属性作为参数用指针传递</li></ol><h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><ul><li><p>初始化 / 销毁</p><p>pthread_attr_init / pthread_attr_destory</p></li><li><p>线程分离状态属性(分离线程的资源在线程终止时立即收回，无法用 join 等待其终止状态)</p><p>pthread_attr_getdetachstate / pthread_attr_setdetachstate</p></li><li><p>以下不建议用</p><p>pthread_attr_getguardsize / pthread_attr_setguardsize</p><p>pthread_attr_getstacksize / pthread_attr_setstacksize</p><p>pthread_attr_getstack / pthread_attr_setstack</p></li><li><p>取消状态（取消点）不建议用</p><p>PTHREAD_CANCEL_ENABLE / PTHREAD_CANCEL_DISABLE </p><p>pthread_setcancelstate</p><p>被取消线程在调用点会感知到取消 (pthread_cancel调用方不等待)</p><p>默认情况延迟取消</p></li></ul><h3 id="同步属性"><a href="#同步属性" class="headerlink" title="同步属性"></a>同步属性</h3><h4 id="互斥量属性-pthread-mutexattr-t"><a href="#互斥量属性-pthread-mutexattr-t" class="headerlink" title="互斥量属性 pthread_mutexattr_t"></a>互斥量属性 pthread_mutexattr_t</h4><p><del>共享属性、健壮属性</del>、类型属性</p><ul><li><p>pthread_mutexattr_init / pthread_mutexattr_destroy</p></li><li><p>以下不建议使用</p><ul><li><p>进程共享(内核开销大，不属于NPTL)</p><p>pthread_mutexattr_getpshared / pthread_mutexattr_setpshared</p></li><li><p>健壮属性</p></li><li><p><strong>类型属性</strong></p><ul><li><p>pthread_mutexattr_gettype / pthread_mutexattr_settype</p></li><li><table><thead><tr><th>互斥量类型</th><th>递归上锁</th><th>不占用时解锁</th><th>已解锁时解锁</th></tr></thead><tbody><tr><td>PTHREAD_MUTEX_NORMAL</td><td>死锁</td><td>未定义</td><td>未定义</td></tr><tr><td>PTHREAD_MUTEX_ERRORCHECK</td><td>返回错误</td><td>返回错误</td><td>返回错误</td></tr><tr><td>PTHREAD_MUTEX_RECURSIVE</td><td>允许</td><td>返回错误</td><td>返回错误</td></tr><tr><td>PTHREAD_MUTEX_DEFAULT</td><td>未定义</td><td>未定义</td><td>未定义</td></tr></tbody></table></li><li><p>递归锁的使用场景</p><p><img src="https://i.loli.net/2021/10/15/adhHkbEo9LBI1gC.png" alt="image-20211015230742334"></p></li></ul></li></ul></li></ul><h4 id="读写锁属性-pthread-rwlockattr-t"><a href="#读写锁属性-pthread-rwlockattr-t" class="headerlink" title="读写锁属性 pthread_rwlockattr_t"></a>读写锁属性 pthread_rwlockattr_t</h4><ul><li>pthread_rwlockattr_init / pthread_rwlockattr_destroy</li><li>pthread_rwlockattr_getpshared / pthread_rwlockattr_setpshared</li></ul><h4 id="条件变量属性-pthread-condattr-t"><a href="#条件变量属性-pthread-condattr-t" class="headerlink" title="条件变量属性 pthread_condattr_t"></a>条件变量属性 pthread_condattr_t</h4><ul><li>pthread_condattr_init / pthread_condattr_destroy</li><li>pthread_condattr_getpshared / pthread_condattr_setpshared</li></ul><h4 id="屏障属性-pthread-barrierattr-t"><a href="#屏障属性-pthread-barrierattr-t" class="headerlink" title="屏障属性 pthread_barrierattr_t"></a>屏障属性 pthread_barrierattr_t</h4><ul><li>pthread_barrierattr_init / pthread_barrierattr_destroy</li><li>pthread_barrierattr_getpshared / pthread_barrierattr_setpshared</li></ul><h2 id="12-2-重入"><a href="#12-2-重入" class="headerlink" title="12.2 重入"></a>12.2 重入</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>如果一个函数对多个线程来说时可重入的，就说这个函数是线程安全的。但并不能说明对信号处理程序来说该函数也是可重入的。</p></li><li><p>如果函数对于异步信号处理程序的重入是安全的，那么可以说函数是异步信号安全的</p></li><li><p><strong>重入的要求高于线程安全</strong></p><p>可重入要求信号安全</p><p>一般来说：</p><p>如果一个函数的实现使用了全局或者静态变量，且访问未加锁，那么这个函数既不是可重入的，也不是线程安全的。</p><p>如果放宽条件，这个函数仍然用到了全局或者静态变量，但是在访问这些变量时，通过加锁来保证互斥访问，那么这个函数就可以变成线程安全的函数。但它此时仍然是不可重入的，因为通常加锁是针对不同线程的访问，对同一线程可能出现问题（发生信号软中断，signal handler中恰巧也执行了该函数）。</p></li></ul><h3 id="非线程安全函数"><a href="#非线程安全函数" class="headerlink" title="非线程安全函数"></a>非线程安全函数</h3><p><img src="https://i.loli.net/2021/10/15/7JrTCHj1DRlBpy6.png" alt="image-20211015231532218"></p><h3 id="替代的线程安全函数"><a href="#替代的线程安全函数" class="headerlink" title="替代的线程安全函数"></a>替代的线程安全函数</h3><p><img src="https://i.loli.net/2021/10/15/3b7pgVX6hin1FEW.png" alt="image-20211015231605762"></p><h2 id="12-3-线程私有数据"><a href="#12-3-线程私有数据" class="headerlink" title="12.3 线程私有数据"></a>12.3 线程私有数据</h2><ul><li><p>由于线程共享地址空间，故线程无法阻止另一个线程访问其私有数据</p><p>因此需要管理线程特定数据的函数（设计上封装隔离）</p></li><li><p>pthread_key_create / pthread_key_delete</p></li><li><p>让不同线程看到同一个键值 pthread_once</p><p>pthread_once_t = PTHREAD_ONCE_INIT</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destructor</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *)</span></span>;<br><span class="hljs-keyword">pthread_key_t</span> key;<br><span class="hljs-keyword">pthread_once_t</span> init_done = PTHREAD_ONCE_INIT;<br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">thread_init</span><span class="hljs-params">(Void)</span></span><br><span class="hljs-function"></span>&#123;<br>err = pthread_key_create(&amp;key, destructor);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">threadfunc</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>pthread_once(&amp;init_done, thread_init);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>关联键和私有数据</p><p>pthread_getspecific / pthread_setspecific</p></li></ul><h2 id="12-4-线程和信号"><a href="#12-4-线程和信号" class="headerlink" title="12.4 线程和信号"></a>12.4 线程和信号</h2><ul><li><p>线程都有自己的信号屏蔽字</p></li><li><p>线程的处理是进程中所有线程共享的</p></li><li><p>信号是传递给单个线程的</p><ul><li>信号与硬件相关，递送给引起时间的进程</li><li>其他信号发送给任意一个进程</li></ul></li><li><p>pthread_sigmask</p><ul><li><p>sigprocmask在多线程环境中行为未定义</p></li><li><p>用法类似sigprocmask</p></li><li><p>sigwait等待信号出现</p><ul><li><p>先阻塞等待的信号（在外部）</p></li><li><p>原子取消信号集阻塞状态</p></li><li><p>信号递送后返回</p></li><li><p>返回前恢复阻塞信号集</p><p>类比条件变量和互斥量</p></li></ul></li><li><p>多个线程等待同一信号，只有一个会被唤醒</p></li></ul></li><li><p>pthread_kill</p><p>给指定进程发送信号</p></li><li><p>线程与I/O</p><ul><li><p>lseek read</p><p>多线程有问题</p></li><li><p>pread</p><p>lseek read 的原子操作</p></li></ul></li></ul><h2 id="12-5-API"><a href="#12-5-API" class="headerlink" title="12.5 API"></a>12.5 API</h2><ul><li>pthread_attr_init / pthread_attr_destroy</li><li>pthread_attr_getdetachstate / pthread_attr_setdetachstate</li><li>pthread_key_create</li><li>pthread_mutexattr_init / pthread_mutexattr_destroy</li><li>pthread_mutexattr_gettype / pthread_mutexattr_settype</li><li>pthread_key_create / pthread_key_delete</li><li>pthread_getspecific / pthread_setspecific</li><li>pthread_sigmask</li><li>pthread_sigkill</li></ul><h1 id="13-守护进程"><a href="#13-守护进程" class="headerlink" title="13. 守护进程"></a>13. 守护进程</h1><h2 id="13-1-概念"><a href="#13-1-概念" class="headerlink" title="13.1 概念"></a>13.1 概念</h2><h3 id="守护进程的概念"><a href="#守护进程的概念" class="headerlink" title="守护进程的概念"></a>守护进程的概念</h3><ul><li>内核态守护进程（内核线程）<ul><li>eg： 虚拟内存换页kswapd / 脏页面冲刷 flush</li></ul></li><li>用户态守护进程<ul><li>由 init 拉起</li><li>setsid 使其一般是会话首进程，同时也是进程组组长、唯一进程</li></ul></li></ul><h3 id="编写守护进程的惯例"><a href="#编写守护进程的惯例" class="headerlink" title="编写守护进程的惯例"></a>编写守护进程的惯例</h3><ol><li><p>umask 设置文件模式创建屏蔽字</p><p>通常 umask(0)</p></li><li><p>父进程 fork 并 exit</p><p>为子进程 setsid 创建会话创造条件</p></li><li><p> setsid</p></li></ol><p>   会话首进程 / 进程组组长 / 没有控制终端</p><ol start="4"><li><p>当前工作目录改为根目录或者其他位置</p><p>chdir(“/“)            防挂在umount</p></li><li><p>关闭不用的文件描述符</p><p>首先 getrlimit 判定最高文件描述符的值，然后用循环全部关闭</p></li><li><p>打开 /dev/null 使具有文件描述符0、1、2</p><p>因为守护进程并不与终端设备相关联，无从显示也无需输入</p><p>fd0 = open(“/dev/null”, O_RDWR);</p></li><li><p>一般还需要处理 SIGHUP 信号</p><p>原因：孤儿进程</p></li></ol><h3 id="出错记录"><a href="#出错记录" class="headerlink" title="出错记录"></a>出错记录</h3><ul><li><img src="https://i.loli.net/2021/10/15/U2B4Ym8CMXEQ1Lh.png" alt="image-20211015160833072"></li><li>内核例程调用log函数</li><li>用户守护进程调用 syslog 函数</li><li>本地或其他主机可通过 UDP 514端口传递log</li><li>rsyslog</li></ul><h3 id="单例守护进程"><a href="#单例守护进程" class="headerlink" title="单例守护进程"></a>单例守护进程</h3><ul><li><p>文件记录锁</p><p>记录锁</p></li><li><p>惯例</p><ol><li><p>锁通常指定在 /var/run/%name%.pid</p><p>内容一般就是pid号</p></li><li><p>配置文件通常在 /etc/%name%.conf</p></li><li><p>守护进程一般通过初始化脚本之一启动</p><p>/etc/rc*    /etc/init.d/*    /etc/inittab启动自动重启</p></li><li><p>一般注册 SIGHUP 处理程序</p><p>一方面使为了防止默认动作终止</p><p>功能上设置为重新读取配置</p></li></ol></li></ul><h2 id="13-2-API"><a href="#13-2-API" class="headerlink" title="13.2 API"></a>13.2 API</h2><ul><li>openlog / syslog / closelog / setlog / mask</li><li>vsyslog</li></ul><h1 id="14-进阶I-O"><a href="#14-进阶I-O" class="headerlink" title="14 进阶I/O"></a>14 进阶I/O</h1><h2 id="14-1-非阻塞I-O"><a href="#14-1-非阻塞I-O" class="headerlink" title="14.1 非阻塞I/O"></a>14.1 非阻塞I/O</h2><ul><li><p>低速系统调用</p><p>定义：会引起进程永久阻塞</p><ul><li>某些文件类型数据不存在，读引起永久阻塞</li><li>数据不能被相同的文件类型接受，写操作会永久阻塞</li><li>对加了记录锁的文件读写</li><li>ioctl</li><li>进程通信函数</li></ul></li><li><p>open 先天指定 O_NONBLOCK</p></li><li><p>fcntl 后天设置  O_NONBLOCK</p></li><li><p>轮询 polling + 非阻塞I/O</p><p>类似用户态的自旋锁   浪费cpu时间</p></li><li><p>多线程 + 阻塞I/O</p><p>额外的线程开销、同步开销</p></li></ul><h2 id="14-2-记录锁-recording-lock"><a href="#14-2-记录锁-recording-lock" class="headerlink" title="14.2 记录锁 recording lock"></a>14.2 记录锁 recording lock</h2><ul><li><p>确保进程单独写文件</p><p>进程读或写文件的某个部分时，使用记录锁组织其他进程修改同一文件区</p><p>byte range locking</p></li><li><p>fcntl 记录锁</p><ul><li><p>struct flock</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">flock</span>&#123;</span><br><span class="hljs-keyword">short</span> l_type;<br><span class="hljs-keyword">short</span> l_whence;<br><span class="hljs-keyword">off_t</span> l_start;<br><span class="hljs-keyword">off_t</span> l_len;<br><span class="hljs-keyword">pid_t</span> l_pid;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>l_type :  F_GETLK / F_SETLK / F_SETLKW</p></li><li><p>F_GETLK 检测上锁后上锁不是原子操作</p></li><li><p>F_SETLKW 检测到死锁后杀死另一个进程获得资源</p></li></ul></li><li><p>锁的隐含继承与释放</p><ol><li><p>进程终止时，建立的所有锁全部释放</p></li><li><p>关联的fd何时关闭，锁都会释放</p></li><li><p>fork 子进程只能继承文件描述符，不能继承它的锁</p></li></ol></li><li><p>文件尾端加锁</p></li><li><p>建议性锁和强制性锁</p></li></ul><h2 id="14-3-异步I-O"><a href="#14-3-异步I-O" class="headerlink" title="14.3 异步I/O"></a>14.3 异步I/O</h2><p>不建议用</p><h2 id="14-4-I-O多路转接-multiplexing"><a href="#14-4-I-O多路转接-multiplexing" class="headerlink" title="14.4 I/O多路转接(multiplexing)"></a>14.4 I/O多路转接(multiplexing)</h2><h3 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h3><ul><li><p>阻塞模式下在多个fd上写，一个block会导致后面的pending</p><ul><li><p>polling + 无阻塞可以解决</p></li><li><p>异步I/O 用信号通知</p><p>缺点在于不知道哪个fd ready（不够映射）</p></li><li><p>I/O多路复用</p></li></ul></li></ul><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><ul><li>select / pselect</li><li>pselect 支持 timespec 结构，更精确的时间</li><li>最多支持fd 有上限</li></ul><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><ul><li>通过数组表明关心的条件</li><li>解决了fd数量的瓶颈</li></ul><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><ul><li>linux I/O多路转接的最优机制</li><li>性能高<ul><li>规避了所有fd的用户态 copy 到内核态的开销<ul><li>fd常驻内核</li><li>内核以红黑树组织</li></ul></li><li>内核态只回传ready 部分的fd</li><li>边沿触发</li></ul></li></ul><h2 id="14-5-其他"><a href="#14-5-其他" class="headerlink" title="14.5 其他"></a>14.5 其他</h2><h3 id="readv-writev"><a href="#readv-writev" class="headerlink" title="readv / writev"></a>readv / writev</h3><ul><li><p>散布读(scatter read) / 聚集写(gather write)</p><ul><li><p>iovec 结构数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span>&#123;</span><br><span class="hljs-keyword">void</span> *iov_base;<br><span class="hljs-keyword">size_t</span> iov_len<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>降低系统调用的次数，获取性能</p></li></ul><h3 id="readn-writen"><a href="#readn-writen" class="headerlink" title="readn / writen"></a>readn / writen</h3><ul><li><p>apue 对 read / write 的一些容错封装</p></li><li><p>原因： 管道、FIFO、网络、终端</p><p>可能读的字节数小于指定数量</p><p>写可能因为内核缓冲区满而失效</p></li></ul><h3 id="mmap-munmap"><a href="#mmap-munmap" class="headerlink" title="mmap / munmap"></a>mmap / munmap</h3><ul><li><p>存储映射I/O</p><p>磁盘文件映射到内存空间</p><p>直接读写内存就是修改磁盘文件</p></li><li><p>mprotect</p><p>修改映射区权限</p></li><li><p>msync</p><p>立刻同步刷新</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
