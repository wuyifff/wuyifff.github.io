<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>introduction to Distributed Systems</title>
    <link href="/2022/03/09/DS/1.%20introduction%20to%20Distributed%20Systems%20/"/>
    <url>/2022/03/09/DS/1.%20introduction%20to%20Distributed%20Systems%20/</url>
    
    <content type="html"><![CDATA[<h1 id="1-introduction-to-Distributed-Systems"><a href="#1-introduction-to-Distributed-Systems" class="headerlink" title="1. introduction to Distributed Systems"></a>1. introduction to Distributed Systems</h1><h1 id="1-1-About-Distributed-Systems"><a href="#1-1-About-Distributed-Systems" class="headerlink" title="1.1 About Distributed Systems"></a>1.1 About <strong><strong>Distributed Systems</strong></strong></h1><p>单机的并发<strong>（concurrency）</strong>又称为是共享内存(shared-memory)的并发，通过指针或变量可以很方便的进行</p><p>而非单机场景下，不同的电脑可以并行执行程序，他们只能通过网络通信，构成分布式系统</p><p>分布式系统中每一个电脑被称为<strong>结点(node)，结点可以是任何互相连接的计算设备</strong></p><h3 id="为何构建分布式系统？（优点）"><a href="#为何构建分布式系统？（优点）" class="headerlink" title="为何构建分布式系统？（优点）"></a>为何构建分布式系统？（优点）</h3><ol><li>一些应用是天然(intrinsically)的分布式系统，例如接打电话</li><li>分布式系统比单机更加<strong>可靠</strong></li><li>分布式系统有更好的<strong>性能</strong>，更快的响应速度（地理相邻）</li><li>一些<strong>数据太大</strong>而不能放在一个机器上</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li><strong>网络错误</strong>导致结点无法相互通信</li><li>结点可能会崩溃(crash)、运行缓慢</li></ol><p>因此：</p><ul><li>我们需要有方法检测crash</li><li>分布式系统需要有容错处理</li></ul><h1 id="1-2-RPC（远程过程调用）"><a href="#1-2-RPC（远程过程调用）" class="headerlink" title="1.2 RPC（远程过程调用）"></a>1.2 RPC（远程过程调用）</h1><p>分布式系统不关心网络如何传输，只关心网络的两个指标：<strong>时延(latency)、吞吐量(bandwidth)</strong></p><p>RPC的调用其他本地的函数一样，只是在本地的代码中，一部分的执行需要等待<strong>别的结点</strong>上的程序的执行结果返回。</p><p>RPC 会<strong>隐藏底层的通讯细节</strong>（不需要直接处理Socket通讯或Http通讯），在调用时会留下一个stub，就像其他本地的代码一样。</p><ul><li>通信流程<ul><li>首先寻址通讯，<strong>建立TCP连接</strong></li><li>当A服务器上的应用发起远程过程调用时，方法的<strong>参数</strong>需要通过底层的网络协议如TCP传递到B服务器，由于<strong>网络协议是基于二进制的</strong>，内存中的参数的值要序列化成二进制的形式，也就是<strong>序列化（Serialize）或编组（marshal）</strong>，通过寻址和传输将序列化的二进制发送给B服务器。</li><li>B服务器收到请求后，需要对参数进行<strong>反序列化</strong>（序列化的逆操作），<strong>恢复为内存中的表达方</strong>式，然后找到对应的方法（寻址的一部分）进行本地调用，然后得到返回值。</li><li>返回值还要发送回服务器A上的应用，也要经过序列化的方式发送，服务器A接到后，再反序列化，恢复为内存中的表达方式，<strong>交给A服务器上的应用</strong></li></ul>  <img src="https://s2.loli.net/2022/03/09/wY8tPdl5TFQUy7f.png" alt="rpc">  rpc</li></ul><p><img src="https://s2.loli.net/2022/03/09/5YcbVglU1XSipam.png" alt="rpc2"></p><p>rpc2</p><p>如果RPC调用失败，则会重试不止一次。但如果一直错误，不能无限的重试，因此需要设置<strong>超时(timeout)</strong></p><p>RPC框架要做到最基本的3件事情：</p><ul><li><strong>服务端如何确定客户端要调用的函数</strong>；<br>在远程调用中，客户端和服务端分别<strong>维护一个【ID-&gt;函数】的对应表</strong>， ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，附上这个ID，服务端通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。</li><li><strong>如何进行序列化和反序列化</strong>；<br>客户端和服务端交互时将参数或结果转化为字节流在网络中传输，那么数据转化为字节流的或者将字节流转换成能读取的<strong>固定格式</strong>时就需要进行序列化和反序列化，序列化和反序列化的<strong>速度</strong>也会影响远程调用的效率。</li><li><strong>如何进行网络传输</strong><br>多数RPC框架选择TCP作为传输协议，也有部分选择HTTP。如gRPC使用HTTP2。不同的协议各有利弊。TCP更加高效，而HTTP在实际应用中更加的灵活</li></ul><h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><p>representational state transfer <strong>表征状态转移</strong>（REST）</p><p>REST是一种架构风格，指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。REST规范<strong>把所有内容都视为资源</strong>，网络上一切皆资源。</p><ul><li><strong>6个约束</strong>：<ol><li><strong>客户端—服务器</strong><br>服务端与客户端<strong>独立实现并独立开发</strong>，只要<strong>接口不改变</strong>即可。提高跨多个平台的用户接口的可移植性并提高可伸缩性。</li><li><strong>统一接口</strong><br>系统中的多个组件都依赖于统一接口，包含4个子约束：<ol><li><strong>资源的标识</strong><br>资源<strong>通过URL区分</strong>，当访问一个URL时，能够获取该资源或对它执行相应的操作。</li><li><strong>通过表述操作资源</strong><br>客户端请求资源时，可以指定期望的格式，服务器返回响应时，响应包含了指定格式的资源。访问同一个资源的不同格式无须修改资源的标识符，客户端也可以通过资源的表述对资源进行操作。</li><li><strong>自描述消息</strong><br>客户端和服务器之间传递的消息都应<strong>包含足够的信息</strong>（如<strong>资源表述的格式和内容长度，甚至相关的其他操作信息</strong>）。</li><li>超媒体作为应用程序状态的引擎（HATEOAS）<br>服务器返回的资源表述中包含与之相关的链接，这些链接能够对资源执行其他操作。</li></ol></li><li><strong>分层系统</strong><br>服务端和客户端不知道网络中介（代理或网关等）的存在，增强安全、负载均衡和响应缓存等。</li><li><strong>缓存</strong><br>客户端和网络中介都可以缓存服务器返回的响应，以便于减少数据获取延迟和服务器的请求次数，提高系统性能。</li><li><strong>无状态</strong><br>服务器不会记录或存储客户端的状态信息。从客户端到服务器的每个请求都必须包含理解请求所需的所有信息，并且不能利用服务器上任何存储的上下文。</li><li><strong>按需编码（可选）</strong><br>允许服务器临时向客户端返回可执行的程序代码用于客户端拓展和自定义功能，简化客户端。</li></ol></li></ul><p><img src="https://s2.loli.net/2022/03/09/2XojBslAMrReQ9U.png" alt="Untitled"></p><h2 id="SOA（Service-Oriented-Architecture）"><a href="#SOA（Service-Oriented-Architecture）" class="headerlink" title="SOA（Service-Oriented Architecture）"></a><strong><strong>SOA（Service-Oriented Architecture）</strong></strong></h2><p>将一个大型软件分成多个服务（或多个结点），其间通过RPC来通信</p><p><strong>微服务是SOA架构的一种变体</strong></p>]]></content>
    
    
    <categories>
      
      <category>Distributed Systems</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ primer 读书笔记 chapter 14 重载运算与类型转换</title>
    <link href="/2021/11/02/c++/14.%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>/2021/11/02/c++/14.%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="C-Primer-重载运算与类型转换"><a href="#C-Primer-重载运算与类型转换" class="headerlink" title="C++ Primer - 重载运算与类型转换"></a>C++ Primer - 重载运算与类型转换</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>重载的运算符是具有<strong>特殊名字的函数</strong>（关键字operator接要定义的运算符号）。</p><p>既然是函数，所以也有<strong>返回类型、参数列表和函数体</strong>。其中参数数量与该运算符作用的运算对象一样多。一元运算符有一个参数，二元运算符有两个（唯一的一个三元运算符不能重载）。对二元运算符来说，左侧运算对象传递给第一个参数，而右侧运算对象传递给第二个参数。<strong>除了重载的函数调用运算符<code>operator()</code>之外，其他重载运算符不能含有默认实参</strong>。</p><blockquote><p>有的运算符既可以当一元也可以当二元，这个时候要根据重载参数个数来判断语义。</p></blockquote><p>如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的this指针上，因此，<strong>成员运算符函数（显式）的参数数量比运算符的运算对象总是少一个。</strong></p><p>运算符函数要么是类的成员，要么至少含有一个类类型参数，这就意味着无法对内置类型的运算对象进行运算符重载。</p><blockquote><p>比如<code>int operator+(int, int);</code>就是错误的语法，不能改变内置类型的运算符行为。</p></blockquote><p>只能重载已有的运算符，不能搞新发明。不是所有的运算符都能重载。</p><table><thead><tr><th align="left">可重载运算符</th><th align="left"></th><th align="left"></th><th align="left"></th><th align="left"></th><th align="left"></th><th></th><th></th></tr></thead><tbody><tr><td align="left">+</td><td align="left">-</td><td align="left">*</td><td align="left">/</td><td align="left">%</td><td align="left">^</td><td></td><td></td></tr><tr><td align="left">&amp;</td><td align="left">\</td><td align="left"></td><td align="left">~</td><td align="left">!</td><td align="left">,</td><td>=</td><td></td></tr><tr><td align="left">&lt;</td><td align="left">&gt;</td><td align="left">&lt;=</td><td align="left">&gt;=</td><td align="left">++</td><td align="left">–</td><td></td><td></td></tr><tr><td align="left">&lt;&lt;</td><td align="left">&gt;&gt;</td><td align="left">==</td><td align="left">!=</td><td align="left">&amp;&amp;</td><td align="left">\</td><td>\</td><td></td></tr><tr><td align="left">+=</td><td align="left">-=</td><td align="left">/=</td><td align="left">%=</td><td align="left">^=</td><td align="left">&amp;=</td><td></td><td></td></tr><tr><td align="left">\</td><td align="left">=</td><td align="left">*=</td><td align="left">&lt;&lt;=</td><td align="left">&gt;&gt;=</td><td align="left">[]</td><td>()</td><td></td></tr><tr><td align="left">-&gt;</td><td align="left">-&gt;*</td><td align="left">new</td><td align="left">new[]</td><td align="left">delete</td><td align="left">delete[]</td><td></td><td></td></tr><tr><td align="left"><strong>不能重载运算符</strong></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td></td><td></td></tr><tr><td align="left">::</td><td align="left">.*</td><td align="left">.</td><td align="left">? :</td><td align="left"></td><td align="left"></td><td></td><td></td></tr></tbody></table><p>运算符函数一般通过间接调用，当然也可以直接调用。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">data1 + data2;<br><span class="hljs-keyword">operator</span>+(data1, data2);<br><br>data1 += data2;<br>data1.<span class="hljs-keyword">operator</span>+=(data2);<br></code></pre></div></td></tr></table></figure><p>尽管有些运算符可以重载，但大多数情况下不建议重载，它们是<code>, &amp; || &amp;&amp;</code>。</p><p>运算符重载虽然可以为所欲为，但最好让他们的含义与内置类型一致，不要违直觉定义。</p><ul><li><strong>如果类执行IO操作，那么&lt;&lt;和&gt;&gt;就应该与内置类型的IO一致。</strong></li><li><strong>如果类的某个操作是检查相等性，则定义operator==，通常也应该有operator!=。</strong></li><li><strong>如果类包含一个内在的单序比较操作，则定义operator&lt;，如果有了&lt;，一般也有其他关系操作。</strong></li><li><strong>重载运算符的返回类型通常应与内置版本的返回类型兼容：逻辑运算符和关系运算符应该返回bool，算术运算符应该返回类类型的值，赋值运算符和复合赋值运算符应该返回左侧运算对象的一个引用。</strong></li></ul><p>定义重载运算符时，必须要先决定是声明为类成员函数还是普通的非成员函数。对此，有一些准则：</p><ul><li><strong>赋值、下标、调用和成员访问箭头运算符必须是成员。</strong></li><li><strong>复合赋值运算符一般来说应该是成员，但并非必须。</strong></li><li><strong>改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，应该是成员。</strong></li><li><strong>具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，它们应该是普通的非成员函数（成员函数则会引发<code>string u = &quot;hi&quot; + s;</code>错误的灾难）。</strong></li><li><strong>输入输出运算符必须是非成员函数。</strong></li></ul><table><thead><tr><th>是否成员函数</th><th>运算符类型</th></tr></thead><tbody><tr><td>必须是成员函数</td><td>赋值运算、下标运算、调用、箭头运算符</td></tr><tr><td>应该是成员函数</td><td>复合赋值、递增递减、解引用</td></tr><tr><td>应该非成员函数（应该友元函数）</td><td>算术运算符、关系运算符、位运算</td></tr><tr><td>必须非成员函数（必须友元函数）</td><td>输入输出</td></tr></tbody></table><h2 id="输入和输出运算符"><a href="#输入和输出运算符" class="headerlink" title="输入和输出运算符"></a>输入和输出运算符</h2><h3 id="重载-lt-lt"><a href="#重载-lt-lt" class="headerlink" title="重载&lt;&lt;"></a>重载&lt;&lt;</h3><p>通常输出运算符的第一个形参是一个<strong>非常量ostream对象引用</strong>。非常量是因为向流写入内容会改变其状态，而引用则是因为ostream不能拷贝。第二个形参一般是一个<strong>常量的引用</strong>，该常量是我们想要打印的类类型。这里的引用是因为我们希望避免复制实参，常量则是因为打印对象通常不会改变对象内容。</p><p>为了与其他&lt;&lt;一致，operator&lt;&lt;一般返回它的ostream形参。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">ostream &amp;Sales_data::<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="hljs-keyword">const</span> Sales_data &amp;item)<br>&#123;<br>    os &lt;&lt; item.<span class="hljs-built_in">isbn</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; item.revenue &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; item.<span class="hljs-built_in">avg_price</span>();<br>  <span class="hljs-keyword">return</span> os;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>IO运算符往往需要读写类的非公有数据成员，所以IO运算符一般被声明为<strong>友元</strong>。</p><h3 id="重载-gt-gt"><a href="#重载-gt-gt" class="headerlink" title="重载&gt;&gt;"></a>重载&gt;&gt;</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;is, Sales_data &amp;item)<br>&#123;<br>    <span class="hljs-keyword">double</span> price;<br>  is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;<br>  <span class="hljs-keyword">if</span>(is)<span class="hljs-comment">//检查输入是否成功</span><br>      item.revenue = item.units_sold * price;<br>  <span class="hljs-keyword">else</span><br>      item = <span class="hljs-built_in">Sales_data</span>();<span class="hljs-comment">//输入失败，对象被赋予默认的状态</span><br>  <span class="hljs-keyword">return</span> is;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>和&lt;&lt;类似，但&gt;&gt;要额外考虑失败的情况。</p><blockquote><p>流含有错误类型的数据读取操作，或是到达文件末尾或遇到输入流的其他错误时会失败。</p></blockquote><h2 id="算术和关系运算符"><a href="#算术和关系运算符" class="headerlink" title="算术和关系运算符"></a>算术和关系运算符</h2><h3 id="重载-、"><a href="#重载-、" class="headerlink" title="重载==、!="></a>重载==、!=</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> Sales_data &amp;lhs, <span class="hljs-keyword">const</span> Sales_data &amp;rhs)<br>&#123;<br>    <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">isbn</span>() == rhs.<span class="hljs-built_in">isbn</span>() &amp;&amp; lhs.units_sold == rhs.units_sold &amp;&amp; lhs.revenue == rhs.revenue;<br>&#125;<br><br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> Sales_data &amp;lhs, <span class="hljs-keyword">const</span> Sales_data &amp;rhs)<br>&#123;<br>    <span class="hljs-keyword">return</span> !(lhs == rhs);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="重载关系运算符"><a href="#重载关系运算符" class="headerlink" title="重载关系运算符"></a>重载关系运算符</h3><p>定义了相等运算符的类一般也包含关系运算符。特别的，关联容器需要用到小于运算符，所以定义operator&lt;很有用。</p><p>通常情况下，关系运算符应该：</p><ol><li>定义顺序关系，令其与关联容器中对关键字的要求一致，并且</li><li>如果类同时含有<code>==</code>运算符的话，则定义一种关系令其与<code>==</code>保持一致。特别是，如果两个对象是<code>!=</code>的，那么一个对象应该<code>&lt;</code>另一个。</li></ol><p>对Sales_data类来说，关系运算符没有什么必要，因为语义上违直觉。</p><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>除了拷贝赋值和移动赋值运算符以外，类还可以定义其他赋值运算符，把别的类型作为右侧运算对象。</p><p>比如vector支持操作：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vector&lt;string&gt; v;<br>v = &#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;the&quot;</span>&#125;;<br></code></pre></div></td></tr></table></figure><p>之所以可以这样赋值，是因为vector类似这样重载了=运算符：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrVec</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  StrVec &amp;<span class="hljs-keyword">operator</span>=(std::initializer_list&lt;std::string&gt;);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>复合赋值运算符虽然不一定非要是类成员，但语义上作为类成员函数更符合直觉。</p><h2 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a>下标运算符</h2><p>如果一个类包含下标运算符，则<strong>通常会定义两个版本</strong>：一个返回普通引用，另一个是类的常量成员并且返回常量引用。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrVec</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  std::string&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-keyword">size_t</span> n)<br>    &#123;<br>        <span class="hljs-keyword">return</span> elements[n];<br>    &#125;<br>  <span class="hljs-keyword">const</span> std::string&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-keyword">size_t</span> n) <span class="hljs-keyword">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> elements[n];<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>  std::string *elements;<span class="hljs-comment">//指向数组首元素的指针</span><br>&#125;；<br></code></pre></div></td></tr></table></figure><p>常量对象取下标会匹配调用const版本。</p><h2 id="递增和递减"><a href="#递增和递减" class="headerlink" title="递增和递减"></a>递增和递减</h2><p>这个比较特别，有前置版本和后置版本，所以也要定义两个版本。语义上建议作为成员函数。</p><h3 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrBlobPtr</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  StrBlobPtr&amp; <span class="hljs-keyword">operator</span>++();<span class="hljs-comment">//前置</span><br>  strBlobPtr&amp; <span class="hljs-keyword">operator</span>--();<br>&#125;;<br><br>StrBlobPtr&amp; StrBlobPtr::<span class="hljs-keyword">operator</span>++()<br>&#123;<br>    <span class="hljs-built_in">check</span>(curr, <span class="hljs-string">&quot;increment past end of StrBlobPtr&quot;</span>);<br>  ++curr;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>StrBlobPtr&amp; StrBlobPtr::<span class="hljs-keyword">operator</span>--()<br>&#123;<br>  --curr;<br>    <span class="hljs-built_in">check</span>(curr, <span class="hljs-string">&quot;decrement past bgin of StrBlobPtr&quot;</span>);<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>前置运算符返回的是递增或递减后的对象引用。</p><h3 id="后置"><a href="#后置" class="headerlink" title="后置"></a>后置</h3><p>为了区分前置和后置，<strong>后置接受一个额外的不被使用的int型形参。</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrBlobPtr</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  StrBlobPtr <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>);<span class="hljs-comment">//后置</span><br>  StrBlobPtr <span class="hljs-keyword">operator</span>--(<span class="hljs-keyword">int</span>);<br>&#125;;<br>StrBlobPtr StrBlobPtr::<span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>)<br>&#123;<br>    StrBlobPtr ret = *<span class="hljs-keyword">this</span>;<br>  ++*<span class="hljs-keyword">this</span>;<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br>StrBlobPtr StrBlobPtr::<span class="hljs-keyword">operator</span>--(<span class="hljs-keyword">int</span>)<br>&#123;<br>  StrBlobPtr ret = *<span class="hljs-keyword">this</span>;<br>    --*<span class="hljs-keyword">this</span>;<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="重载-gt"><a href="#重载-gt" class="headerlink" title="重载*/-&gt;"></a>重载*/-&gt;</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrBlobPtr</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  std::string&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span><br>    &#123;<br>        <span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">check</span>(curr, <span class="hljs-string">&quot;dereference past end&quot;</span>);<br>      <span class="hljs-keyword">return</span> (*p)[curr];<span class="hljs-comment">//(*p)是对象所指的vector</span><br>    &#125;<br>  std::string* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> &amp; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">operator</span>*();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="重载"><a href="#重载" class="headerlink" title="重载()"></a>重载()</h2><p>最特别的一个。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">absInt</span>&#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> <span class="hljs-keyword">const</span></span>&#123;<br>        <span class="hljs-keyword">return</span> val &lt; <span class="hljs-number">0</span> ? -val : val;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">-42</span>;<br>absInt absObj;<br><span class="hljs-keyword">int</span> ui = <span class="hljs-built_in">absObj</span>(i);<span class="hljs-comment">//i传递给absObj.operator()</span><br></code></pre></div></td></tr></table></figure><p>只能作为类成员定义，可以重载多个函数，以参数区分。</p><p><strong>类如果定义了调用运算符，那么该类的对象就被称为函数对象。</strong></p><p>lambda会被编译器翻译成一个未命名类的未命名对象。lambda表达式产生的类中含有一个重载的函数调用运算符，所以lambda表达式实际上是函数对象。</p><p>标准库也定义了一组函数对象，plus类定义了一个函数调用运算符用于对一对运算对象执行+操作，modules类定义了调用运算符执行二元%操作，equal_to类执行==等。</p><p>这些类都是类模板，需要使用时指定具体应用类型。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">plus&lt;<span class="hljs-keyword">int</span>&gt; intAdd;<br>negate&lt;<span class="hljs-keyword">int</span>&gt; intNegate;<br><span class="hljs-keyword">int</span> sum = <span class="hljs-built_in">intAdd</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>sum = <span class="hljs-built_in">intNegate</span>(<span class="hljs-built_in">intAdd</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>));<br>sum = <span class="hljs-built_in">intAdd</span>(<span class="hljs-number">10</span>, <span class="hljs-built_in">intNegate</span>(<span class="hljs-number">10</span>));<br></code></pre></div></td></tr></table></figure><p>它们定义在functional头文件中。</p><table><thead><tr><th align="left">算术</th><th align="left">关系</th><th align="left">逻辑</th></tr></thead><tbody><tr><td align="left"><code>plus&lt;Type&gt;</code></td><td align="left"><code>equal_to&lt;Type&gt;</code></td><td align="left"><code>logical_and&lt;Type&gt;</code></td></tr><tr><td align="left"><code>minus&lt;Type&gt;</code></td><td align="left"><code>not_equal_to&lt;Type&gt;</code></td><td align="left"><code>logical_or&lt;Type&gt;</code></td></tr><tr><td align="left"><code>multiplies&lt;Type&gt;</code></td><td align="left"><code>greater&lt;Type&gt;</code></td><td align="left"><code>logical_not&lt;Type&gt;</code></td></tr><tr><td align="left"><code>divides&lt;Type&gt;</code></td><td align="left"><code>greater_equal&lt;Type&gt;</code></td><td align="left"></td></tr><tr><td align="left"><code>modules&lt;Type&gt;</code></td><td align="left"><code>less&lt;Type&gt;</code></td><td align="left"></td></tr><tr><td align="left"><code>negate&lt;Type&gt;</code></td><td align="left"><code>less_equal&lt;Type&gt;</code></td><td align="left"></td></tr></tbody></table><p>函数对象的一个坑：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vector&lt;string *&gt; nameTable;<br><span class="hljs-built_in">sort</span>(nameTable.<span class="hljs-built_in">begin</span>(), nameTable.<span class="hljs-built_in">end</span>(), [](string *a, string *b)&#123;<span class="hljs-keyword">return</span> a &lt; b;&#125;);<span class="hljs-comment">//错误，nameTable中指针彼此之间没有关系，所以&lt;将产生未定义行为</span><br><span class="hljs-built_in">sort</span>(nameTable.<span class="hljs-built_in">begin</span>(), nameTable.<span class="hljs-built_in">end</span>(), less&lt;string*&gt;());<span class="hljs-comment">//正确，标准库规定指针的less是定义良好的</span><br></code></pre></div></td></tr></table></figure><p>后者可以用指针地址值来排序，标准库规定其函数对象对于指针同样适用，而手写的lambda就不行了。</p><p>C++语言中几种可调用的对象：函数、函数指针、lambda表达式、bind创建的对象以及重载了函数调用运算符的类。调用形式指明了调用返回的类型以及传递给调用的实参类型。不同的可调用对象可能具有相同的调用形式。</p><p>标准库<code>function</code>类型是一个模板，定义在头文件<em>functional</em>中，用来表示对象的调用形式。</p><table><thead><tr><th align="left">function的操作</th><th align="left"></th></tr></thead><tbody><tr><td align="left"><code>function&lt;T&gt; f;</code></td><td align="left">f是一个用来存储可调用对象的空function，这些可调用对象的调用形式应该与函数类型T相同（即T是<code>retType(args)</code>）</td></tr><tr><td align="left"><code>function&lt;T&gt; f(nullptr);</code></td><td align="left">显式地构造一个空function</td></tr><tr><td align="left"><code>function&lt;T&gt; f(obj);</code></td><td align="left">在f中存储可调用对象obj的副本</td></tr><tr><td align="left"><code>f</code></td><td align="left">将f作为条件：当f含有一个可调用对象时为真，否则为假</td></tr><tr><td align="left"><code>f(args)</code></td><td align="left">调用f中的对象，参数是args</td></tr><tr><td align="left">定义为<code>function&lt;T&gt;</code>的成员的类型</td><td align="left"></td></tr><tr><td align="left">result_type</td><td align="left">该function类型的可调用对象返回的类型</td></tr><tr><td align="left">argument_type</td><td align="left">T有一个或两个实参时定义的类型。如果T只有一个实参，</td></tr><tr><td align="left">first_argument_type</td><td align="left">则argument_type是该类型的同义词；如果T有两个实参，</td></tr><tr><td align="left">second_argument_type</td><td align="left">则first_argument_type和second_argument_type分别代表两个实参的类型</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">function&lt;<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)&gt; f1 = add;<span class="hljs-comment">//函数指针</span><br>function&lt;<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)&gt; f2 = <span class="hljs-built_in">devide</span>();<span class="hljs-comment">//函数对象类的对象</span><br>function&lt;<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)&gt; f3 = [](<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)&#123;<span class="hljs-keyword">return</span> i * j;&#125;;<span class="hljs-comment">//lambda</span><br><br>cout &lt;&lt; <span class="hljs-built_in">f1</span>(<span class="hljs-number">4</span>,<span class="hljs-number">2</span>) &lt;&lt; endl;<span class="hljs-comment">//6</span><br>cout &lt;&lt; <span class="hljs-built_in">f2</span>(<span class="hljs-number">4</span>,<span class="hljs-number">2</span>) &lt;&lt; endl;<span class="hljs-comment">//2</span><br>cout &lt;&lt; <span class="hljs-built_in">f3</span>(<span class="hljs-number">4</span>,<span class="hljs-number">2</span>) &lt;&lt; endl;<span class="hljs-comment">//8</span><br></code></pre></div></td></tr></table></figure><h2 id="重载、类型转换与运算符"><a href="#重载、类型转换与运算符" class="headerlink" title="重载、类型转换与运算符"></a>重载、类型转换与运算符</h2><p>转换构造函数和类型转换运算符共同定义了类类型转换（class-type conversion）。</p><h3 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h3><p>这是类的一种特殊成员函数，负责将一个类类型的值转为其他类型。<strong>它不能声明返回类型，形参列表也必须为空</strong>，形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br></code></pre></div></td></tr></table></figure><p>类型转换运算符可以面向除了void以外的任意类型进行定义。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmallInt</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SmallInt</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>): <span class="hljs-built_in">val</span>(i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt; <span class="hljs-number">255</span>)<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Bad SmallInt value&quot;</span>);<br>    &#125;   <br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> val; &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    std::<span class="hljs-keyword">size_t</span> val;<br>&#125;;<br><br><span class="hljs-comment">// 内置类型转换将double实参转换成int</span><br>SmallInt si = <span class="hljs-number">3.14</span>;     <span class="hljs-comment">// 调用SmallInt(int)构造函数</span><br><span class="hljs-comment">// SmallInt类型转换运算符将si转换成int</span><br>si + <span class="hljs-number">3.14</span>;     <span class="hljs-comment">// 内置类型转换将所得的int继续转换成double</span><br></code></pre></div></td></tr></table></figure><p>应该避免过度使用类型转换函数。如果在类类型和转换类型之间不存在明显的映射关系，则这样的类型转换可能具有误导性。</p><p>C++11引入了显示的类型转换运算符（explicit conversion operator）。和显式构造函数一样，编译器通常不会将显式类型转换运算符用于隐式类型转换。</p><p><strong>一旦给了类型转换运算符explicit标志</strong>，那么：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">SmallInt si = <span class="hljs-number">3</span>;<span class="hljs-comment">//正确，SmallInt的构造函数不是显式的</span><br>si + <span class="hljs-number">3</span>;<span class="hljs-comment">//错误：此处需要隐式的类型转换，但类型转换运算符是显式的</span><br><span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(si)+<span class="hljs-number">3</span>;<span class="hljs-comment">//正确，显式地请求类型转换</span><br></code></pre></div></td></tr></table></figure><p><strong>如果表达式被用作条件，则编译器会隐式地执行显式类型转换。</strong></p><ul><li><strong>if、while、do语句的条件部分。</strong></li><li><strong>for语句头的条件表达式。</strong></li><li><strong>条件运算符<code>? :</code>的条件表达式。</strong></li><li><strong>逻辑非运算符<code>!</code>、逻辑或运算符<code>||</code>、逻辑与运算符<code>&amp;&amp;</code>的运算对象。</strong></li></ul><p>在两种情况下可能产生多重转换路径：</p><ul><li>A类定义了一个接受B类对象的转换构造函数，同时B类定义了一个转换目标是A类的类型转换运算符。</li><li>类定义了多个类型转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起。</li></ul><p>可以通过显式调用类型转换运算符或转换构造函数解决二义性问题，但不能使用强制类型转换，因为强制类型转换本身也存在二义性。</p><p><strong>所以，请避免有二义性的类型转换。</strong></p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>effective C++ 第三版 第一章</title>
    <link href="/2021/10/27/c++/effect%201-4/"/>
    <url>/2021/10/27/c++/effect%201-4/</url>
    
    <content type="html"><![CDATA[<h1 id="守则01：把C-看做一个语言的集合，而不是单一的语言"><a href="#守则01：把C-看做一个语言的集合，而不是单一的语言" class="headerlink" title="守则01：把C++看做一个语言的集合，而不是单一的语言"></a><strong>守则01：把C++看做一个语言的集合，而不是单一的语言</strong></h1><blockquote><p>“C++ is a federation of languages”</p></blockquote><p>早期的C++只是叫”C with classes”，但发展到今天已经成为一个多重泛型编程语言(Multi-paradigm programming language)，它具有4种“子语言”:</p><ul><li>C</li><li>面向对象的C++</li><li>模板C++</li><li>STL</li></ul><p><strong>高效的C++编程守则取决于你所使用的“子语言”</strong></p><p>例如**:**</p><ul><li>在C中，一般使用<strong>值传递</strong> (Pass by value)</li><li>在**面向对象的C++和模板C++**中，使用常量引用传递 (Pass by const reference)更加高效</li><li>对于STL，因为迭代器是基于指针构造而成，直接使用<strong>值传递</strong>即可</li></ul><h1 id="守则02：尽量使用const-enum-inline-减少宏变量-define的使用"><a href="#守则02：尽量使用const-enum-inline-减少宏变量-define的使用" class="headerlink" title="守则02：尽量使用const, enum, inline, 减少宏变量#define的使用"></a><strong>守则02：尽量使用const, enum, inline, 减少宏变量#define的使用</strong></h1><p><strong>或者说，尽量多用编译器，少用预处理器</strong></p><blockquote><p>“Prefer the compiler to the preprocessor”</p></blockquote><blockquote><p>C++提供的编译预处理功能主要有以下三种：<br>　　① 宏定义<br>　　② 文件包含<br>　　③条件编译</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A 1.653   </span><br></code></pre></div></td></tr></table></figure><p>在上面这个语句中，字符串’A’是不会被编译器看到的，而编译器看到的是’1.653’，这就会导致在调试过程中，<strong>编译器的错误信息只显示’1.653’而不是’A’，让你不知从何下手</strong>。</p><p>解决方法：定义全局常量</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> A = <span class="hljs-number">1.653</span>;<br></code></pre></div></td></tr></table></figure><p>使用全局常量还有一个好处：预处理器只会把每次对’A’的引用变成’1.653’而不管其是否已经存在，这就导致多次引用’A’会造成多个重复对象出现在目标代码中(Object code)，造成资源浪费。</p><p><strong>当定义或声明全局变量时，常数指针和类的常数需要另加考虑</strong></p><ul><li><strong>对于指针</strong></li></ul><p>对于指针要把指针本身和它指向的数据都定义为const，例如</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-keyword">const</span> myWord = <span class="hljs-string">&quot;Hello&quot;</span>;<br></code></pre></div></td></tr></table></figure><p>(指向常量的常量指针)</p><p>在C++中可以更方便地使用std::string这样基于char*类型的推广，例如</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">const</span> std::string <span class="hljs-title">myWord</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br></code></pre></div></td></tr></table></figure><ul><li><strong>对于类的常数</strong></li></ul><p>声明为类的私有静态成员，这样既保证变量只能被这个类的对象接触到，又不会生成多个拷贝</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span>&#123;</span><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> numPlayer = <span class="hljs-number">5</span>;<br>........<br></code></pre></div></td></tr></table></figure><p><strong>注意</strong>，因为此处是类的成员声明范围内，所以上面只是变量的声明和初始化，而并非定义，因此如果想获取变量的地址，需要在别处另加定义。这个定义不能有任何赋值语句，因为在类内已经规定为const:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Player::numPlayer;<br></code></pre></div></td></tr></table></figure><h2 id="额外的补充：类内const推荐用static"><a href="#额外的补充：类内const推荐用static" class="headerlink" title="额外的补充：类内const推荐用static"></a><strong>额外的补充：类内const推荐用static</strong></h2><p>细节可见（4）</p><ul><li><p><strong>static的const</strong>对象赋初值与否编译器都能通过</p><p><img src="https://i.loli.net/2021/10/26/4p1wB3K5Msl9hf7.png" alt="image-20211026232229655"></p></li><li><p><strong>非static的const</strong>对象不允许赋初值</p><p>赋值会报错</p><blockquote><p>error: non-static const member ‘const int A::NUM_TURNS’, can’t use default assignment operator</p></blockquote><p>不赋值且无构造函数也会报错</p><blockquote><p>error: non-static const member ‘const int A::NUM_TURNS’, can’t use default assignment operator</p></blockquote><p><img src="https://i.loli.net/2021/10/26/RGD49qci21xNZhm.png" alt="image-20211026232615673"></p></li></ul><p><strong>对于#define的宏函数，尽量使用inline修饰的函数来代替#define</strong></p><p>C中经常会用形如<code>#define max(a,b) ((a) &gt; (b) ? (a) : (b))</code>这样的宏而不是定义成函数，一方面为了代码编写简洁而另一方面，又不增加函数调用的开销。</p><p>为什么要加()呢，因为怕运算符优先级问题引起歧义，这在C中已是路人皆知的技巧。</p><p>但实际上这种手法捉襟见肘，缺陷很多，比如:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>, b = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">max</span>(++a, b);<span class="hljs-comment">//a的值会增加2次</span><br><span class="hljs-built_in">max</span>(++a, b+<span class="hljs-number">10</span>);<span class="hljs-comment">//a的值只增加了1次</span><br></code></pre></div></td></tr></table></figure><p>虽然有点故意刁难的意思。</p><p>C++的inline完全规避了这种缺陷，可以改为inline函数：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">const</span> T&amp; <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; a, <span class="hljs-keyword">const</span> T&amp; b)</span></span>&#123; <span class="hljs-keyword">return</span> a &gt; b ? a : b; &#125;<br></code></pre></div></td></tr></table></figure><p>inline还有一个好处就是现代的编译器都比程序员聪明，你<strong>显式声明inline实际上最终不一定是inline，而有一些即使不声明inline也会被编译器优化成inline</strong>，这是C++的一大性能优化。</p><h1 id="守则03-尽可能使用const关键字"><a href="#守则03-尽可能使用const关键字" class="headerlink" title="守则03: 尽可能使用const关键字"></a><strong>守则03: 尽可能使用const关键字</strong></h1><blockquote><p>“Use const whenever possible”</p></blockquote><ul><li><strong>指针与const:</strong></li></ul><p>记忆法: const在星号左边修饰数据，const在星号右边修饰指针</p><p>以及如下两个语句的功能是相同的，不需要对此产生困惑:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* pw;             <span class="hljs-comment">//都表示指向常量char的指针</span><br><span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span>* pw;<br></code></pre></div></td></tr></table></figure><ul><li><strong>迭代器与const</strong></li></ul><p>迭代器在功能上相当于指向某类型T的指针 T*</p><p>区分 const iterator 和 const_iterator</p><p>因此，如果想定义某迭代器指向一个常数，使用const iterator是不可以的，这样只相当于定义一个迭代器为一个常量(T* const)，例如:（<strong>相当于指向常量的指针</strong>）</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> std::vector&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">//注意，此声明只表示迭代器本身是常量     </span><br>*it = <span class="hljs-number">10</span>;                                        <span class="hljs-comment">//编译通过，迭代器是常量，数据可以被修改</span><br>++it;                                            <span class="hljs-comment">//编译失败！因为const迭代器不允许改变！</span><br></code></pre></div></td></tr></table></figure><p>解决方法，使用const_iterator:（<strong>相当于指针本身为常量</strong>）</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-keyword">int</span>&gt;::const_iterator it = v.<span class="hljs-built_in">begin</span>();  <span class="hljs-comment">//使用了const_iterator类型</span><br>*it = <span class="hljs-number">10</span>;                                         <span class="hljs-comment">//编译失败，数据不允许被改变！</span><br>++it;     <br></code></pre></div></td></tr></table></figure><ul><li><strong>尽量使用const可以帮助调试</strong></li><li><strong>类的成员函数与const</strong></li><li><strong>成员函数的常量性(Constness)</strong></li><li><strong>在定义常量与非常量成员函数时，避免代码重复</strong></li></ul><p>既然两个版本的成员函数都要有，为什么又要避免重复?</p><p>其实在这里指的是函数的实现要避免重复。试想某函数既要检查边界范围，又要记录读取历史，还要检查数据完整性，这样的代码复制一遍，既不显得美观，又增加了代码维护的难度和编译时间。因此，我们<strong>可以使用非常量的函数来调用常量函数。</strong>(绝对不能是常量调用非常量版本)</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-keyword">size_t</span> pos) <span class="hljs-keyword">const</span>&#123;....&#125;<br><span class="hljs-keyword">char</span>&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-keyword">size_t</span> pos)&#123;<br>  <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">char</span>&amp;&gt;(                       <span class="hljs-comment">//const_cast去掉const关键字，并转换为char&amp;</span><br>      <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">const</span> Text&amp;&gt;(*<span class="hljs-keyword">this</span>)   <span class="hljs-comment">//给当前变量加上const关键字，才可以调用const操作符</span><br>      [position]);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>为了避免无限递归调用当前非常量的操作符，我们需要将(*this)转换为const Text&amp;类型才能保证安全调用const的操作符，最后去掉const关键字(const_cast)再将其返回，巧妙避免了代码的大段复制。</p><h1 id="守则04-在使用前保证对象是初始化的"><a href="#守则04-在使用前保证对象是初始化的" class="headerlink" title="守则04: 在使用前保证对象是初始化的"></a><strong>守则04: 在使用前保证对象是初始化的</strong></h1><ul><li><strong>自有类型(built-in type)的初始化</strong></li></ul><p>C++的自有类型继承于C，因此不能保证此类型的变量在定义时被初始化。使用未初始化的数据可能会导致程序不正常运作，因此在定义变量的时候，需要对其进行初始化。</p><ul><li><strong>类的初始化</strong></li></ul><p>对于用户自定义的类，我们需要构造函数(constructor)来完成此类的初始化</p><p>C++规定，在<strong>进入</strong>构造函数<strong>之前</strong>，如果用户没有规定初始化过程，C++将自动调用各成员对应类型的默认构造函数。</p><p>这样一来，此构造函数就相当于先调用了C++的默认构造函数，又做了一次赋值操作覆盖掉了先前的结果，造成了浪费。</p><p>解决方法：使用**初始化列表(initialization list)**，C++就不必额外调用默认构造函数了。</p><ul><li><p><strong>某些初始化是语法必要的</strong></p><p>例如<strong>在定义引用(reference)和常量(const)时，不将其初始化会导致编译器报错</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a;                <span class="hljs-comment">//报错，需要初始化！</span><br><span class="hljs-keyword">int</span>&amp; b;                     <span class="hljs-comment">//报错，需要初始化！</span><br><span class="hljs-comment">//现在对其进行初始化：</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">3</span>;            <span class="hljs-comment">//编译通过</span><br><span class="hljs-keyword">int</span> c = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">int</span>&amp; b = c;                 <span class="hljs-comment">//编译通过！</span><br></code></pre></div></td></tr></table></figure></li><li><p><strong>数据初始化的顺序</strong></p></li></ul><p>在继承关系中，<strong>基类(base class)总是先被初始化</strong>。</p><p>在同一类中，成员数据的==初始化顺序与其声明顺序是一致的==，<strong>而不是初始化列表的顺序</strong>。因此，为了代码一致性，要保证初始化列表的顺序与成员数据声明的顺序是一样的。</p><ul><li><strong>初始化非本地静态对象</strong></li></ul><p><strong>编译单元</strong>(translation unit): 可以让编译器生成代码的基本单元，一般一个源代码文件就是一个编译单元。</p><p><strong>非本地静态对象</strong>(non-local static object): 静态对象可以是在<strong>全局范围定义的变量</strong>，在名空间范围定义的变量，函数范围内定义为static的变量，类的范围内定义为static的变量，而<strong>除了函数中的静态对象是本地的，其他都是非本地的。</strong></p><p>此外注意，静态对象存在于程序的开始到结束，所以它不是基于堆(heap)或者栈(stack)的。初始化的静态对象存在于.data中，未初始化的则存在于.bss中。</p><p>回到问题，现有以下服务器代码:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span>&#123;</span>...&#125;;     <br><span class="hljs-keyword">extern</span> Server server;                 <span class="hljs-comment">//在全局范围声明外部对象server，供外部使用</span><br></code></pre></div></td></tr></table></figure><p>又有某客户端：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span>&#123;</span>...&#125;;<br>Client::<span class="hljs-built_in">Client</span>(...)&#123;<br>    number = server.number;<br>&#125;<br><br>Client client;                       <span class="hljs-comment">//在全局范围定义client对象，自动调用了Client类的构造函数</span><br></code></pre></div></td></tr></table></figure><p>以上问题在于，定义对象client自动调用了Client类的构造函数，此时需要读取对象server的数据，<strong>但全局变量的不可控性让我们不能保证对象server在此时被读取时是初始化的</strong>。试想如果还有对象client1, client2等等不同的用户读写，我们不能保证当前server的数据是我们想要的。</p><p><strong>解决方法:</strong> 将全局变量变为本地静态变量</p><p>使用一个函数，<strong>只用来定义一个本地静态变量并返回它的引用</strong>。==因为C++规定在本地范围(函数范围)内定义某静态对象时，当此函数被调用，该静态变量一定会被初始化。==(singleton模式)</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span>&#123;</span>...&#125;;<br><br><span class="hljs-function">Server&amp; <span class="hljs-title">server</span><span class="hljs-params">()</span></span>&#123;                         <span class="hljs-comment">//将直接的声明改为一个函数</span><br>    <span class="hljs-keyword">static</span> Server server;<br>    <span class="hljs-keyword">return</span> server;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span>&#123;</span>...&#125;;<br><br>Client::<span class="hljs-built_in">client</span>()&#123;                        <span class="hljs-comment">//客户端构造函数通过函数访问服务器数据</span><br>    number = <span class="hljs-built_in">server</span>().number;<br>&#125;<br><br><span class="hljs-function">Client&amp; <span class="hljs-title">client</span><span class="hljs-params">()</span></span>&#123;                        <span class="hljs-comment">//同样将客户端的声明改为一个函数</span><br>    <span class="hljs-keyword">static</span> Client client;<br>    <span class="hljs-keyword">return</span> client;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="第一章总结"><a href="#第一章总结" class="headerlink" title="第一章总结"></a>第一章总结</h1><ol><li><strong>视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL）</strong></li><li><strong>宁可以编译器替换预处理器（尽量以 <code>const</code>、<code>enum</code>、<code>inline</code> 替换 <code>#define</code>）</strong></li><li><strong>尽可能使用 const</strong></li><li><strong>确定对象被使用前已先被初始化（构造时赋值（copy 构造函数）比 default 构造后赋值（copy assignment）效率高）</strong></li></ol>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ primer 读书笔记 chapter 13 拷贝控制</title>
    <link href="/2021/10/25/c++/13.%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/"/>
    <url>/2021/10/25/c++/13.%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="C-primer-chapter-13"><a href="#C-primer-chapter-13" class="headerlink" title="C++ primer chapter 13"></a>C++ primer chapter 13</h1><h1 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h1><p>定义一个类，会显式或隐式指定此类型的对象拷贝、移动、赋值和销毁时做什么。类通过定义五种特殊的成员函数来控制这些操作，包括：<strong>拷贝构造函数</strong>（copy constructor）、<strong>拷贝赋值运算</strong>符（copy-assignment operator）、<strong>移动构造函数</strong>（move constructor）、移动赋值运算符（move-assignment operator）和<strong>析构函数</strong>（destructor）。</p><h2 id="拷贝、赋值与销毁"><a href="#拷贝、赋值与销毁" class="headerlink" title="拷贝、赋值与销毁"></a>拷贝、赋值与销毁</h2><p>移动语义是C++11新引入的</p><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>仅有一个参数为自身类类型引用的构造函数就是拷贝构造函数，形如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Foo</span>();<span class="hljs-comment">//默认构造函数</span><br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-keyword">const</span> Foo&amp;);<span class="hljs-comment">//拷贝构造函数</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>该参数==必须是引用类型==，一般是const引用。由于拷贝构造函数会在几种情况下<strong>隐式地调用</strong>，所以一般不是explicit。</p><p>如果自己不定义，编译器就会<strong>合成</strong>一个默认的、合成的拷贝构造函数会把参数成员逐个拷贝到正在创建的对象中（非static成员）。</p><p>成员的类型决定了拷贝的方式：类类型的成员会用它自己的拷贝构造函数来拷贝；内置类型则直接值拷贝。数组会逐个复制，如果数组成员是类类型，会逐个调用成员本身的拷贝构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sales_data</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Sales_data</span>(<span class="hljs-keyword">const</span> Sales_data&amp;);<br><span class="hljs-keyword">private</span>:<br>    std::string bookNo;<br>    <span class="hljs-keyword">int</span> units_sold = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">double</span> revenue = <span class="hljs-number">0.0</span>;<br>&#125;;<br><br><span class="hljs-comment">//与Sales_data的合成拷贝构造函数等价</span><br>Sales_data::<span class="hljs-built_in">Sales_data</span>(<span class="hljs-keyword">const</span> Sales_data &amp;orig) : <br><span class="hljs-built_in">bookNo</span>(orig.bookNo), <span class="hljs-comment">//使用string的拷贝构造函数</span><br><span class="hljs-built_in">units_sold</span>(orig.units_sold),<span class="hljs-comment">//拷贝orig.units_sold</span><br><span class="hljs-built_in">revenue</span>(orig.revenue)<span class="hljs-comment">//拷贝orig.revenue</span><br>    &#123;&#125;<span class="hljs-comment">//空函数体</span><br></code></pre></div></td></tr></table></figure><h4 id="拷贝初始化"><a href="#拷贝初始化" class="headerlink" title="拷贝初始化"></a>拷贝初始化</h4><p>拷贝初始化和直接初始化的差异：</p><p>直接初始化：==普通的函数匹配==</p><p>拷贝初始化：==类型转换==</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">dots</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;,&#x27;</span>)</span></span>;<span class="hljs-comment">//直接初始化</span><br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(dots)</span></span>;<span class="hljs-comment">//直接初始化</span><br>string s2 = dots;<span class="hljs-comment">//拷贝初始化</span><br>string null_book = <span class="hljs-string">&quot;9-999-99999-9&quot;</span>;<span class="hljs-comment">//拷贝初始化</span><br>string nines = <span class="hljs-built_in">string</span>(<span class="hljs-number">100</span>, <span class="hljs-string">&#x27;9&#x27;</span>);<span class="hljs-comment">//拷贝初始化</span><br></code></pre></div></td></tr></table></figure><p>拷贝初始化<strong>一般</strong>由拷贝构造函数完成，之所以说一般是因为移动语义的引入，导致如果类由移动构造函数时，拷贝初始化<strong>有时</strong>会使用移动构造函数而非拷贝构造函数。</p><p>拷贝初始化<strong>不仅在用=定义变量</strong>时发生，在下列情形也会发生：</p><ul><li>将一个对象作为实参传递给一个非引用类型的形参</li><li>从一个返回类型为非引用类型的函数返回一个对象</li><li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</li></ul><p>某些类类型还会对它们所分配的对象使用拷贝初始化。如初始化标准库容器或调用其insert或push成员时，容器会对其元素进行<strong>拷贝初始化</strong>。而emplace创建的元素都是<strong>直接初始化</strong>。</p><h4 id="参数和返回值"><a href="#参数和返回值" class="headerlink" title="参数和返回值"></a>参数和返回值</h4><p>拷贝构造函数被用来<strong>初始化非引用类类型参数</strong>，所以拷贝构造函数自身的参数必须是引用类型。不然的话，就二者矛盾而无限循环了。</p><blockquote><p>如果可以不是引用类型，为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数。（套娃）</p></blockquote><h4 id="拷贝初始化的限制"><a href="#拷贝初始化的限制" class="headerlink" title="拷贝初始化的限制"></a>拷贝初始化的限制</h4><p>构造函数为explicit类型，拷贝初始化只能是直接初始化</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">vector&lt;<span class="hljs-keyword">int</span>&gt; v1 <span class="hljs-number">10</span>;<span class="hljs-comment">//正确，直接初始化</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; v2 = <span class="hljs-number">10</span>;<span class="hljs-comment">//错误，vector接受大小的构造函数是explicit的</span><br><span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-built_in">f</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;));<span class="hljs-comment">//f的参数进行拷贝初始化</span><br><span class="hljs-built_in">f</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//错误，不能用一个explicit的构造函数拷贝一个实参</span><br><span class="hljs-built_in">f</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">10</span>));<span class="hljs-comment">//正确，从一个int直接构造一个临时vector</span><br></code></pre></div></td></tr></table></figure><p>对于explicit的构造函数，我们不能隐式的使用它（如第4行），必须显式的使用（如第5行）。</p><h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">Sales_data trans, accum;<br>trans = accum;<span class="hljs-comment">//使用Sales_data的拷贝赋值运算符</span><br></code></pre></div></td></tr></table></figure><p>如果类未定义，编译器会合成一个。</p><p>这个函数的定义涉及了重载运算符的概念，这里重载的是赋值运算符（ 即 = ）。</p><p>重载运算符本质上是函数，名字由operator关键字接要定义的运算符符号组成。所以，赋值运算符就<strong>对应operator=的函数</strong>。</p><p>重载运算符的参数表示运算符的运算对象，某些运算符包括赋值必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就<strong>绑定到隐式的this参数</strong>。对一个二元运算符，例如赋值运算符，右侧运算对象作为显式参数传递。</p><p>拷贝赋值运算符接受一个与其所在类相同类型的参数：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    Foo&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Foo&amp;);<span class="hljs-comment">//赋值运算符</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>为了与内置类型的赋值保持一直，赋值运算符通常<strong>返回一个指向其左侧运算对象的引用</strong>。另外，<strong>标准库通常要求保存在容器中的类型具有赋值运算符，且返回值是左侧运算符对象的引用</strong>。</p><p>编译器合成的拷贝赋值运算符类似拷贝构造，也是逐一进行成员拷贝（非static），类类型通过它自身的拷贝赋值运算符来完成，数组成员为类类型的，也会逐一调用自身的拷贝赋值运算符。最后，返回一个指向左侧运算对象的引用。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//该函数等价于合成的拷贝赋值运算符</span><br>Sales_data&amp; Sales_data::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Sales_data &amp;rhs)<br>&#123;<br>    bookNo = rhs.bookNo;<span class="hljs-comment">//调用string::operator=</span><br>    units_sold = rhs.units_sold;<span class="hljs-comment">//使用内置的int赋值</span><br>    revenue = rhs.revenue;<span class="hljs-comment">//使用内置的double赋值</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//返回左侧对象的引用</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>与构造执行的操作相反。</p><p>析构函数名字比构造函数多了一个**~**。没有返回值，也没有参数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Foo</span>();<span class="hljs-comment">//析构函数</span><br>    ...<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>析构函数不能被重载（因为它也不接受参数），是惟一的。</p><p>调用析构的时机：</p><ul><li>变量在<strong>离开作用域</strong>时被销毁</li><li>当一个对象被销毁时，其<strong>成员</strong>被销毁</li><li><strong>容器被销毁</strong>时（标准库容器或数组），其元素被销毁</li><li>动态分配的对象，当对指向它的指针应用<strong>delete</strong>时被销毁</li><li><strong>临时对象</strong>，当创建它的完整表达式结束时被销毁</li></ul><blockquote><p>隐式的销毁一个内置指针类型的成员不会delete它所指向的对象</p></blockquote><p>与普通指针不同,<strong>智能指针</strong>是<strong>类类型</strong>,所以<strong>具有析构函数</strong>,在析构时会<strong>被自动销毁</strong>.</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">&#123;<span class="hljs-comment">//新作用域</span><br>    <span class="hljs-comment">//p和p2指向动态分配对象</span><br>    Sales_data *p = <span class="hljs-keyword">new</span> Sales_data;<span class="hljs-comment">//p是一个内置指针</span><br>    <span class="hljs-keyword">auto</span> p2 = make_shared&lt;Sales_data&gt;();<span class="hljs-comment">//p2是一个shared_ptr</span><br>    <span class="hljs-function">Sales_data <span class="hljs-title">item</span><span class="hljs-params">(*p)</span></span>;<span class="hljs-comment">//拷贝构造函数将*p拷贝到item中</span><br>    vector&lt;Sales_data&gt; vec;<span class="hljs-comment">//局部对象</span><br>    vec.<span class="hljs-built_in">push_back</span>(*p2);<span class="hljs-comment">//拷贝p2指向的对象</span><br>    <span class="hljs-keyword">delete</span> p;<span class="hljs-comment">//对p指向的对象执行析构函数</span><br>&#125;<span class="hljs-comment">//退出局部作用域；对item、p2和vec调用析构函数</span><br><span class="hljs-comment">//销毁p2会递减其引用计数；如果引用计数变为0，则对象释放</span><br><span class="hljs-comment">//销毁vec会销毁它的元素</span><br></code></pre></div></td></tr></table></figure><blockquote><p>当指向一个对象的应用或指针离开作用域时,析构函数不会执行</p></blockquote><p>如果类未定义析构，则编译器会自动合成(合成析构函数)。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sales_data</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//成员会被自动销毁，除此之外不需要做其他事情</span><br>    ~<span class="hljs-built_in">Sales_data</span>()&#123;&#125;<br>    <span class="hljs-comment">//其他成员的定义</span><br>    ...<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>析构函数体（空）执行完毕后，成员会被自动销毁。本例中string的析构函数会被调用，释放bookNo的内存。<strong>析构函数体本身不直接销毁成员</strong>，它们是==<strong>在函数体之后隐含的析构阶段中被销毁</strong>==的。析构函数体只是析构过程的一部分。</p><h3 id="三五法则"><a href="#三五法则" class="headerlink" title="三五法则"></a>三五法则</h3><h4 id="需要析构函数的类也需要拷贝和赋值操作"><a href="#需要析构函数的类也需要拷贝和赋值操作" class="headerlink" title="需要析构函数的类也需要拷贝和赋值操作"></a>需要析构函数的类也需要拷贝和赋值操作</h4><p>因为析构函数需要去手工delete成员指针。这种情况下，<strong>编译器合成的拷贝构造和赋值运算符就会有问题，因为仅仅只是完成了浅拷贝</strong>，拷贝了成员指针的地址值（指向同一个对象），这可能引起问题。所以这种情况我们要自己写深拷贝代码。</p><h4 id="需要拷贝操作的类也需要赋值操作，反之亦然"><a href="#需要拷贝操作的类也需要赋值操作，反之亦然" class="headerlink" title="需要拷贝操作的类也需要赋值操作，反之亦然"></a>需要拷贝操作的类也需要赋值操作，反之亦然</h4><p>因为<strong>语义上拷贝构造和赋值操作是一致的</strong>，只是调用时机不同。提供了一个就说明需要特化某些操作，那么对应的另一个也要一致。但需要二者却不一定需要一个析构。</p><h3 id="default"><a href="#default" class="headerlink" title="=default"></a>=default</h3><p>=default可以显式地要求编译器生成合成的版本。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sales_data</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Sales_data</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Sales_data</span>(<span class="hljs-keyword">const</span> Sales_data&amp;) = <span class="hljs-keyword">default</span>;<br>    Sales_data &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Sales_data &amp;);<br>    ~<span class="hljs-built_in">Sales_data</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-comment">//其他成员</span><br>    ...<br>&#125;;<br>Sales_data &amp;Sales_data::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Sales_data&amp;) = <span class="hljs-keyword">default</span>;<br></code></pre></div></td></tr></table></figure><p>类内使用=default声明，合成的函数会隐式地声明为inline。</p><h3 id="delete"><a href="#delete" class="headerlink" title="=delete"></a>=delete</h3><p>有些情况我们希望阻止类的拷贝或赋值。比如iostream就阻止了拷贝，避免多个对象写入或读取相同的IO缓冲。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NoCopy</span>&#123;</span><br>    <span class="hljs-built_in">NoCopy</span>() = <span class="hljs-keyword">default</span>;<span class="hljs-comment">//合成的默认构造函数</span><br>    <span class="hljs-built_in">NoCopy</span>(<span class="hljs-keyword">const</span> NoCopy&amp;) = <span class="hljs-keyword">delete</span>;<span class="hljs-comment">//阻止拷贝</span><br>    NoCopy&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> NoCopy&amp;) = <span class="hljs-keyword">delete</span>;<span class="hljs-comment">//阻止赋值</span><br>    ~<span class="hljs-built_in">NoCopy</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>=delete通知编译器</strong>，不希望定义这些成员。</p><p>注意，<strong>析构函数不能删除，其他任何函数都可以指定=delete</strong>。虽然语法上允许析构函数指定=delete，但这样一来涉及到该类的对象都不能用，因为它无法销毁。</p><p>所以，记着析构函数不能加=delete这条软规则即可。</p><p>如果一个类有某个数据成员不能默认构造、拷贝、复制或销毁，那么对应的成员函数将被定义为删除的。</p><p>具有引用成员或无法默认构造的const成员的类，编译器不会合成默认构造函数。如果类有const成员，则它不能使用合成的拷贝赋值运算符（新值是不能给const对象的）。</p><p>在没有=delete之前，C++是通过private权限限制拷贝构造函数和拷贝赋值运算符来阻止拷贝的。这种方法有一个疏漏，就是友元函数和成员函数是可以进行拷贝的。</p><p>与 = default 不同， = delete 必须出现在函数第一次声明的时候，这个差异与这些声明的含义在逻辑上是吻合的，默认成员只影响为这个成员生成的代码，因此 = default 直到编译器生成代码时才需要。而对于被删除的函数，编译器需要一开始就直到，以便禁止试图使用它的操作。</p><blockquote><p>希望组织拷贝的类应该使用 = delete 来定义自己的拷贝构造函数和拷贝赋值运算符，而不是将他们声明为private的，如  <code>NoCopy(const NoCopy&amp;) = delete;</code></p></blockquote><h2 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a>拷贝控制和资源管理</h2><p>类一旦管理了类外资源，往往就需要自定义析构，根据三五法则也就意味着要自定义拷贝构造和拷贝赋值运算符。</p><p>而定义拷贝控制成员时，首先要确定类的拷贝语义，我们是让类的行为看起来像值还是像指针。</p><ul><li>如果是像值，比如string、标准库容器类等，它们的拷贝会使得副本对象和原对象完全独立，改变副本不会影响原对象。</li><li>如果是像指针，比如shared_ptr，那么拷贝的就是指针，指向的是同一个对象。</li><li>当然，也可以设置为不允许拷贝或赋值，此时既不像值也不像指针。</li></ul><h3 id="行为像值的类"><a href="#行为像值的类" class="headerlink" title="行为像值的类"></a>行为像值的类</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HasPtr</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">HasPtr</span>(<span class="hljs-keyword">const</span> std::string &amp;s = std::<span class="hljs-built_in">string</span>()):<span class="hljs-built_in">ps</span>(<span class="hljs-keyword">new</span> std::<span class="hljs-built_in">string</span>(s)), <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>)&#123;&#125;<br>  <span class="hljs-comment">//对ps指向的string，每个HasPtr对象都有自己的拷贝</span><br>  <span class="hljs-built_in">HasPtr</span>(<span class="hljs-keyword">const</span> HasPtr &amp;p):<span class="hljs-built_in">ps</span>(<span class="hljs-keyword">new</span> std::<span class="hljs-built_in">string</span>(*p.ps)), <span class="hljs-built_in">i</span>(p.i)&#123;&#125;<br>  HasPtr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> HasPtr &amp;);<br>  ~<span class="hljs-built_in">HasPtr</span>()&#123;<span class="hljs-keyword">delete</span> ps;&#125;<br><span class="hljs-keyword">private</span>:<br>  std::string *ps;<br>  <span class="hljs-keyword">int</span> i;<br>&#125;;<br><br>HasPtr&amp; HasPtr::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> HasPtr &amp;rhs)<br>&#123;<br>  <span class="hljs-comment">//这里一定要先new再delete，因为赋值操作赋值给自己是合法的</span><br>  <span class="hljs-comment">//如果赋值给自己，先delete意味着rhs.ps就丢了</span><br>    <span class="hljs-keyword">auto</span> newp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(*rhs.ps);<span class="hljs-comment">//拷贝底层string</span><br>  <span class="hljs-keyword">delete</span> ps;<span class="hljs-comment">//释放旧内存</span><br>  ps = newp;<span class="hljs-comment">//从右侧运算对象拷贝数据到本对象</span><br>  i = rhs.i;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//返回本对象</span><br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>赋值运算符要谨记一个好习惯，在销毁左侧运算对象资源之前先拷贝右侧运算对象资源。</p></blockquote><h3 id="行为像指针的类"><a href="#行为像指针的类" class="headerlink" title="行为像指针的类"></a>行为像指针的类</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HasPtr</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">//构造函数分配新的string和新的计数器，将计数器置为1</span><br>  <span class="hljs-built_in">HasPtr</span>(<span class="hljs-keyword">const</span> std::string &amp;s = std::<span class="hljs-built_in">string</span>()):<span class="hljs-built_in">ps</span>(<span class="hljs-keyword">new</span> std::<span class="hljs-built_in">string</span>(s)), <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">use</span>(<span class="hljs-keyword">new</span> std::<span class="hljs-built_in">size_t</span>(<span class="hljs-number">1</span>))&#123;&#125;<br>  <span class="hljs-comment">//拷贝构造函数拷贝所有3个数据成员，并递增计数器</span><br>  <span class="hljs-built_in">HasPtr</span>(<span class="hljs-keyword">const</span> HasPtr &amp;p):<span class="hljs-built_in">ps</span>(p.ps), <span class="hljs-built_in">i</span>(p.i), <span class="hljs-built_in">use</span>(p.use)&#123;++*use;&#125;<br>  HasPtr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> HasPtr&amp;);<br>  ~<span class="hljs-built_in">HasPtr</span>();<br><span class="hljs-keyword">private</span>:<br>  std::string *ps;<br>  <span class="hljs-keyword">int</span> i;<br>  std::<span class="hljs-keyword">size_t</span> *use;<span class="hljs-comment">//用来记录有多少个对象共享*ps的成员</span><br>&#125;;<br><br>HasPtr::~<span class="hljs-built_in">HasPtr</span>()<br>&#123;<br>    <span class="hljs-keyword">if</span>(--*use == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//如果引用计数变为0</span><br>        <span class="hljs-keyword">delete</span> ps;<span class="hljs-comment">//释放string内存</span><br>      <span class="hljs-keyword">delete</span> use;<span class="hljs-comment">//释放计数器内存</span><br>    &#125;<br>&#125;<br><br>HasPtr&amp; HasPtr::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> HasPtr &amp;rhs)<br>&#123;<br>    ++*rhs.use;<span class="hljs-comment">//递增右侧运算对象的引用计数</span><br>  <span class="hljs-keyword">if</span>(--*use == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//然后递减本对象的引用计数</span><br>        <span class="hljs-keyword">delete</span> ps;<span class="hljs-comment">//如果没有其他用户</span><br>      <span class="hljs-keyword">delete</span> use;<span class="hljs-comment">//释放本对象分配的成员</span><br>    &#125;<br>  ps = rhs.ps;<span class="hljs-comment">//将数据从rhs拷贝到本对象</span><br>  i = rhs.i;<br>  use = rhs.use;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//返回本对象</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>赋值运算符要考虑自赋值的情况，所以在左侧递减引用计数之前先递增右侧引用计数。</p><h2 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a>交换操作</h2><p>除了拷贝控制成员外，管理资源的类一般还定义一个swap函数。对与重排元素顺序的算法一起使用的类来说，swap非常重要，因为这些算法交换两个元素时会调用swap。</p><p>如果类自己定义了swap，算法就使用自定义版本，否则使用标准库定义的swap。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HasPtr</span>&#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(HasPtr&amp;, HasPtr&amp;)</span></span>;<br>  <span class="hljs-comment">//其他成员定义</span><br>  ...<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(HasPtr &amp;lhs, HasPtr &amp;rhs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> std::swap;<br>  <span class="hljs-built_in">swap</span>(lhs.ps, rhs.ps);<span class="hljs-comment">// 交换指针，而不是string数据</span><br>  <span class="hljs-built_in">swap</span>(lhs.i, rhs.i);<span class="hljs-comment">// 交换int成员</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>swap不是必要的，但对分配了资源的类来说，定义swap是一种很重要的优化手段。</p><p>swap定义的一个坑：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//Foo有类型为HasPtr的成员h</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Foo &amp;lhs, Foo &amp;rhs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//错误：这个函数使用了标准库版本的swap，而不是HasPtr版本</span><br>  std::<span class="hljs-built_in">swap</span>(lhs.h, rhs.h);<br>  <span class="hljs-comment">// 交换类型Foo的其他成员</span><br>&#125;<br><br><span class="hljs-comment">//正确的写法：</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Foo &amp;lhs, Foo &amp;rhs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> std::swap;<br>  <span class="hljs-built_in">swap</span>(lhs.h, rhs.h);<span class="hljs-comment">//使用HasPtr版本的swap</span><br>  <span class="hljs-comment">//交换类型Foo的其他成员</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这种未加限定的写法之所以可行，本质上是因为类型特定的swap版本匹配程度优于声明的std::swap版本。而对std::swap的声明可以使得在找不到类型特定版本时可以正确的找到std中的版本。</p><p>swap常用于赋值运算符，它可以一步到位完成拷贝并交换的技术。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//注意rhs是按值传递的，意味着HasPtr的拷贝构造函数将右侧运算对象中的string拷贝到rhs</span><br>HasPtr&amp; HasPtr::<span class="hljs-keyword">operator</span>=(HasPtr rhs)<br>&#123;<br>    <span class="hljs-comment">//交换左侧运算对象和局部变量rhs的内容</span><br>  <span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>, rhs);<span class="hljs-comment">//rhs现在指向本对象曾经使用的内存</span><br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//rhs被销毁，从而delete了rhs中的指针</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里的参数不是引用，右侧运算对象是值传递，所以rhs<strong>是右侧运算对象的副本</strong>。因此直接swap就一步到位了，自动销毁rhs时就自动销毁了原对象（执行析构）。</p><p><strong>使用拷贝和交换的赋值运算符天生异常安全，且能正确处理自赋值。</strong></p><h2 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h2><p>C++11引入了一个特性：可以移动而非拷贝对象。移动而非拷贝对象会大幅度提升性能。</p><p>旧版本即使在不必拷贝对象的情况下，也不得不拷贝，对象如果巨大，那么拷贝的代价是昂贵的。在旧版本的标准库中，容器所能保存的类型必须是可拷贝的。但在新标准中，可以用容器保存不可拷贝，但可移动的类型。</p><p>标准库容器、string和shared_ptr类既支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝。</p><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>为了支持移动操作，C++11引入了一个新的引用类型——右值引用(rvalue reference)。所谓右值引用就是必须绑定到右值的引用。通过&amp;&amp;来获得右值引用（左值引用是通过&amp;）。<strong>右值引用只能绑定到一个将要销毁的对象。</strong>因此，才得以自由地将一个右值引用的资源转移给另一个对象。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">int</span> &amp;r = i;<span class="hljs-comment">//正确：r引用i，r是左值引用</span><br><span class="hljs-keyword">int</span> &amp;&amp;rr = i;<span class="hljs-comment">//错误：右值引用不能绑定到左值上</span><br><span class="hljs-keyword">int</span> &amp;r2 = i*<span class="hljs-number">42</span>;<span class="hljs-comment">//错误：i*42是右值</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r3 = i*<span class="hljs-number">42</span>;<span class="hljs-comment">//正确：可以将一个const引用绑定到一个右值上</span><br><span class="hljs-keyword">int</span> &amp;&amp;rr2 = i*<span class="hljs-number">42</span>;<span class="hljs-comment">//正确：将rr2绑定到乘法结果上</span><br></code></pre></div></td></tr></table></figure><blockquote><p>最特别的就是const左值引用是可以绑定到右值的。</p></blockquote><p>变量表达式都是左值，所以不能将一个右值引用直接绑定到一个变量上，即使这个变量的类型是右值引用也不行。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> &amp;&amp;rr1 = <span class="hljs-number">42</span>;<span class="hljs-comment">//正确：字面常量是右值</span><br><span class="hljs-keyword">int</span> &amp;&amp;rr2 = rr1;<span class="hljs-comment">//错误：表达式rr1是左值</span><br></code></pre></div></td></tr></table></figure><p><strong>左值是持久的，右值是短暂的</strong>。</p><h3 id="标准库move函数"><a href="#标准库move函数" class="headerlink" title="标准库move函数"></a>标准库move函数</h3><p>虽然右值引用不能绑定到左值，但可以<strong>显式地将左值转换为对应的右值引用类型</strong>。调用<code>move</code>函数可以获得绑定在左值上的右值引用，此函数定义在头文件utility中。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> &amp;&amp;rr3 = std::<span class="hljs-built_in">move</span>(rr1);<span class="hljs-comment">//正确</span><br></code></pre></div></td></tr></table></figure><p>move告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。<strong>但使用move就意味着承诺：除了对rr1赋值或销毁它外，我们将不再使用它。</strong></p><p>可以销毁一个移后源对象，也可以赋予它新值，但不能使用移后源对象的值。</p><p><strong>调用move函数的代码应该使用std::move而非move，这样做可以避免潜在的名字冲突。</strong></p><h3 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h3><p>移动构造函数类似拷贝构造，第一个参数是该类类型的引用。不同于拷贝构造函数，这个引用参数在移动构造函数中是一个右值引用。其他任何额外参数都必须有默认值（与拷贝构造一致）。</p><p>除了完成资源移动，移动构造函数还要保证移后源对象处于一个状态：销毁它是无害的。移动之后，源对象必须不再指向被移动的资源，这些资源归新对象所有。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">StrVec::<span class="hljs-built_in">StrVec</span>(StrVec &amp;&amp;s) <span class="hljs-keyword">noexcept</span><span class="hljs-comment">//移动构造不应该抛任何异常</span><br>  <span class="hljs-comment">//成员初始化器接管s中资源</span><br>  : <span class="hljs-built_in">elements</span>(s.elements), <span class="hljs-built_in">first_free</span>(s.first_free), <span class="hljs-built_in">cap</span>(s.cap)<br>&#123;<br><span class="hljs-comment">//令s进入这样一个状态————对其运行析构函数是安全的</span><br>    s.elements = s.first_free = s.cap = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>移动构造函数不会分配任何新内存，它接管给定的StrVec的内存。接管之后，源对象的指针置nullptr。</p><p><strong>移动操作通常不分配任何资源，因此移动操作通常不抛出任何异常。而通过noexcept可以通知标准库构造函数不会抛出异常，如果不通知，那么标准库会认为移动构造函数可能会抛出异常，为此会做一些额外的工作。</strong></p><p>为什么要指出移动操作不抛出异常呢？因为标准库能对异常发生时其自身的行为提供保证，比如vector保证push_back时发生异常不会改变vector本身。</p><p>之所不异常时不改变vector，是因为拷贝构造函数中发生异常时，旧元素的内存空间是没有变化的，至于新内存空间尽管发生了异常，vector可以直接释放新分配的内存（尚未成功构造）并返回，这不会影响vector原有的元素。但移动语义就不同，如果移动了部分元素时发生了异常，那么这时源元素就已经被改变了，这就无法满足自身保持不变的要求了。</p><p>所以除非vector知道元素类型的移动构造函数不会抛异常，否则在重新分配内存时，它必须使用拷贝构造而不是移动构造。基于此，如果希望vector重新分配内存时可以使用自定义类型对象的移动操作而不是拷贝操作，那就要<strong>显式的声明我们的移动构造函数是noexcept的。</strong></p><h3 id="移动赋值运算符"><a href="#移动赋值运算符" class="headerlink" title="移动赋值运算符"></a>移动赋值运算符</h3><p>类似移动构造，如果不抛出任何异常，也要标记为noexcept。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">StrVec &amp;StrVec::<span class="hljs-keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="hljs-keyword">noexcept</span><br>&#123;<br>    <span class="hljs-comment">//直接检测自赋值</span><br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> != &amp;rhs)&#123;<br>        <span class="hljs-built_in">free</span>();<span class="hljs-comment">//释放已有元素</span><br>      elements = rhs.elements;/从rhs接管资源<br>        first_free = rhs.first_free;<br>      cap = rhs.cap;<br>      <span class="hljs-comment">//将rhs置于可析构状态</span><br>      rhs.elements = rhs.first_free = rhs.cap = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="合成的移动操作"><a href="#合成的移动操作" class="headerlink" title="合成的移动操作"></a>合成的移动操作</h3><p>如果自己不定义，编译器也会自动合成移动操作，但这和拷贝操作不同，它需要一些条件。</p><ul><li><p>如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会合成移动操作。</p></li><li><p><strong>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造和移动赋值运算符。</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//编译器为X和hasX合成移动操作</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X</span>&#123;</span><br>    <span class="hljs-keyword">int</span> i;<span class="hljs-comment">//内置类型可以移动</span><br>  std::string s;<span class="hljs-comment">//string定义了自己的移动操作</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hasX</span>&#123;</span><br>    X mem;<span class="hljs-comment">//X有合成的移动操作</span><br>&#125;;<br>X x, x2 = std::<span class="hljs-built_in">move</span>(x);<span class="hljs-comment">//使用合成的移动构造函数</span><br>hasX hx, hx2 = std::<span class="hljs-built_in">move</span>(hx);<span class="hljs-comment">//使用合成的移动构造函数</span><br></code></pre></div></td></tr></table></figure><p>与拷贝操作不同，移动操作永远不会被隐式定义为删除的函数。但如果显式地要求编译器生成=default的移动操作，且编译器不能移动全部成员，则移动操作会被定义为删除的函数。</p><p>定义了移动构造或移动赋值的类也必须定义自己的拷贝操作，否则拷贝操作默认被定义为删除的。</p><p>如果类既有移动构造，也有拷贝构造，那么编译器使用普通的函数匹配规则来确定使用哪个构造函数。赋值也类似。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">StrVec v1, v2;<br>v1 = v2;<span class="hljs-comment">//v2是左值，使用拷贝赋值</span><br><span class="hljs-function">StrVec <span class="hljs-title">getVec</span><span class="hljs-params">(istream &amp;s)</span></span>;<span class="hljs-comment">//getVec返回一个右值</span><br>v2 = <span class="hljs-built_in">getVec</span>(cin);<span class="hljs-comment">//getVec(cin)是一个右值，使用移动赋值</span><br></code></pre></div></td></tr></table></figure><p>如果类有拷贝构造，但没有移动构造，函数匹配规则会保证该类型的对象会被拷贝：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Foo</span>() = <span class="hljs-keyword">default</span>;<br>  <span class="hljs-built_in">Foo</span>(<span class="hljs-keyword">const</span> Foo&amp;);<br>  ...<br>&#125;;<br>Foo x;<br><span class="hljs-function">Foo <span class="hljs-title">y</span><span class="hljs-params">(x)</span></span>;<span class="hljs-comment">//拷贝构造函数，x是左值</span><br><span class="hljs-function">Foo <span class="hljs-title">z</span><span class="hljs-params">(std::move(x))</span></span>;<span class="hljs-comment">//拷贝构造函数，因为未定义移动构造函数</span><br></code></pre></div></td></tr></table></figure><p>在未定义移动构造的情境下，<code>Foo z(std::move(x)</code>之所以可行，是因为我们可以把<code>Foo&amp;&amp;</code>转换为一个<code>const Foo&amp;</code>。</p></li></ul><p>五个拷贝控制成员应该当成一个整体来对待。如果一个类需要任何一个拷贝操作，它就应该定义所有五个操作。</p><p>C++11标准库定义了移动迭代器（move iterator）适配器。一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。移动迭代器的解引用运算符返回一个右值引用。调用<code>make_move_iterator</code>函数能将一个普通迭代器转换成移动迭代器。原迭代器的所有其他操作在移动迭代器中都照常工作。</p><p><strong>最好不要在移动构造函数和移动赋值运算符这些类实现代码之外的地方随意使用move操作。std::move是危险的。</strong></p><h3 id="右值引用和成员函数"><a href="#右值引用和成员函数" class="headerlink" title="右值引用和成员函数"></a>右值引用和成员函数</h3><p>在非static成员函数的形参列表后面添加引用限定符（reference qualifier）可以指定this的左值/右值属性。引用限定符可以是<code>&amp;</code>或者<code>&amp;&amp;</code>，分别表示this可以指向一个左值或右值对象。引用限定符必须同时出现在函数的声明和定义中。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    Foo &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Foo&amp;) &amp;; <span class="hljs-comment">// 只能向可修改的左值赋值</span><br>    <span class="hljs-comment">// 其他成员</span><br>&#125;;<br><br>Foo &amp;Foo::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Foo &amp;rhs) &amp;<br>&#123;<br>    <span class="hljs-comment">// 执行将rhs赋予本对象所需的工作</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>一个非static成员函数可以同时使用const和引用限定符，此时引用限定符跟在const限定符之后。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Foo <span class="hljs-title">someMem</span><span class="hljs-params">()</span> &amp; <span class="hljs-keyword">const</span></span>;      <span class="hljs-comment">// error</span><br>    <span class="hljs-function">Foo <span class="hljs-title">anotherMem</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> &amp;</span>;   <span class="hljs-comment">// ok</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>引用限定符也可以区分成员函数的重载版本。</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Foo <span class="hljs-title">sorted</span><span class="hljs-params">()</span> &amp;&amp;</span>;        <span class="hljs-comment">// 可用于可改变的右值</span><br>    <span class="hljs-function">Foo <span class="hljs-title">sorted</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> &amp;</span>;   <span class="hljs-comment">// 可用于任何类型的Foo</span><br>  <span class="hljs-comment">//Foo其他成员</span><br><span class="hljs-keyword">private</span>:<br>  vector&lt;<span class="hljs-keyword">int</span>&gt; data;<br>&#125;;<br><br><span class="hljs-comment">//本对象为右值，因此可以原址排序</span><br><span class="hljs-function">Foo <span class="hljs-title">Foo::sorted</span><span class="hljs-params">()</span> &amp;&amp;</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">sort</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>());<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125; <br><span class="hljs-comment">//本对象是const或是一个左值，哪种情况我们都不能对其进行原址排序</span><br><span class="hljs-function">Foo <span class="hljs-title">Foo::sorted</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> &amp;</span>&#123;<br>    <span class="hljs-function">Foo <span class="hljs-title">ret</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>  <span class="hljs-built_in">sort</span>(ret.data.<span class="hljs-built_in">begin</span>(), ret.data.<span class="hljs-built_in">end</span>());<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-built_in">retVal</span>().<span class="hljs-built_in">sorted</span>();<span class="hljs-comment">//retVal()是右值，调用Foo::sorted() &amp;&amp;</span><br><span class="hljs-built_in">retFoo</span>().<span class="hljs-built_in">sorted</span>();<span class="hljs-comment">//retFoo()是左值，调用Foo::sorted() const &amp;</span><br></code></pre></div></td></tr></table></figure><p>如果定了两个或两个以上具有相同名字和相同参数列表的成员函数，<strong>要么都加引用限定符，要么都不加</strong>，这一点不受const this的影响。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Foo <span class="hljs-title">sorted</span><span class="hljs-params">()</span> &amp;&amp;</span>;<br>    <span class="hljs-function">Foo <span class="hljs-title">sorted</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;    <span class="hljs-comment">// 错误：必须加上引用限定符</span><br>    <span class="hljs-comment">// Comp是函数类型的类型别名</span><br>    <span class="hljs-comment">// 此函数类型可以用来比较int值</span><br>    <span class="hljs-keyword">using</span> Comp = <span class="hljs-built_in"><span class="hljs-keyword">bool</span></span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp;, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp;);<br>    <span class="hljs-function">Foo <span class="hljs-title">sorted</span><span class="hljs-params">(Comp*)</span></span>;  <span class="hljs-comment">// 正确：不同的参数列表</span><br>  <span class="hljs-function">Foo <span class="hljs-title">sorted</span><span class="hljs-params">(Comp*)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-comment">//正确：两个版本都没有引用限定符</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ primer 读书笔记 chapter 15 面向对象程序设计</title>
    <link href="/2021/10/24/c++/15.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2021/10/24/c++/15.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="C-Primer-chapter-15"><a href="#C-Primer-chapter-15" class="headerlink" title="C++ Primer  chapter 15"></a>C++ Primer  chapter 15</h1><h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1><h2 id="OOP概述"><a href="#OOP概述" class="headerlink" title="OOP概述"></a>OOP概述</h2><p><strong>OOP三大核心思想：抽象、继承和多态（动态绑定）。</strong></p><ul><li><strong>数据抽象将类的接口与实现分离</strong></li><li><strong>继承可以定义相似的类型并对其相似关系建模</strong></li><li><strong>多态则在一定程度上忽略相似类型的区别，实现统一方式来使用一组对象</strong></li></ul><p>对继承来说，层次关系的根部类叫基类，其他类可以直接或间接从基类继承而来，它们叫派生类。基类负责定义在层次关系中所有类共同拥有的成员，派生类定义各自特有的成员。</p><p>而一旦有了继承，也就可以应用多态。想要解释继承和多态，再多的语言也是苍白无力。不如从一个例子说起：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Quote</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">std::string <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span> n)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-comment">//定义为虚函数，实现多态</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bulk_quote</span> :</span> <span class="hljs-keyword">public</span> Quote&#123;<span class="hljs-comment">// Bulk_quote继承了Quote</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>Quote为基类，Bulk_quote为Quote的派生类（子类）。派生类通过类派生列表(class derivation list)明确指出从哪个(哪些)基类继承而来。其中关键字public表示公有继承，先不解释其作用。</p><p>基类的函数net_price前面加上virtual表示其是一个虚函数，虚函数的作用是为了实现多态。一旦基类定义了虚函数，那么派生的子类就可以通过重新定义来覆盖基类的虚函数实现。派生类可以省略virtual关键字，尽管子类中不声明virtual，覆盖函数定义仍然还是虚函数。(<strong>但是还是应该带上virtual,这样间接继承就免得去看基类的实现</strong>)</p><p>C++11标准允许派生类<strong>显式地注明</strong>它将使用哪个成员函数改写基类的虚函数，这就是上例中override关键字的作用。==（好处是万一同名参数形参列表不同将会overrid失败，编译器将会报错帮助你发现）==</p><p>virtual实现的动态绑定怎么用呢？<a href="https://www.bilibili.com/video/BV1dE41167hJ?p=22&share_source=copy_web"><strong>（翁恺c++ p23-24）</strong></a></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">print_total</span><span class="hljs-params">(ostream &amp;os, <span class="hljs-keyword">const</span> Quote &amp;item, <span class="hljs-keyword">size_t</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//如果item是Quote对象，调用Quote::net_price</span><br>  <span class="hljs-comment">//如果item是Bulk_quote对象，调用Bulk_quote::net_price</span><br>    <span class="hljs-keyword">double</span> ret = item.<span class="hljs-built_in">net_price</span>(n);<br>  os &lt;&lt; <span class="hljs-string">&quot;ISBN: &quot;</span> &lt;&lt; item.<span class="hljs-built_in">isbn</span>()<span class="hljs-comment">//调用Quote::isbn</span><br>      &lt;&lt; <span class="hljs-string">&quot; # sold: &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; total due: &quot;</span> &lt;&lt; ret &lt;&lt; endl;<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-built_in">print_total</span>(cout, basic, <span class="hljs-number">20</span>);<span class="hljs-comment">//basic是Quote对象</span><br><span class="hljs-built_in">print_total</span>(cout, bulk, <span class="hljs-number">20</span>);<span class="hljs-comment">//bulk是Bulk_quote对象</span><br></code></pre></div></td></tr></table></figure><p>可以看到尽管形参是一个const Quote对象的引用，但可以传入一个派生类对象作为实参，而一旦如此，对形参调用类成员函数时，就会进行动态绑定，即派生类调用派生类重新定义的虚函数体，基类调用基类定义的虚函数体。</p><blockquote><p>如果net_price不是虚函数，即使子类中重新定义了一模一样的net_price，对该例来说，无论传给item的对象是子类还是派生类，最终调用的都是父类的net_price。所以说<strong>虚函数才支持动态绑定</strong>。深入一点说，拥有虚函数的类对象都有虚表，忽略基类型别动态绑定到子类成员函数的过程实际上是依赖于类对象的虚表指针，因为无论对象被看成基类还是子类，它的虚表指针始终是指向正确的解绑函数的。</p></blockquote><p>所以，多态的存在可以让我们在程序设计上使用父类指针（或引用）指向子类对象，也就是所谓的“一定程度上忽略相似类型的区别，实现统一方式来使用一组对象”。</p><h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Quote</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Quote</span>() = <span class="hljs-keyword">default</span>;<span class="hljs-comment">//合成默认构造函数</span><br>  <span class="hljs-built_in">Quote</span>(<span class="hljs-keyword">const</span> std::string &amp;book, <span class="hljs-keyword">double</span> sales_price):<span class="hljs-built_in">bookNo</span>(book), <span class="hljs-built_in">price</span>(sales_price)&#123;&#125;<br>  <span class="hljs-function">std::string <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> bookNo;&#125;<br>  <span class="hljs-comment">//返回给定数量的书籍的销售总额</span><br>  <span class="hljs-comment">//派生类负责改写并使用不同的折扣计算算法</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span> n)</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">    </span>&#123;<span class="hljs-keyword">return</span> n * price;&#125;<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Quote</span>() = <span class="hljs-keyword">default</span>;<span class="hljs-comment">//对析构函数进行动态绑定</span><br><span class="hljs-keyword">private</span>:<br>  std::string bookNo;<span class="hljs-comment">//书籍的ISBN编号</span><br><span class="hljs-keyword">protected</span>:<br>  <span class="hljs-keyword">double</span> price = <span class="hljs-number">0.0</span>;<span class="hljs-comment">//代表普通状态下不打折的价格</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>为什么析构函数要定义成虚函数呢？因为我们往往使用多态时，会使用父类指针指向子类对象，而后续可能会delete父类指针，如果析构函数不是虚函数，那么delete一个子类对象不会调用子类对象的析构，而是直接调用父类的析构了，这与预期不符。</strong></p><p>所以，==拥有虚函数的父类的析构函数往往也是虚函数==（因为多态需要虚函数来实现）。</p><h3 id="成员函数与继承"><a href="#成员函数与继承" class="headerlink" title="成员函数与继承"></a>成员函数与继承</h3><p>派生类可以继承基类的成员，基类的成员函数有两种：希望派生类进行覆盖而被声明为virtual的虚函数、希望派生类直接使用的函数。</p><p>任何构造函数之外的非静态函数都可以是虚函数。==构造函数不能virtual！==</p><blockquote><p>构造函数为什么不能virtual呢？很简单，因为构造子类理应递归的调用父类的构造器，如果父类构造器被virtual化了，那么子类就无法调用到父类的构造器了。</p></blockquote><p>普通的成员函数的解析过程发生在编译阶段，虚函数的解析过程发生在运行时(从虚表(virtual table)取函数地址)。</p><p>所以有虚函数的类会大一点，在<strong>类的开头有一个指针指向virtual table。</strong></p><p><img src="https://i.loli.net/2021/10/24/qG3HOzX9Q4kTyhs.png" alt="image-20211024153527689"></p><h3 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h3><p>派生类可以继承基类的成员，但这并不意味着派生类内部可以随意使用基类的成员。在public继承条件下，如果父类的成员是private权限，那么派生类内部无法访问，如果父类的成员是public权限，那么派生类内部可以访问。</p><p>那么，有的时候我们希望父类的一些成员也可以被子类访问，但不希望被其他外部非亲非戚的访问，private和public就都不好用了，于是，就有了protected权限。protected修饰的成员意味着派生类可以访问，外部不行。</p><p>继续定义派生类：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bulk_quote</span> :</span> <span class="hljs-keyword">public</span> Quote&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Bulk_quote</span>() = <span class="hljs-keyword">default</span>;<br>  <span class="hljs-built_in">Bulk_quote</span>(<span class="hljs-keyword">const</span> std::string &amp;, <span class="hljs-keyword">double</span>, std::<span class="hljs-keyword">size_t</span>, <span class="hljs-keyword">double</span>);<br>  <span class="hljs-comment">//覆盖基类的虚函数，隐式virtual</span><br>  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-keyword">private</span>:<br>  std::<span class="hljs-keyword">size_t</span> min_qty = <span class="hljs-number">0</span>;<span class="hljs-comment">//自己的成员，折扣政策下最低购买量</span><br>  <span class="hljs-keyword">double</span> discount = <span class="hljs-number">0.0</span>;<span class="hljs-comment">//折扣额</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>派生类对象包含多个组成部分：含有派生类自己定义的(非静态)成员的子对象，以及一个与该类继承的基类对应的子对象，如果有多个基类，那么也就有对应多个子对象。</p><p>Bulk_quote对象</p><table><thead><tr><th align="center">变量名</th><th align="center">来源</th></tr></thead><tbody><tr><td align="center">bookNo</td><td align="center">从Quote继承</td></tr><tr><td align="center">price</td><td align="center">从Quote继承</td></tr><tr><td align="center">min_qty</td><td align="center">Bulk_quote自定义的成员</td></tr><tr><td align="center">discount</td><td align="center">Bulk_quote自定义的成员</td></tr></tbody></table><p>之所以能完成继承，<strong>本质上是因为派生类对象中拥有基类对象</strong>。</p><p>因为派生类对象中含有与其基类对应的组成部分，所以可以把派生类对象当成基类对象使用，也能将基类指针或引用绑定到派生类对象的基类部分上。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">Quote item;<span class="hljs-comment">//基类对象</span><br>Bulk_quote bulk;<span class="hljs-comment">//派生类对象</span><br>Quote *p = &amp;item;<span class="hljs-comment">//p指向Quote对象</span><br>p = &amp;bulk;<span class="hljs-comment">//p指向bulk的Quote部分</span><br>Quote &amp;r = bulk;<span class="hljs-comment">//r绑定到bulk的Quote部分</span><br></code></pre></div></td></tr></table></figure><p>这种称为派生类到基类的类型转换（upcasting，向上造型），编译器会隐式执行派生类到基类的转换。</p><h3 id="派生类构造函数"><a href="#派生类构造函数" class="headerlink" title="派生类构造函数"></a>派生类构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">Bulk_quote</span>(<span class="hljs-keyword">const</span> std::string &amp;book, <span class="hljs-keyword">double</span> p, std::<span class="hljs-keyword">size_t</span> qty, <span class="hljs-keyword">double</span> disc) : <span class="hljs-built_in">Quote</span>(book, p), <span class="hljs-built_in">min_qty</span>(qty), <span class="hljs-built_in">discount</span>(disc)&#123;&#125;<br></code></pre></div></td></tr></table></figure><p>初始化列表中调用了Quote的构造函数，用来负责初始化基类部分。</p><p>除非特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。如果想使用其他的基类构造函数，我们需要以类名加圆括号内的实参列表的形式为构造函数提供初始值。</p><p>派生类的构造器总是先初始化基类部分，再按声明顺序依次初始化派生类成员。</p><h3 id="派生类使用基类的成员"><a href="#派生类使用基类的成员" class="headerlink" title="派生类使用基类的成员"></a>派生类使用基类的成员</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Bulk_quote::net_price</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> cnt)</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(cnt &gt;= min_qty)<br>      <span class="hljs-keyword">return</span> cnt * (<span class="hljs-number">1</span> - discount) * price;<br>  <span class="hljs-keyword">else</span><br>      <span class="hljs-keyword">return</span> cnt * price;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="继承与静态成员"><a href="#继承与静态成员" class="headerlink" title="继承与静态成员"></a>继承与静态成员</h3><p>如果基类定义了静态成员，则整个继承体系中只存在该成员的唯一定义。<strong>不论基类中派生出多少个派生类，对每个静态成员来说都只存在唯一的一个实例。</strong></p><blockquote><p>因为静态成员实际上是全局的，当然是单例。只是语法上为了关系结构，把它放在类中定义。</p></blockquote><p>另外，静态成员也遵循访问控制权限。</p><p>派生类的声明不能包含派生列表，直接<code>class Bulk_quote;</code>就行了。</p><p>C++11可以定义一种不允许其他类继承的类。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoDerived</span> <span class="hljs-keyword">final</span>&#123;</span><span class="hljs-comment">/* */</span>&#125;;<span class="hljs-comment">//NoDerived不能做基类</span><br></code></pre></div></td></tr></table></figure><h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><p>通常当把引用或指针绑定到一个对象时，引用或指针的类型得和对象的类型一致，或者对象类型含有一个可接受的const类型转换规则。但对于继承类来说还有一个特例，那就是可以把基类的指针或引用绑定到派生类对象上，为了实现多态。</p><blockquote><p>智能指针也支持这一类型转换，所以可以将派生类对象指针存在基类智能指针之内。</p></blockquote><ul><li>从派生类向基类的类型转换只对指针或引用类型有效。</li><li>基类向派生类不存在隐式类型转换。</li><li>派生类向基类的类型转换也可能会由于访问受限而变得不可行。</li></ul><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>对虚函数的调用在运行时被解析。派生类覆盖虚函数定义需要保证型别完全一致。</p><blockquote><p>有一个例外就是虚函数在基类中如果返回基类指针或引用时，派生类中是可以返回派生类的指针或引用的，这是唯一的一个可行的型别不一致的地方，但这种不一致也有前提条件，即派生类到基类的类型转换是可访问的（不能访问受限）。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span>&#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-keyword">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-comment">//这个例子可以看出override的用处，可以直观的找出错误，没有override编译器会曲解原本的意图</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">D1</span> :</span> B&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span>;<span class="hljs-comment">//正确，f1与基类型别一致</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-keyword">override</span></span>;<span class="hljs-comment">//错误，B没有该函数</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<span class="hljs-comment">//错误，f3不是虚函数</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f4</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<span class="hljs-comment">//错误，B没有f4</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">D2</span> :</span> B&#123;<br>  <span class="hljs-comment">//继承B的f2(),f3(),覆盖f1(int)</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">final</span></span>;<span class="hljs-comment">//不允许后续的其他类覆盖f1(int)</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">D3</span> :</span> D2&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//正确：覆盖从间接基类B继承而来的f2()</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-comment">//错误，D2已经声明f1为final了</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>虚函数也可以声明final来阻止派生类覆盖。</p><h3 id="回避虚函数的机制"><a href="#回避虚函数的机制" class="headerlink" title="回避虚函数的机制"></a>回避虚函数的机制</h3><p>有时候不希望动态绑定，而是调用某个虚函数的特定版本，可以通过作用域运算符来实现：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> undiscounted = baseP-&gt;Quote::<span class="hljs-built_in">net_price</span>(<span class="hljs-number">42</span>);<br></code></pre></div></td></tr></table></figure><p>无论baseP实际上是啥类型，最后调用的都是Quote的net_price，这是编译时期确定的。</p><p>通常只有成员函数(或友元)的代码才需要这种hack技巧。比如派生类虚函数想要调用父类的虚函数版本。</p><h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p>有时候父类指向声明一个函数接口，不想实际定义，希望由派生类来定义。C++允许这种设计，可以在virtual的基础上定义纯虚函数：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Disc_quote</span> :</span> <span class="hljs-keyword">public</span> Quote&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Disc_quote</span>() = <span class="hljs-keyword">default</span>;<br>  <span class="hljs-built_in">Disc_quote</span>(<span class="hljs-keyword">const</span> std::string &amp;book, <span class="hljs-keyword">double</span> price, std:<span class="hljs-keyword">size_t</span> qty, <span class="hljs-keyword">double</span> disc):<span class="hljs-built_in">Quote</span>(book, price), <span class="hljs-built_in">quantity</span>(qty), <span class="hljs-built_in">discount</span>(disc) &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span>)</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-comment">//=0表示纯虚函数</span><br><span class="hljs-keyword">protected</span>:<br>  std::<span class="hljs-keyword">size_t</span> quantity = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">double</span> discount = <span class="hljs-number">0.0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>纯虚函数无需定义，=0只能出现在类内部的虚函数声明语句处。</p><p>纯虚函数也可以定义，但必须在类外部定义，大部分情况不会定义，因为这与我们的使用意图相悖。</p><p>==类只要含有纯虚函数，就是一个抽象基类==，抽象基类负责定义接口，后续的其他类来覆盖接口。<strong>不能创建抽象基类的对象，抽象基类需要派生类去继承。</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bulk_quote</span> :</span> <span class="hljs-keyword">public</span> Disc_quote&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Bulk_quote</span>() = <span class="hljs-keyword">default</span>;<br>  <span class="hljs-built_in">Bulk_quote</span>(<span class="hljs-keyword">const</span> std::string &amp;book, <span class="hljs-keyword">double</span> price, std::<span class="hljs-keyword">size_t</span> qty, <span class="hljs-keyword">double</span> disc):<span class="hljs-built_in">Disc_quote</span>(book, price, qty, disc)&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>直接基类是Disc_quote，间接基类是Quote。各个类控制自己的构造器，构造器会递归下去，先执行根基类构造器，最后执行自身的构造。继承链的构造器形成了层的概念。</p><h2 id="访问控制与继承-1"><a href="#访问控制与继承-1" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><p>protected的一个坑：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span>&#123;</span><br><span class="hljs-keyword">protected</span>:<br>  <span class="hljs-keyword">int</span> prot_mem;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sneaky</span> :</span> <span class="hljs-keyword">public</span> Base&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clobber</span><span class="hljs-params">(Sneaky&amp;)</span></span>;<span class="hljs-comment">//可以访问Sneaky::prot_mem</span><br>  <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clobber</span><span class="hljs-params">(Base&amp;)</span></span>;<span class="hljs-comment">//不能访问Base::prot_mem</span><br>  <span class="hljs-keyword">int</span> j;<span class="hljs-comment">//j默认是private</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clobber</span><span class="hljs-params">(Sneaky &amp;s)</span></span>&#123;s.j = s.prot_mem = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//clobber可以访问Sneaky的private和protected成员</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clobber</span><span class="hljs-params">(Base &amp;b)</span></span>&#123;b.prot_mem = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//clobber不能访问Base的protected成员</span><br></code></pre></div></td></tr></table></figure><p>之所以有这种限制，是因为如果第二个用法合法的话，那么就可以通过定义一个形如Sneaky的新类来规避掉protected提供的访问保护了。</p><p>所以，<u>派生类的成员和友元</u>只能访问<strong>派生类对象中的基类部分</strong>的受保护成员，而<u>不能访问</u><strong>普通的基类对象中的任何成员</strong>。</p><h3 id="public、private和protected"><a href="#public、private和protected" class="headerlink" title="public、private和protected"></a>public、private和protected</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pub_mem</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">protected</span>:</span><br><span class="hljs-function">  int prot_mem;</span><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">char</span> priv_mem;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pub_Derv</span> :</span> <span class="hljs-keyword">public</span> Base&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> prot_mem;&#125;<span class="hljs-comment">//正确：派生类能访问protected成员</span><br>  <span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> priv_mem;&#125;<span class="hljs-comment">//错误：private成员对于派生类来说是不可访问的</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Priv_Derv</span> :</span> <span class="hljs-keyword">private</span> Base&#123;<br>    <span class="hljs-comment">//private不影响派生类的访问权限</span><br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>&#123;<span class="hljs-keyword">return</span> prot_mem;&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Prot_Derv</span> :</span> <span class="hljs-keyword">protected</span> Base&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>&#123;<span class="hljs-keyword">return</span> prot_mem;&#125;<span class="hljs-comment">//依然是protected</span><br>&#125;<br>Pub_Derv d1;<span class="hljs-comment">//继承自Base的成员遵循原有的访问说明符</span><br>Priv_Derv d2;<span class="hljs-comment">//继承自Base的成员无论此前是什么权限，都变成private</span><br>d1.<span class="hljs-built_in">pub_mem</span>();<span class="hljs-comment">//正确：pub_mem在派生类中是public的</span><br>d2.<span class="hljs-built_in">pub_mem</span>();<span class="hljs-comment">//错误：pub_mem在派生类中是private的</span><br><br>Prot_Derv d3;<span class="hljs-comment">//继承自Base的成员如果是public，会变成protected，其他不变</span><br>d3.<span class="hljs-built_in">pub_mem</span>();<span class="hljs-comment">//错误，pub_mem是protected，只能成员和友元访问，外部不行</span><br></code></pre></div></td></tr></table></figure><h3 id="派生类向基类转换的可访问性"><a href="#派生类向基类转换的可访问性" class="headerlink" title="派生类向基类转换的可访问性"></a>派生类向基类转换的可访问性</h3><ul><li>只有当D公有继承B时，用户代码才能使用派生类向基类的转换，如果D继承B的方式是受保护或私有继承，则用户代码不能使用该转换。</li><li>无论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换，派生类向直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。</li><li>如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的类型转换；反之，如果D继承B的方式是私有的，则不能使用。</li></ul><p>说白了就一个规则：</p><p><strong>对代码中某个给定节点，如果基类的公有成员是可访问的，则派生类向基类的转换就是可访问的，反之则不行。</strong></p><p><strong>友元关系不能继承。</strong></p><p>class默认继承权限是private，struct是public。这一点和类成员权限很相似。</p><h2 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h2><p>派生类的作用域位于基类作用域之内，因此才可以实现派生类访问基类成员。</p><p>如果派生类重用了基类的成员名字，那么基类的对应成员就会被隐藏。此时想要访问隐藏的成员，就要通过域运算符，这一手法类似调用特定虚函数版本。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fcn</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D1</span> :</span> <span class="hljs-keyword">public</span> Base&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">//隐藏基类的fcn，这个fcn不是虚函数</span><br>  <span class="hljs-comment">//D1继承了Base::fcn()的定义</span><br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fcn</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-comment">//形参列表与Base中的fcn不一致</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//新的虚函数，在Base中不存在</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D2</span> :</span> <span class="hljs-keyword">public</span> D1&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fcn</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-comment">//非虚函数，隐藏了D1::fcn(int)</span><br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fcn</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//覆盖了Base的虚函数fcn</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//覆盖了D1的虚函数f2</span><br>&#125;;<br><br>Base bobj;<br>D1 d1obj;<br>D2 d2obj;<br><br>Base *bp1 = &amp;bobj, *bp2 = &amp;d1obj, *bp3 = &amp;d2obj;<br>bp1-&gt;<span class="hljs-built_in">fcn</span>();<span class="hljs-comment">//虚调用，运行时调用Base::fcn</span><br>bp2-&gt;<span class="hljs-built_in">fcn</span>();<span class="hljs-comment">//虚调用，运行时调用Base::fcn</span><br>bp3-&gt;<span class="hljs-built_in">fcn</span>();<span class="hljs-comment">//虚调用，运行时调用D2::fcn</span><br><br>D1 *d1p = &amp;d1obj; D2 *d2p = &amp;d2obj;<br>bp2-&gt;<span class="hljs-built_in">f2</span>();<span class="hljs-comment">//错误，Base没有f2成员</span><br>d1p-&gt;<span class="hljs-built_in">f2</span>();<span class="hljs-comment">//虚调用，运行时调用D1::f2()</span><br>d2p-&gt;<span class="hljs-built_in">f2</span>();<span class="hljs-comment">//虚调用，运行时调用D2::f2()</span><br><br>Base *p1 = &amp;d2obj; D1 *p2 = &amp;d2obj; D2 *p3 = &amp;d2obj;<br>p1-&gt;<span class="hljs-built_in">fcn</span>(<span class="hljs-number">42</span>);<span class="hljs-comment">//错误：Base中没有接受一个int的fcn</span><br>p2-&gt;<span class="hljs-built_in">fcn</span>(<span class="hljs-number">42</span>);<span class="hljs-comment">//静态绑定，调用D1::fcn(int)</span><br>p3-&gt;<span class="hljs-built_in">fcn</span>(<span class="hljs-number">42</span>);<span class="hljs-comment">//静态绑定，调用D2::fcn(int)</span><br></code></pre></div></td></tr></table></figure><h2 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h2><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>这一点已经说过了，如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义行为。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">Quote *itemP = <span class="hljs-keyword">new</span> Quote;<br><span class="hljs-keyword">delete</span> itemP;<span class="hljs-comment">//调用Quote的析构</span><br>itemP = <span class="hljs-keyword">new</span> Bulk_quote;<span class="hljs-comment">//静态类型与动态类型不一致</span><br><span class="hljs-keyword">delete</span> itemP;<span class="hljs-comment">//如果Quote析构是虚函数，则调用Bulk_quote，否则调用Quote析构</span><br></code></pre></div></td></tr></table></figure><p>三五准则中曾言，如果类需要析构函数，往往也需要拷贝构造和赋值操作，但对虚析构函数来说不遵守该准侧。</p><p><strong>虚析构函数将阻止合成移动操作。</strong></p><h3 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h3><p>构造器的调用链：</p><ul><li>合成的Bulk_quote默认构造函数运行Disc_quote的默认构造函数，后者又运行Quote的默认构造函数。</li><li>Quote的默认构造函数将bookNo成员默认初始化为空串，同时使用类内初始化值将price初始化为0。</li><li>Quote的构造函数完成后，继续执行Disc_quote的构造函数，它使用类内初始化qty和discount。</li><li>Disc_quote的构造函数完成后，继续执行Bulk_quote的构造函数，但什么具体工作也没做。</li></ul><p>类似的，合成的Bulk_quote的拷贝构造也一样，调用Disc_quote的拷贝构造，后者又调用了Quote的拷贝构造。</p><ul><li>如果基类的默认构造、拷贝构造、拷贝赋值运算符或析构函数是被删除的函数或不可访问，则派生类中对应的成员也将是删除的。</li><li>如果基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数是删除的，因为编译器无法销毁派生类对象的基类部分。</li><li>编译器不会合成一个删除掉的移动操作。使用=default请求一个移动操作时，如果基类中对应的操作是删除的或不可访问的，那么派生类中该函数将是被删除的，因为派生类对象的基类部分不可移动。同理，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。</li></ul><p>如果确实需要移动操作，那就应该在基类中自己去定义，否则会因为虚析构的存在而默认被delete。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span>&#123;</span>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> :</span> <span class="hljs-keyword">public</span> Base&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">D</span>(<span class="hljs-keyword">const</span> D&amp; d) : <span class="hljs-built_in">Base</span>(d)<br>    <span class="hljs-built_in">D</span>(D&amp;&amp; d) : <span class="hljs-built_in">Base</span>(std::<span class="hljs-built_in">move</span>(d))<br>  D &amp;D::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> D &amp;rhs)&#123;<br>        Base::<span class="hljs-keyword">operator</span>=(rhs);<br>      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h3><p>C++11可以让派生类重用基类定义的构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bulk_quote</span> :</span> <span class="hljs-keyword">public</span> Disc_quote&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">using</span> Disc_quote::Disc_quote;<span class="hljs-comment">//继承了Disc_quote的构造函数</span><br>  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span>)</span> <span class="hljs-keyword">const</span></span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>编译器会生成形如:<code>derived(params) : base(args)&#123;&#125;</code>的构造函数。这里的using作用给编译器，而不是当前作用域。</p><p>using声明语句不能指定constexpr或explicit，所以它继承基类的修饰。</p><p><strong>基类构造函数含有默认实参时，默认实参不会被继承。相反，派生类或获得多个继承的构造函数，每个构造函数分别省略掉一个含有默认实参的形参。</strong></p><p>如果基类有好几个构造函数，则大多数情况下派生类继承所有构造函数。除了两个例外，其一是派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本。如果派生类定义的构造函数与基类构造函数具有相同的参数列表，则这些构造函数不会被继承。其二是默认、拷贝和移动构造不会被继承。它们按照正常规则来合成，游离于三界之外。</p><h2 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vector&lt;Quote&gt; basket;<br>basket.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Quote</span>(<span class="hljs-string">&quot;0-201-82470-1&quot;</span>, <span class="hljs-number">50</span>));<br><span class="hljs-comment">//正确，但是只能把对象的Quote部分拷贝给basket</span><br>basket.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Bulk_quote</span>(<span class="hljs-string">&quot;0-201-54858-8&quot;</span>, <span class="hljs-number">50</span>, <span class="hljs-number">10</span>, <span class="hljs-number">.25</span>));<br><span class="hljs-comment">//调用Quote定义的版本</span><br>cout &lt;&lt; basket.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">net_price</span>(<span class="hljs-number">15</span>) &lt;&lt; endl;<br></code></pre></div></td></tr></table></figure><p>因为存放的是对象，所以类型转换上会阉割。</p><p>想要多态必须要间接访问，对容器来说也一样，我们要存放指针而不是对象。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vector&lt;shared_ptr&lt;Quote&gt;&gt; basket;<br>basket.<span class="hljs-built_in">push_back</span>(make_shared&lt;Quote&gt;(<span class="hljs-string">&quot;0-201-82470-1&quot;</span>, <span class="hljs-number">50</span>));<br>basket.<span class="hljs-built_in">push_back</span>(make_shared&lt;Bulk_quote&gt;(<span class="hljs-string">&quot;0-201-54848-8&quot;</span>, <span class="hljs-number">50</span>, <span class="hljs-number">10</span>, <span class="hljs-number">.25</span>));<br>cout &lt;&lt; basket.<span class="hljs-built_in">back</span>()-&gt;<span class="hljs-built_in">net_price</span>(<span class="hljs-number">15</span>) &lt;&lt; endl;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ primer 读书笔记 chapter 12 动态内存与智能指针</title>
    <link href="/2021/10/20/c++/12.%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"/>
    <url>/2021/10/20/c++/12.%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="C-primer-chapter-12"><a href="#C-primer-chapter-12" class="headerlink" title="C++ primer chapter 12"></a>C++ primer chapter 12</h1><h1 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h1><h2 id="动态内存与智能指针"><a href="#动态内存与智能指针" class="headerlink" title="动态内存与智能指针"></a>动态内存与智能指针</h2><p>C++中的动态内存管理通过一对运算符完成：<code>new</code>在动态内存中为对象分配空间并返回指向该对象的指针，可以选择对对象进行初始化；<code>delete</code>接受一个<strong>动态对象的指针</strong>，销毁该对象并释放与之关联的内存。</p><p>如果忘记释放内存，就会产生内存泄露。而如果在<strong>尚有指针引用内存的情况下释放内存</strong>，可能产生野指针的使用。</p><p>为了安全，标准库提供了两种智能指针(smart pointer)类型来管理动态对象。智能指针的行为类似常规指针，区别在于它负责自动释放所指向的对象。新标准库提供的这两种智能指针的区别在于管理底层指针的方式：<strong>shared_ptr</strong> 允许多个指针指向同一个对象；<strong>unique_pt</strong>r则独占所指向的对象。标准库还定义了名为<strong>weak_ptr</strong>的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。三者均在memory头文件中定义。</p><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>智能指针也是<strong>类模板</strong>（具有析构函数，在离开作用域析构阶段自动销毁）。</p><p>默认初始化：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">shared_ptr&lt;string&gt; p1;<span class="hljs-comment">//shared_ptr，可以指向string</span><br>shared_ptr&lt;list&lt;<span class="hljs-keyword">int</span>&gt;&gt; p2;<span class="hljs-comment">//shared_ptr, 可以指向int的list</span><br></code></pre></div></td></tr></table></figure><p>默认初始化的智能指针保存<strong>空指针</strong>。</p><p>使用方式类似普通指针，通过解引用返回对象。</p><table><thead><tr><th align="left">shared_ptr与unique_ptr都支持的操作</th><th align="left"></th></tr></thead><tbody><tr><td align="left"><code>shared_ptr&lt;T&gt; sp</code> / <code>unique_ptr&lt;T&gt; up</code></td><td align="left">空智能指针，可以指向类型为T的对象</td></tr><tr><td align="left"><code>p</code></td><td align="left">将p用作一个条件判断，若p指向一个对象，则为true</td></tr><tr><td align="left"><code>*p</code></td><td align="left">解引用p，获得它指向的对象</td></tr><tr><td align="left"><code>p-&gt;mem</code></td><td align="left">等价于(*p).mem</td></tr><tr><td align="left"><code>p.get()</code></td><td align="left">返回p中保存的指针。要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了</td></tr><tr><td align="left"><code>swap(p, q) </code>/<code>p.swap(q)</code></td><td align="left">交换p和q中的指针</td></tr></tbody></table><table><thead><tr><th align="left">shared_ptr独有的操作</th><th align="left"></th></tr></thead><tbody><tr><td align="left"><strong><code>make_shared&lt;T&gt;(args)</code></strong></td><td align="left">返回一个shared_ptr，指向一个动态分配的类型为T的对象。使用args初始化此对象</td></tr><tr><td align="left"><code>shared_ptr&lt;T&gt; p(q)</code></td><td align="left">p是shared_ptr q的拷贝；此操作会递增q中的计数器。q中的指针必须能转换为T*</td></tr><tr><td align="left"><code>p = q</code></td><td align="left">p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0，则将其管理的原内存释放</td></tr><tr><td align="left"><code>p.unique()</code></td><td align="left">若p.use_count()为1，返回true；否则返回false</td></tr><tr><td align="left"><code>p.use_count()</code></td><td align="left">返回与p共享对象的智能指针数量；可能很慢，主要用于调试</td></tr></tbody></table><p>make_shared标准库函数是<strong>分配使用动态内存最安全的方式</strong>，在内存中创建一个对象并初始化它。定义在memory头文件中。</p><p>make_shared用其参数来构造给定类型的对象。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; p3 = make_shared&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">42</span>);<span class="hljs-comment">//42</span><br>shared_ptr&lt;string&gt; p4 = make_shared&lt;string&gt;(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;9&#x27;</span>);<span class="hljs-comment">//&quot;9999999999&quot;，体现args</span><br>shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; p5 = make_shared&lt;<span class="hljs-keyword">int</span>&gt;();<span class="hljs-comment">//值初始化，即为0</span><br><span class="hljs-keyword">auto</span> p6 = make_shared&lt;vector&lt;string&gt;&gt;();<span class="hljs-comment">//更通用的定义</span><br></code></pre></div></td></tr></table></figure><h3 id="shared-ptr的拷贝和赋值"><a href="#shared-ptr的拷贝和赋值" class="headerlink" title="shared_ptr的拷贝和赋值"></a>shared_ptr的拷贝和赋值</h3><p>拷贝或赋值时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> p = make_shared&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">42</span>);<span class="hljs-comment">//p指向的对象只有p一个引用者</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">q</span><span class="hljs-params">(p)</span></span>;<span class="hljs-comment">//p和q指向相同对象，此对象有两个引用者</span><br></code></pre></div></td></tr></table></figure><p>每个shared_ptr都有一个<strong>引用计数</strong>。<strong>拷贝shared_ptr会递增计数器</strong>。用一个shared_ptr初始化另一个shared_ptr，或作为参数传递给一个函数或作为函数的返回值时，引用计数都会递增。而shared_ptr赋予其他值时或是shared_ptr被销毁时（比如局部的shared_ptr离开其作用域），计<strong>数器会递减</strong>。</p><p>一旦shared_ptr计数器变为0，它会<strong>自动释放自己管理的对象</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> r = make_shared&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">42</span>);<span class="hljs-comment">//r指向的int只有一个引用者</span><br>r = q;<span class="hljs-comment">//给r赋值，令它指向另一个地址</span><br><span class="hljs-comment">//递增q指向的对象的引用计数</span><br><span class="hljs-comment">//递减r原本指向对象的引用计数</span><br><span class="hljs-comment">//r原本指向对象的引用计数变为0，自动释放</span><br></code></pre></div></td></tr></table></figure><p>shared_ptr类的自动销毁对象是通过其析构函数完成的。析构函数会递减它所指向对象的引用计数，如果引用计数变为0，shared_ptr的析构函数会销毁对象并释放空间。</p><p>如果将shared_ptr存放于容器中，一段时间过后不需要全部元素，而只使用其中一部分，应该用erase删除不再需要的元素，如此才能得以释放内存（如果没有其他的引用的话）。</p><p>程序使用动态内存通常出于以下三种原因之一：</p><ul><li>不确定需要使用多少对象。</li><li>不确定所需对象的准确类型。</li><li>需要在多个对象间共享数据。</li></ul><h3 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h3><p>直接使用new和delete是C++的一把双刃剑。</p><p>默认情况下，动态分配的对象是默认初始化的。所以内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">string *ps = <span class="hljs-keyword">new</span> string;<span class="hljs-comment">//初始化为空字符串</span><br><span class="hljs-keyword">int</span> *pi = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<span class="hljs-comment">//pi指向未初始化int</span><br></code></pre></div></td></tr></table></figure><p>可以使用<strong>值初始化方式、直接初始化方式、传统构造方式（圆括号<code>()</code>）或新标准下的列表初始化方式（花括号<code>&#123;&#125;</code>）</strong>初始化动态分配的对象。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *pi = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-number">1024</span>);<br>string *ps = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;9&#x27;</span>);<br>vector&lt;<span class="hljs-keyword">int</span>&gt; *pv = <span class="hljs-keyword">new</span> vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br>string *ps1 = <span class="hljs-keyword">new</span> string;<span class="hljs-comment">//默认初始化，空串</span><br>string *ps = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>();<span class="hljs-comment">//值初始化，空串</span><br><span class="hljs-keyword">int</span> *pi1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<span class="hljs-comment">//默认初始化，值未定义</span><br><span class="hljs-keyword">int</span> *pi2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>();<span class="hljs-comment">//值初始化为0</span><br></code></pre></div></td></tr></table></figure><p>对定义了构造函数的类类型来说，无论是值初始化还是默认初始化，都会调用默认构造函数。<strong>而内置类型则不同，值初始化有着良好定义的值，默认初始化则未定义。</strong></p><p>可以用new分配const对象，返回指向const类型的指针。<strong>动态分配的const对象必须初始化</strong>。</p><p>如果动态内存被耗尽，new表达式就会失败，默认情况下new失败时会抛出类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛异常：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//如果分配失败，new返回一个空指针</span><br><span class="hljs-keyword">int</span> *p1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<span class="hljs-comment">//分配失败，则new抛出std::bad_alloc</span><br><span class="hljs-keyword">int</span> *p2 = <span class="hljs-built_in"><span class="hljs-keyword">new</span></span> (nothrow) <span class="hljs-keyword">int</span>;<span class="hljs-comment">//如果分配失败，则new返回一个空指针</span><br></code></pre></div></td></tr></table></figure><p>后者的new形式称为定位new。定位new表达式可以传递额外的参数，这里传递了一个标准库定义的名为nothrow的对象，意为不要抛出异常。</p><blockquote><p>nothrow和bad_alloc定义在new头文件中。</p></blockquote><p>释放内存通过delete表达式。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">delete</span> p;<span class="hljs-comment">//p必须指向一个动态分配的对象或是一个空指针</span><br></code></pre></div></td></tr></table></figure><p>释放并非new分配的内存，或者将相同的指针值释放多次，行为是未定义的：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i, *pi1 = &amp;i, *pi2 = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">double</span> *pd = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(<span class="hljs-number">33</span>), *pd2 = pd;<br><span class="hljs-keyword">delete</span> i;<span class="hljs-comment">//错误：i不是指针</span><br><span class="hljs-keyword">delete</span> pi1;<span class="hljs-comment">//未定义：pi1指向一个局部变量</span><br><span class="hljs-keyword">delete</span> pd;<span class="hljs-comment">//正确</span><br><span class="hljs-keyword">delete</span> pd2;<span class="hljs-comment">//未定义：pd2指向的内存已经被释放了</span><br><span class="hljs-keyword">delete</span> pi2;<span class="hljs-comment">//正确：释放空指针总是没有错误的</span><br></code></pre></div></td></tr></table></figure><p>new出来的const对象也可以delete，尽管对象本身不能改变。</p><h3 id="shared-ptr和new的联用"><a href="#shared-ptr和new的联用" class="headerlink" title="shared_ptr和new的联用"></a>shared_ptr和new的联用</h3><p>new返回的指针可以初始化智能指针，<strong>智能指针的构造函数是explicit的</strong>，因此<strong>必须使用直接初始化形式</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-number">1024</span>);<span class="hljs-comment">//错误：必须使用直接初始化</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">1024</span>))</span></span>;<span class="hljs-comment">//正确：使用了直接初始化</span><br></code></pre></div></td></tr></table></figure><p>默认情况下，用来初始化<strong>智能指针的内置指针必须指向动态内存</strong>，因为智能指针默认使用delete释放它所管理的对象。如果要将智能指针绑定到一个指向其他类型资源的指针上，就必须提供自定义操作来代替delete。</p><table><thead><tr><th align="left">定义和改变shared_ptr的其他方法</th><th align="left"></th></tr></thead><tbody><tr><td align="left"><code>shared_ptr&lt;T&gt; p(q)</code></td><td align="left">p管理内置指针q所指向的对象；q必须指向new分配的内存，且能够转换为T*类型</td></tr><tr><td align="left"><code>shared_ptr&lt;T&gt; p(u)</code></td><td align="left">p从unique_ptr u那里接管了对象的所有权；将u置为空</td></tr><tr><td align="left"><code>shared_ptr&lt;T&gt; p(q, d)</code></td><td align="left">p接管了内置指针q所指向的对象的所有权。q必须能转为T*类型。p将使用可调用对象d来代替delete</td></tr><tr><td align="left"><code>shared_ptr&lt;T&gt; p(p2, d)</code></td><td align="left">p是shared_ptr p2的拷贝，唯一的区别是p将用可调用对象d来代替delete</td></tr><tr><td align="left"><code>p.reset()</code></td><td align="left">置p为空，若p是唯一指向其对象的shared_ptr，reset会释放此对象。</td></tr><tr><td align="left"><code>p.reset(q)</code></td><td align="left">若传递了可选的参数内置指针q，会令p指向q，否则会将p置空。</td></tr><tr><td align="left"><code>p.reset(q, d)</code></td><td align="left">若还传递了参数d，将会调用d而不是delete来释放q</td></tr></tbody></table><p>区分<code>shared_ptr&lt;T&gt; p(q, d)</code> 和 <code>p.reset(q, d)</code> 中参数 d 的语义</p><p><strong>不要混合使用内置指针和智能指针</strong>。当将shared_ptr绑定到内置指针后，资源管理就应该交由shared_ptr负责。不应该再使用内置指针访问shared_ptr指向的内存。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 函数被调用时ptr被创建并初始化</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 使用ptr</span><br>&#125;   <span class="hljs-comment">// ptr离开作用域，被销毁</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">1024</span>))</span></span>;   <span class="hljs-comment">// 危险：x是一个普通指针，不是智能指针</span><br><span class="hljs-built_in">process</span>(x);     <span class="hljs-comment">// 错误：无法转换 int* 到 shared_ptr&lt;int&gt;</span><br><span class="hljs-built_in">process</span>(shared_ptr&lt;<span class="hljs-keyword">int</span>&gt;(x));    <span class="hljs-comment">// 合法，但是内存会被释放</span><br><span class="hljs-keyword">int</span> j = *x;     <span class="hljs-comment">// 未定义的：x是悬垂指针</span><br><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>))</span></span>;   <span class="hljs-comment">// 引用计数为1</span><br><span class="hljs-built_in">process</span>(p);     <span class="hljs-comment">// 拷贝p会增加它的引用计数，process中引用计数为2</span><br><span class="hljs-keyword">int</span> i = *p;     <span class="hljs-comment">// 正确：引用计数为1</span><br></code></pre></div></td></tr></table></figure><p>智能指针的<code>get</code>函数<strong>返回一个内置指针</strong>，指向智能指针管理的对象。主要<strong>用于向不能使用智能指针的代码传递内置指针</strong>。使用get返回指针的代码不能delete此指针。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>))</span></span>;<span class="hljs-comment">//引用计数为1</span><br><span class="hljs-keyword">int</span> *q = p.<span class="hljs-built_in">get</span>();<span class="hljs-comment">//正确：但使用q要注意，不要让它管理的指针被释放</span><br>&#123;<span class="hljs-comment">//新程序块</span><br>    <span class="hljs-comment">//未定义：两个独立的shared_ptr指向相同的内存</span><br>  shared_ptr&lt;<span class="hljs-keyword">int</span>&gt;(q);<br>&#125;<span class="hljs-comment">//程序块结束，q被销毁，它指向的内存被释放</span><br><span class="hljs-keyword">int</span> foo = *p;<span class="hljs-comment">//未定义：p指向的内存已经被释放了</span><br></code></pre></div></td></tr></table></figure><p>花式作死的另一种用法。</p><blockquote><p>永远不要用get初始化另一个智能指针或为另一个智能指针赋值。</p></blockquote><p>reset可以将新指针赋予shared_ptr：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">p = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-number">1024</span>);<span class="hljs-comment">//错误：不能将一个指针赋予shared_ptr</span><br>p.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-number">1024</span>));<span class="hljs-comment">//正确：p指向一个新对象</span><br></code></pre></div></td></tr></table></figure><p>与赋值类似，reset会更新引用计数，如果需要的话，会释放p指向的对象。reset成员经常与unique一起用，来控制多个shared_ptr共享的对象。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(!p.<span class="hljs-built_in">unique</span>())<br>  p.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(*p));<span class="hljs-comment">//不是唯一用户；分配新的拷贝</span><br>*p += newVal;<span class="hljs-comment">//现在我们知道自己是唯一的用户，可以改变对象的值</span><br></code></pre></div></td></tr></table></figure><h3 id="智能指针和异常"><a href="#智能指针和异常" class="headerlink" title="智能指针和异常"></a>智能指针和异常</h3><p>如果使用智能指针，<strong>即使程序块过早结束</strong>，智能指针类也能确保在内存不再需要时将其释放。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> *ip = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-number">42</span>);<br>  <span class="hljs-comment">//这段代码抛出异常，且在f中未被捕获</span><br>  <span class="hljs-keyword">delete</span> ip;<span class="hljs-comment">//退出之前释放内存</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>标准的内存泄露</strong>。</p><p>而如果:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sp</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>))</span></span>;<br>  <span class="hljs-comment">//这段代码抛出异常，且在f中未捕获</span><br>&#125;<span class="hljs-comment">//函数结束时shared_ptr自动释放内存</span><br></code></pre></div></td></tr></table></figure><p>默认情况下shared_ptr假定其指向动态内存，使用delete释放对象。创建shared_ptr时可以传递一个（可选）指向删除函数的指针参数，用来代替delete。这个删除器(deleter)函数必须能够完成对shared_ptr中保存的指针进行释放的操作。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">destination</span>;</span>  <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">connection</span>;</span>     <br><span class="hljs-function">connection <span class="hljs-title">connect</span><span class="hljs-params">(destination*)</span></span>;   <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">disconnect</span><span class="hljs-params">(connection)</span></span>;   <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">end_connection</span><span class="hljs-params">(connection *p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">disconnect</span>(*p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(destination &amp;d <span class="hljs-comment">/* 其他参数 */</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    connection c = <span class="hljs-built_in">connect</span>(&amp;d);<br>    <span class="hljs-function">shared_ptr&lt;connection&gt; <span class="hljs-title">p</span><span class="hljs-params">(&amp;c, end_connection)</span></span>;<br>    <span class="hljs-comment">// 使用连接</span><br>    <span class="hljs-comment">// f退出时（即使是异常退出），connection会被正确关闭</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>==<strong>智能指针规范</strong>：==</p><ul><li><strong>不使用相同的内置指针值初始化或reset多个智能指针。</strong></li><li><strong>不释放get返回的指针。</strong></li><li>==<strong>不使用get初始化或reset另一个智能指针。</strong>==</li><li><strong>使用get返回的指针时，如果最后一个对应的智能指针被销毁，指针就无效了。</strong></li><li><strong>使用shared_ptr管理并非new分配的资源时，应该传递删除函数。</strong></li></ul><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>与shared_ptr不同，同一时刻只能有一个unique_ptr指向给定的对象。当unique_ptr被销毁时，它指向的对象也会被销毁。</p><p><code>make_unique</code>函数（C++14新增，定义在头文件<em>memory</em>中）在动态内存中分配一个对象并初始化它，返回指向此对象的unique_ptr。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>))</span></span>;<br><span class="hljs-comment">// C++14  C11没有make_unique</span><br>unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; p2 = make_unique&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">42</span>);<br></code></pre></div></td></tr></table></figure><p>由于unique_ptr<strong>独占</strong>其指向的对象，因此<strong>unique_ptr不支持普通的拷贝或赋值操作</strong>。</p><table><thead><tr><th align="left">unique_ptr操作</th><th align="left"></th></tr></thead><tbody><tr><td align="left"><code>unique_ptr&lt;T&gt; u1</code></td><td align="left">空unique_ptr，可以指向类型为T的对象。u1会使用delete来释放它的指针；u2会使用一个类型为D的可调用对象来释放它的指针</td></tr><tr><td align="left"><code>unique_ptr&lt;T, D&gt; u2</code></td><td align="left"></td></tr><tr><td align="left"><code>unique_ptr&lt;T, D&gt; u(d)</code></td><td align="left">空unique_ptr，指向类型为T的对象，用类型为D的对象d代替delete</td></tr><tr><td align="left"><code>u = nullptr</code></td><td align="left">释放u指向的对象，将u置空</td></tr><tr><td align="left"><code>u.release()</code></td><td align="left">u放弃对指针的控制权，返回指针，并将u置空</td></tr><tr><td align="left"><code>u.reset()</code></td><td align="left">释放u指向的对象</td></tr><tr><td align="left"><code>u.reset(q)</code></td><td align="left">如果提供了内置指针q，令u指向这个对象，否则u置空</td></tr><tr><td align="left"><code>u.reset(nullptr)</code></td><td align="left"></td></tr></tbody></table><p>unique_ptr<strong>不能拷贝或赋值，但可以转移</strong>：(release 和 reset)</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//将所有权从p1转移给p2</span><br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p2</span><span class="hljs-params">(p1.release())</span></span>;<span class="hljs-comment">//release将p1置空</span><br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;Trex&quot;</span>))</span></span>;<br><span class="hljs-comment">//将所有权从p3转移给p2</span><br>p2.<span class="hljs-built_in">reset</span>(p3.<span class="hljs-built_in">release</span>());<span class="hljs-comment">//reset释放了p2原来指向的内存</span><br><br>p2.<span class="hljs-built_in">release</span>();<span class="hljs-comment">//错误：p2不会释放内存，而且我们弄丢了指针</span><br><span class="hljs-keyword">auto</span> p = p2.<span class="hljs-built_in">release</span>();<span class="hljs-comment">//正确，但我们必须记得delete(p)</span><br></code></pre></div></td></tr></table></figure><p>不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">clone</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>&#123;<br>    <span class="hljs-comment">//正确：从int*创建一个unique_ptr&lt;int&gt;</span><br>  <span class="hljs-keyword">return</span> unique_ptr&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(p));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>还可以返回一个局部对象的拷贝：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">clone</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>&#123;<br>    <span class="hljs-function">unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ret</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(p))</span></span>;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>类似shared_ptr，默认情况下unique_ptr用delete释放其指向的对象。unique_ptr的删除器同样可以重载，但unique_ptr管理删除器的方式与shared_ptr不同。<strong>定义unique_ptr时必须在尖括号中提供删除器类型</strong>。创建或reset这种unique_ptr类型的对象时，必须提供一个指定类型的可调用对象（删除器）。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//p指向一个类型为objT的对象，并使用一个类型为delT的对象释放objT对象</span><br><span class="hljs-comment">//它会调用一个名为fcn的delT类型对象</span><br><span class="hljs-function">unique_ptr&lt;objT, delT&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> objT, fcn)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(destination &amp;d<span class="hljs-comment">/* 其他参数 */</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    connection c = <span class="hljs-built_in">connect</span>(&amp;d);<br>  <span class="hljs-function">unique_ptr&lt;connection, <span class="hljs-title">decltype</span><span class="hljs-params">(end_connection)</span>*&gt; <span class="hljs-title">p</span><span class="hljs-params">(&amp;c, end_connection)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr是一种不控制所指向对象生存期的智能指针，它指向一个由shared_ptr管理的对象。将weak_ptr绑定到shared_ptr不会改变shared_ptr的引用计数。<strong>如果shared_ptr被销毁，即使有weak_ptr指向对象，对象仍然有可能被释放</strong>。</p><table><thead><tr><th align="left">weak_ptr</th><th align="left"></th></tr></thead><tbody><tr><td align="left"><code>weak_ptr&lt;T&gt; w</code></td><td align="left">空weak_ptr可以指向类型为T的对象</td></tr><tr><td align="left"><code>weak_ptr&lt;T&gt; w(sp)</code></td><td align="left">与shared_ptr sp指向相同对象的weak_ptr。T必须能转换为sp指向的类型</td></tr><tr><td align="left">w = p</td><td align="left">p可以是一个shared_ptr或一个weak_ptr。赋值后w与p共享对象</td></tr><tr><td align="left">w.reset()</td><td align="left">w置空</td></tr><tr><td align="left">w.use_count()</td><td align="left">与w共享对象的<strong>shared_ptr的数量</strong></td></tr><tr><td align="left">w.expired()</td><td align="left">若w.use_count()为0，返回true，否则返回false</td></tr><tr><td align="left">w.lock()</td><td align="left">如果expired为true，返回空shared_ptr；否则返回一个指向w的对象的shared_ptr</td></tr></tbody></table><p>创建一个weak_ptr时，<strong>需要使用shared_ptr来初始化它</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> p = make_shared&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">42</span>);<br><span class="hljs-function">weak_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">wp</span><span class="hljs-params">(p)</span></span>;    <span class="hljs-comment">// wp弱共享p，p引用计数不变</span><br></code></pre></div></td></tr></table></figure><p>由于对象可能不存在，所以<strong>weak_ptr访问对象前，要先lock</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; np = wp.<span class="hljs-built_in">lock</span>())&#123;<span class="hljs-comment">//np不为空则条件成立</span><br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><h3 id="new和数组"><a href="#new和数组" class="headerlink" title="new和数组"></a>new和数组</h3><p>数组是个很特别的存在，对于数组的动态分配和释放C++定义了相应的手法。</p><h4 id="new"><a href="#new" class="headerlink" title="new []"></a>new []</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *pia = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-built_in">get_size</span>()];<span class="hljs-comment">// pia指向第一个int，调用get_size确定分配多少个int</span><br></code></pre></div></td></tr></table></figure><p>方括号中的大小必须是整型，但不一定非要常量。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> arrT[<span class="hljs-number">42</span>];<br><span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> arrT;<span class="hljs-comment">//实际上还是用的new[]而非new</span><br></code></pre></div></td></tr></table></figure><p>new返回的是一个元素类型的指针，指向第一个分配的成员。</p><p>C++中，<strong>动态数组不是数组类型</strong>，所以begin或end是不可以使用的，也不能用范围for语句来处理动态数组。</p><p>默认情况下，new分配的对象是默认初始化的。可以对数组中的元素进行<strong>值初始化</strong>，方法是在大小**后面跟一对空括号<code>()</code>**。在新标准中，还可以提供一个元素初始化器的花括号列表。如果初始化器数量大于元素数量，则new表达式失败，不会分配任何内存，并抛出bad_array_new_length异常。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *pia = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];     <span class="hljs-comment">// 10个未初始化的int</span><br><span class="hljs-keyword">int</span> *pia2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>]();    <span class="hljs-comment">// 10个值初始化为的int</span><br>string *psa = <span class="hljs-keyword">new</span> string[<span class="hljs-number">10</span>];    <span class="hljs-comment">// 10个空string</span><br>string *psa2 = <span class="hljs-keyword">new</span> string[<span class="hljs-number">10</span>]();    <span class="hljs-comment">// 10个空string</span><br><span class="hljs-comment">//10个int分别用列表中对应的初始化器初始化</span><br><span class="hljs-keyword">int</span> *pia3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>] &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span> &#125;;<br><span class="hljs-comment">//10个string，前4个用给定的初始化器初始化，剩余的进行值初始化</span><br>string *psa3 = <span class="hljs-keyword">new</span> string[<span class="hljs-number">10</span>] &#123; <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;the&quot;</span>, <span class="hljs-built_in">string</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;x&#x27;</span>) &#125;;<br></code></pre></div></td></tr></table></figure><p>虽然可以使用空括号对new分配的数组元素进行值初始化，但不能在括号中指定初始化器。这意味着不能用auto分配数组。</p><p>动态分配一个空数组是合法的，此时new会返回一个合法的非空指针。对于零长度的数组来说，该指针类似尾后指针，不能解引用。</p><h4 id="delete"><a href="#delete" class="headerlink" title="delete []"></a>delete []</h4><p>对应<code>new[]</code>，使用==<code>delete[]</code>==释放动态数组。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">delete</span> p;<span class="hljs-comment">//p必须指向一个动态分配的对象或空</span><br><span class="hljs-keyword">delete</span> [] pa;<span class="hljs-comment">//pa必须指向动态分配的数组或空</span><br></code></pre></div></td></tr></table></figure><p>数组中元素按逆序销毁。如果忽略了方括号，那么行为未定义。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> arrT[<span class="hljs-number">42</span>];<br><span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> arrT;<br><span class="hljs-keyword">delete</span> [] p;<span class="hljs-comment">//这个方括号是必须的。</span><br></code></pre></div></td></tr></table></figure><h4 id="智能指针和动态数组"><a href="#智能指针和动态数组" class="headerlink" title="智能指针和动态数组"></a>智能指针和动态数组</h4><p>unique_ptr可以直接管理动态数组，**定义时需要在对象类型后添加一对空方括号<code>[]</code>**。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">unique_ptr&lt;<span class="hljs-keyword">int</span>[]&gt; <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>])</span></span>;<br>up.<span class="hljs-built_in">release</span>();<span class="hljs-comment">//自动使用delete []来销毁指针</span><br></code></pre></div></td></tr></table></figure><p>指向数组的unique_ptr的操作有些不同：</p><table><thead><tr><th align="left">指向数组的unique_ptr</th><th align="left"></th></tr></thead><tbody><tr><td align="left"><code>unique_ptr&lt;T[]&gt; u</code></td><td align="left">u可以指向一个动态分配的数组，数组元素类型为T</td></tr><tr><td align="left"><code>unique_ptr&lt;T[]&gt; u(p)</code></td><td align="left">u指向内置指针p所指向的动态分配的数组。p必须能转换为类型T*</td></tr><tr><td align="left">u[i]</td><td align="left">返回u拥有的数组中i处的对象，u必须指向一个数组</td></tr></tbody></table><p>指向数组的unique_ptr不支持成员访问运算符(.和-&gt;)。</p><p>shared_ptr不直接支持管理动态数组，如果希望使用shared_ptr管理动态数组，必须提供自定义的删除器：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sp</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>], [](<span class="hljs-keyword">int</span> *p)&#123;<span class="hljs-keyword">delete</span>[] p;&#125;)</span></span>;<br>sp.<span class="hljs-built_in">reset</span>();<span class="hljs-comment">//使用我们提供的lambda释放数组，它使用delete []</span><br></code></pre></div></td></tr></table></figure><p>如果未提供删除器，则代码是未定义的。</p><p>shared_ptr不支持下标运算符，且不支持指针的算数运算，所以需要借助get。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span>;i!=<span class="hljs-number">10</span>;++i)&#123;<br>    *(sp.<span class="hljs-built_in">get</span>() + i) = i;<span class="hljs-comment">//使用get获取一个内置指针</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a>allocator类</h3><p>allocator类也是一个类模板，定义时必须指定其分配的对象类型。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">allocator&lt;<span class="hljs-built_in">string</span>&gt; alloc;    <span class="hljs-comment">// 可以分配string的allocator对象</span><br><span class="hljs-built_in">auto</span> <span class="hljs-keyword">const</span> p = alloc.allocate(n);   <span class="hljs-comment">// 分配n个未初始化的string</span><br></code></pre></div></td></tr></table></figure><table><thead><tr><th align="left">标准库allocator类及其算法</th><th align="left"></th></tr></thead><tbody><tr><td align="left"><code>allocator&lt;T&gt; a</code></td><td align="left">定义了一个名为a的allocator对象，它可以为类型为T的对象分配内存</td></tr><tr><td align="left"><code>a.allocate(n)</code></td><td align="left">分配一段原始的、未构造的内存，保存n个类型为T的对象</td></tr><tr><td align="left"><code>a.deallocate(p, n)</code></td><td align="left">释放从T*指针p中地址开始的内存，这块内存保存了n个类型为T的对象；p必须是一个先前由allocate返回的指针，且n必须是p创建时所要求的大小。调用deallocate前，用户必须对每个在这块内存中创建的对象调用destroy</td></tr><tr><td align="left"><code>a.construct(p, args)</code></td><td align="left">p必须是一个类型为T<em>的指针，指向一块原始内存；*<em>arg被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象</em></em></td></tr><tr><td align="left"><code>a.destroy(p)</code></td><td align="left">p为T*类型的指针，此算法对p指向的对象执行析构函数</td></tr></tbody></table><p>allocator分配的内存是未构造的，程序需要在此内存中构造对象。新标准库的<code>construct</code>函数接受一个指针和零或多个额外参数，在给定位置构造一个元素。额外参数用来初始化构造的对象，必须与对象类型相匹配。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> q = p;     <span class="hljs-comment">// q指向最后构造的元素之后的位置</span><br>alloc.<span class="hljs-built_in">construct</span>(q++);    <span class="hljs-comment">// *q为空字符串</span><br>alloc.<span class="hljs-built_in">construct</span>(q++, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;c&#x27;</span>);  <span class="hljs-comment">// *q为cccccccccc</span><br>alloc.<span class="hljs-built_in">construct</span>(q++, <span class="hljs-string">&quot;hi&quot;</span>);     <span class="hljs-comment">// *q为hi</span><br></code></pre></div></td></tr></table></figure><p>在未构造对象前使用原始内存是错误的：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">cout &lt;&lt; *p &lt;&lt; endl;<span class="hljs-comment">//正确：使用string的输出运算符</span><br>cout &lt;&lt; *q &lt;&lt; endl;<span class="hljs-comment">//灾难：q指向未构造的内存！</span><br></code></pre></div></td></tr></table></figure><p>用完对象后，需要对每个构造的元素调用destroy来销毁它们。函数destroy接受一个指针，对指向的对象执行析构函数：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(q != p)<br>  alloc.<span class="hljs-built_in">destroy</span>(--q);<span class="hljs-comment">//释放我们真正构造的string</span><br></code></pre></div></td></tr></table></figure><p>注意只能对已构造的对象进行destroy。</p><p>destroy后的内存可以重用。</p><p>全部destroy后，可以调用deallocate来归还内存给系统。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">alloc.<span class="hljs-built_in">deallocate</span>(p, n);<br></code></pre></div></td></tr></table></figure><p>标准库还为allocator类定义了两个伴随算法，可以在未初始化内存中创建对象。</p><table><thead><tr><th align="left">allocator算法</th><th align="left"></th></tr></thead><tbody><tr><td align="left">uninitialized_copy(b,e,b2)</td><td align="left">从迭代器b和e指定的输入范围中拷贝元素到迭代器b2指定的未构造的原始内存中。b2指向的内存必须足够大。</td></tr><tr><td align="left">uninitialized_copy_n(b,n,b2)</td><td align="left">从迭代器b指向的元素开始，拷贝n个元素到b2开始的内存中</td></tr><tr><td align="left">uninitialized_fill(b,e,t)</td><td align="left">在迭代器b和e指定的原始内存范围中创建对象，对象的值均为t的拷贝</td></tr><tr><td align="left">uninitialized_fill_n(b,n,t)</td><td align="left">从迭代器b指向的内存地址开始创建n个对象。b必须指向足够大的未构造的原始内存</td></tr></tbody></table><p>这些函数在给定目的位置创建元素，而不是由系统分配内存给它们。它们在memory头文件中。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> p = alloc.<span class="hljs-built_in">allocate</span>(vi.<span class="hljs-built_in">size</span>() * <span class="hljs-number">2</span>);<br><span class="hljs-keyword">auto</span> q = <span class="hljs-built_in">uninitialized_copy</span>(vi.<span class="hljs-built_in">begin</span>(), vi.<span class="hljs-built_in">end</span>(), p);<span class="hljs-comment">//返回递增后的目的位置迭代器。</span><br><span class="hljs-built_in">uninitialized_fill_n</span>(q, vi.<span class="hljs-built_in">size</span>(), <span class="hljs-number">42</span>);<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ primer 读书笔记 chapter 7 类</title>
    <link href="/2021/10/19/c++/7.%E7%B1%BB/"/>
    <url>/2021/10/19/c++/7.%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="C-primer-chapter-7"><a href="#C-primer-chapter-7" class="headerlink" title="C++ primer chapter 7"></a>C++ primer chapter 7</h1><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类的基本思想是<strong>数据抽象（data abstraction）</strong>和<strong>封装（encapsulation）</strong>。数据抽象是一种依赖于<strong>接口（interface）</strong>和<strong>实现（implementation）</strong>分离的编程及设计技术。<strong>类的接口</strong>包括用户所能执行的操作；<strong>类的实现</strong>包括类的数据成员、负责接口实现的函数体以及其他私有函数。</p><h2 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h2><p>使用class或是struct关键字可以定义类类型，struct是为了兼容旧式C风格结构体，对于定义类类型来说，struct和class的<strong>唯一区别在于默认访问权限不同</strong>。</p><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>成员函数通过一个名为this的<strong>隐式参数</strong>来访问调用它的对象。this是一个<strong>常量指针</strong>，无法改变this中保存的地址。</p><h3 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h3><p>isbn函数的参数列表后跟随了一个const关键字，这里的const是用来<strong>修改隐式this指针的类型</strong>。</p><p>默认情况下，this类型是指向类类型非常量版本的常量指针。比如Sales_data类成员函数中，this的类型是<code>Sales_data *const</code>。尽管this是隐式的，但它仍然需要遵守初始化规则，这就意味着我们不能把this绑定到一个常量对象上。因此，受这一限制，我们无法在一个常量对象上调用普通的成员函数。</p><p>因为this是隐式的，我们没有办法像修饰其他参数一样，去声明其为指向常量的指针，所以C++的语法只好提供实现途径——把const关键字放在成员函数的参数列表之后，此时，this就是一个<strong>指向常量的指针</strong>，这种const成员函数被叫做<strong>常量成员函数</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//伪代码，说明隐式this指针是如何使用的</span><br><span class="hljs-comment">//下面的代码非法：我们不能显式地定义自己的this指针</span><br><span class="hljs-comment">//此处的this是一个指向常量的指针，因为isbn是一个常量成员</span><br><span class="hljs-function">std::string <span class="hljs-title">Sales_data::isbn</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Sales_data *<span class="hljs-keyword">const</span> <span class="hljs-keyword">this</span>)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;isbn;&#125;<br></code></pre></div></td></tr></table></figure><p>因为this指向常量，所以常量成员函数不能改变调用它的对象的内容。只读不可写。</p><h3 id="外部定义成员函数"><a href="#外部定义成员函数" class="headerlink" title="外部定义成员函数"></a>外部定义成员函数</h3><p>注意需要加作用域运算符，否则谁知道你定义的是谁的成员。</p><p>为了实现<strong>连续调用链</strong>，可以令成员函数返回this对象本身：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">Sales_data &amp;<span class="hljs-title">Sales_data::combine</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Sales_data &amp;rhs)</span></span><br><span class="hljs-function"></span>&#123;<br>    units_sold += rhs.units_sold;<br>  revenue += rhs.revenue;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">// 返回调用该函数的对象</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>类的作者往往还需要定义一些辅助函数，这些函数不作为类的成员函数，但也作为类的接口的一部分。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">istream &amp;<span class="hljs-title">read</span><span class="hljs-params">(istream &amp;is, Sales_data &amp;item)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">double</span> price = <span class="hljs-number">0</span>;<br>  is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;<br>  item.revenue = price * item.units_sold;<br>  <span class="hljs-keyword">return</span> is;<br>&#125;<br><span class="hljs-function">ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(ostream &amp;os, <span class="hljs-keyword">const</span> Sales_data &amp;item)</span></span><br><span class="hljs-function"></span>&#123;<br>    os &lt;&lt; item.<span class="hljs-built_in">isbn</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="hljs-string">&quot; &quot;</span><br>      &lt;&lt; item.revenue &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt; item.<span class="hljs-built_in">avg_price</span>();<br>  <span class="hljs-keyword">return</span> os;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>每个类都定义了对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫构造函数。构造函数的任务是<strong>初始化类对象的数据成员</strong>，无论何时只要类的对象被创建，就会执行构造函数。</p><p>==构造函数的名字和类名一致，没有返回类型==，构造函数可以重载，不能被声明成const（因为创建一个const对象时，会先调用构造函数，再得到const属性）。</p><h4 id="合成的默认构造函数"><a href="#合成的默认构造函数" class="headerlink" title="合成的默认构造函数"></a>合成的默认构造函数</h4><p>如果类不定义任何构造函数，编译器会提供一个没有任何实参的默认构造函数。编译器创建的构造函数也叫合成的默认构造函数。</p><p>合成的默认构造函数完成以下任务：</p><ul><li>如果存在类内的初始值，用它来初始化成员。</li><li>否则，默认初始化该成员。</li></ul><p><strong>一旦</strong>定义了一个构造函数，那么编译器不再合成默认构造函数，即使我们定义的构造函数并不是没有参数的默认构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Sales_data</span>&#123;</span><br>    <span class="hljs-built_in">Sales_data</span>() = <span class="hljs-keyword">default</span>;<br>  <span class="hljs-built_in">Sales_data</span>(<span class="hljs-keyword">const</span> std::string &amp;s):<span class="hljs-built_in">bookNo</span>(s)&#123;&#125;<br>  <span class="hljs-built_in">Sales_data</span>(<span class="hljs-keyword">const</span> std::string &amp;s, <span class="hljs-keyword">unsigned</span> n, <span class="hljs-keyword">double</span> p):<span class="hljs-built_in">bookNo</span>(s), <span class="hljs-built_in">units_sold</span>(n), <span class="hljs-built_in">revenue</span>(p*n)&#123;&#125;<br>  <span class="hljs-built_in">Sales_data</span>(std::istream &amp;);<br>  std::string bookNo;<br>  <span class="hljs-keyword">unsigned</span> units_sold = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">double</span> revenue = <span class="hljs-number">0.0</span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>=default</strong>是<strong>C11</strong>引入的， 用于<strong>显式要求</strong>编译器合成默认构造函数（因为定义了其他构造函数，编译器不会自动合成默认构造函数，但我们又想要编译器提供的默认构造函数，所以这是一种偷懒的语法糖）。</p><p>=default可以出现在类的内部，<strong>也可以出现在外部</strong>，内部意味着inline。</p><p>紧跟在构造函数参数列表之后在花括号之前的部分是初始值列表。它负责为新创建的对象的一个或几个数据成员赋初值。被忽略的成员则将以合成默认构造函数相同的方式隐式初始化。</p><p>C++的编译器并不都支持类内初始值。为了可移植性，最好用初始值列表。</p><h3 id="拷贝、赋值和析构"><a href="#拷贝、赋值和析构" class="headerlink" title="拷贝、赋值和析构"></a>拷贝、赋值和析构</h3><p>除了构造函数以外，类还有3个特殊的成员函数：拷贝构造、赋值操作和析构。</p><p>拷贝构造会在拷贝初始化变量和值传递方式传递或返回一个对象时被调用。</p><p>赋值操作则在对类对象使用赋值运算符时会被调用。</p><p>而析构函数则在对象被销毁时被调用。</p><p>与构造函数类似，如果不去定义这3个成员，编译器也会默认合成。关于这一议题，后面第13章会单独讲解。</p><h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><p>C++用访问说明符加强了类的封装性：</p><ul><li>定义在public说明符之后的成员在整个程序内都可以被访问，<strong>public成员定义类的接口</strong>。</li><li>定义在private说明符之后的成员<strong>仅可以被类的内部成员函数访问</strong>，外部代码无法访问，private封装了类的实现细节。</li><li>struct的默认访问权限是public，class的默认访问权限是private。</li></ul><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>加上了权限之后，一些外部接口函数就无法访问类的private成员，这种情况要么提供public接口，要么就使用友元。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sales_data</span>&#123;</span><br><span class="hljs-function"><span class="hljs-keyword">friend</span> Sales_data <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Sales_data&amp;, <span class="hljs-keyword">const</span> Sales_data&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> std::istream &amp;<span class="hljs-title">read</span><span class="hljs-params">(std::istream&amp;, Sales_data&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> std::ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(std::ostream&amp;, <span class="hljs-keyword">const</span> Sales_data&amp;)</span></span>;<br>  ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>friend关键字用于表示这三个函数是类Sales_data的友元函数，如此这三个函数可以访问类的private成员。friend相当于白名单，除了友元函数以外，<strong>还可以定义友元类</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span>&#123;</span><br>  <span class="hljs-comment">// Window_mgr的成员可以访问Screen类的private成员</span><br><span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Window_mgr</span>;</span><br>  ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>每个类负责控制自己的友元类和友元函数。</p><p>有时候整个类作为友元比较冒险，可以只对类的几个成员函数声明为友元：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span>&#123;</span><br>  <span class="hljs-comment">// Window_mgr::clear必须在Screen类之前被声明</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Window_mgr::clear</span><span class="hljs-params">(ScreenIndex)</span></span>;<br>  ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>但是要注意声明的前后关系</strong></p><h2 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h2><p>在外部定义的成员函数也可以通过inline关键字来显式内联。</p><p>成员函数也是可以重载的。</p><h3 id="可变数据成员"><a href="#可变数据成员" class="headerlink" title="可变数据成员"></a>可变数据成员</h3><p>使用关键字<code>mutable</code>可以声明可变数据成员（mutable data member）。可变数据成员永远不会是const的，即使它在const对象内。因此const成员函数可以修改可变成员的值。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span> </span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">some_member</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-keyword">size_t</span> access_ctr;  <span class="hljs-comment">// may change even in a const object</span><br>    <span class="hljs-comment">// other members as before</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Screen::some_member</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function"></span>&#123;<br>    ++access_ctr;   <span class="hljs-comment">// keep a count of the calls to any member function</span><br>    <span class="hljs-comment">// whatever other work this member needs to do</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="类内初始值花括号初始化"><a href="#类内初始值花括号初始化" class="headerlink" title="类内初始值花括号初始化"></a>类内初始值花括号初始化</h3><p>类内初始值除了=初始化形式以外，还可以用花括号形式（C++11）：</p><p>（对screens对象列表初始化）（类内初始值的两种初始化方式）</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Window_mgr</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">//默认情况下，一个Window_mgr包含一个标准尺寸的空白Screen</span><br>  std::vector&lt;Screen&gt; screens&#123;<span class="hljs-built_in">Screen</span>(<span class="hljs-number">24</span>, <span class="hljs-number">80</span>, <span class="hljs-string">&#x27; &#x27;</span>)&#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="为什么要返回-this"><a href="#为什么要返回-this" class="headerlink" title="为什么要返回*this"></a>为什么要返回*this</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//返回引用成为左值</span><br>myScreen.<span class="hljs-built_in">move</span>(<span class="hljs-number">4</span>,<span class="hljs-number">0</span>).<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;#&#x27;</span>);<br><span class="hljs-comment">//返回的是拷贝,只能改变临时副本</span><br>Screen temp = myScreen.<span class="hljs-built_in">move</span>(<span class="hljs-number">4</span>,<span class="hljs-number">0</span>);<br>temp.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;#&#x27;</span>)<br></code></pre></div></td></tr></table></figure><p><strong>const成员函数</strong>以引用形式返回*this，则它的返回类型将是<strong>常量引用</strong>。</p><h3 id="成员函数可以基于const重载"><a href="#成员函数可以基于const重载" class="headerlink" title="成员函数可以基于const重载"></a>成员函数可以基于const重载</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">Screen &amp;<span class="hljs-title">display</span><span class="hljs-params">(std::ostream &amp;os)</span></span><br><span class="hljs-function">    </span>&#123;<span class="hljs-built_in">do_display</span>(os);<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125; <br>    <span class="hljs-comment">//非常量版本调用do_display时，this指针将隐式的从指向非常量的指针转换成指向常量的指针</span><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> Screen &amp;<span class="hljs-title">display</span><span class="hljs-params">(std::ostream &amp;os)</span> <span class="hljs-keyword">const</span> </span><br><span class="hljs-function">    </span>&#123;<span class="hljs-built_in">do_display</span>(os);<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">do_display</span><span class="hljs-params">(std::ostream &amp;os)</span> <span class="hljs-keyword">const</span> </span>&#123;os &lt;&lt; contents;&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>因为<strong>非常量版本的函数对于常量对象是不可用的</strong>，所以只能在常量对象上调用const成员函数。尽管明面上参数列表相同，<strong>但实际上隐式的this指针类型是不同的，区别在于是否有底层const</strong>。</p><p>当我们在对象上调用display()时，该对象是否const决定了应该调用display的哪个版本。</p><h3 id="友元-1"><a href="#友元-1" class="headerlink" title="友元"></a>友元</h3><ul><li><p>允许特定的<strong>非成员函数</strong>访问一个类的<strong>私有成员</strong>.</p></li><li><p>友元的声明以关键字 <code>friend</code>开始。</p><p><code>friend Sales_data add(const Sales_data&amp;, const Sales_data&amp;);</code>表示非成员函数<code>add</code>可以访问类的非公有成员。</p></li><li><p>通常将友元声明成组地放在<strong>类定义的开始或者结尾</strong>。</p></li><li><p>类之间的友元：</p><p>如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。</p></li><li><p><strong>友元不具有传递性</strong></p></li><li><p>声明重载函数为友元必须指明参数</p></li><li><p>可以把另一个类的公有成员函数声明为自己的友元函数。</p><p>必须按照三步走，很容易出错。（<strong>前向声明、不完全类型</strong>）</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span> <span class="hljs-comment">//提前引用声明，因为友元A中要用到B，必须让编译器知道B为一个类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">disp</span><span class="hljs-params">(B &amp;b)</span></span>;<span class="hljs-comment">//只能声明不能定义，因为类B内部还没有定义</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">A::disp</span><span class="hljs-params">(B &amp;b)</span></span>;  <span class="hljs-comment">//声明友元函数</span><br>&#125;;<br><span class="hljs-comment">//这时候才可以去定义友元函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">A::disp</span><span class="hljs-params">(B &amp;b)</span></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;B::val=&quot;</span>&lt;&lt;b.val&lt;&lt;endl;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><ul><li>每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由引用、对象、指针使用成员访问运算符来访问。</li><li>函数的<strong>返回类型</strong>通常在函数名前面，因此<strong>当成员函数定义在类的外部</strong>时，返回类型中使用的名字都位于类的作用域之外。</li><li>如果成员使用了外层作用域中的某个名字，而该名字代表一种<strong>类型</strong>，则类不能在之后重新定义该名字。</li><li>类中的<strong>类型名定义</strong>都要放在一开始。</li></ul><h2 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a>构造函数再探</h2><h3 id="构造函数和初始化列表"><a href="#构造函数和初始化列表" class="headerlink" title="构造函数和初始化列表"></a>构造函数和初始化列表</h3><p>初始值列表提供了成员初始化的机会，如果在构造函数体内对成员进行赋值，那执行的就是赋值操作了（**==区分初始化和赋值==*），对于类类型来说，<strong>初始化和赋值操作可能行为不一致</strong>。</p><p>如果成员是<strong>const、引用，或者是某种未定义默认构造函数的类类型</strong>，==必须==在初始值列表中将其初始化。（因为const不能用赋值来初始化）</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConstRef</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ConstRef</span>(<span class="hljs-keyword">int</span> ii);<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci;<br>    <span class="hljs-keyword">int</span> &amp;ri;<br>&#125;;<br><br>ConstRef::<span class="hljs-built_in">ConstRef</span>(<span class="hljs-keyword">int</span> ii): <span class="hljs-built_in">i</span>(ii), <span class="hljs-built_in">ci</span>(ii), <span class="hljs-built_in">ri</span>(i) &#123; &#125; <br></code></pre></div></td></tr></table></figure><p>最好令构造函数初始值的顺序与成员声明的<strong>顺序一致</strong>，并且尽量避免使用某些成员初始化其他成员。因为类成员的初始化顺序与它们在类定义中出现的顺序一致。</p><p>如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。</p><h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>C++11引入了委托构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sales_data</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-comment">//非委托构造函数使用对应实参初始化成员</span><br>  <span class="hljs-built_in">Sales_data</span>(std:string s, <span class="hljs-keyword">unsigned</span> cnt, <span class="hljs-keyword">double</span> price):<span class="hljs-built_in">bookNo</span>(s), <span class="hljs-built_in">units_sold</span>(cnt), <span class="hljs-built_in">revenue</span>(cnt*price)&#123;&#125; <span class="hljs-comment">//该构造函数函数体为空</span><br>  <span class="hljs-comment">//其余构造函数全都委托给另一个构造函数</span><br>  <span class="hljs-built_in">Sales_data</span>():<span class="hljs-built_in">Sales_data</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)&#123;&#125;  <span class="hljs-comment">//默认构造函数委托给第一个constructor</span><br>  <span class="hljs-built_in">Sales_data</span>(std::string s):<span class="hljs-built_in">Sales_data</span>(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)&#123;&#125;<br>  <span class="hljs-built_in">Sales_data</span>(std::istream &amp;is):<span class="hljs-built_in">Sales_data</span>()&#123;<span class="hljs-built_in">read</span>(is, *<span class="hljs-keyword">this</span>);&#125;<br>    <span class="hljs-comment">//委托给默认构造函数，默认构造函数委托给第一个constructor</span><br>  ...<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数值被依次执行，然后控制权才会交还给委托者的函数体（例子中恰好函数体为空）。</p><h4 id="默认构造函数的作用"><a href="#默认构造函数的作用" class="headerlink" title="默认构造函数的作用"></a>默认构造函数的作用</h4><p>默认初始化的发生情况：</p><ul><li>在块作用域内不使用初始值定义非静态变量或数组。</li><li>类本身含有类类型的成员且使用合成默认构造函数。</li><li>类类型的成员没有在构造函数初始值列表中显式初始化。</li></ul><p>值初始化的发生情况：</p><ul><li>数组初始化时提供的初始值数量少于数组大小。</li><li>不使用初始值定义局部静态变量。</li><li>通过<code>T()</code>形式（<em>T</em>为类型）的表达式显式地请求值初始化。</li></ul><p>类必须包含一个默认构造函数以便在上述情况下使用。</p><h3 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h3><p>如果构造函数<strong>只接受一个实参</strong>，则它实际上<strong>定义了转换为此类类型的隐式转换机制</strong>（从构造函数的参数类型向类类型隐式转换）。这种构造函数被称为转换构造函数（converting constructor）。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">string null_book = <span class="hljs-string">&quot;9-999-99999-9&quot;</span>;<br><span class="hljs-comment">// 构造一个临时的Sales_data对象</span><br><span class="hljs-comment">// 该对象的units_sold和revenue等于0，bookNo等于null_book</span><br>item.<span class="hljs-built_in">combine</span>(null_book);<br></code></pre></div></td></tr></table></figure><p>类类型转换<strong>只允许一步</strong>，这意味着：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//错误，需要两次转换</span><br>item.<span class="hljs-built_in">combine</span>(<span class="hljs-string">&quot;9-999-99999-9&quot;</span>);<br><span class="hljs-comment">//正确，显式转换为string，隐式转为Sales_data</span><br>item.<span class="hljs-built_in">combine</span>(<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;9-999-99999-9&quot;</span>));<br></code></pre></div></td></tr></table></figure><p><strong>只有一个参数的构造函数，或者构造函数有n个参数，但有n-1个参数提供了默认值，这样的情况才能进行类型转换。</strong></p><p>如果构造函数声明为<strong>explicit</strong>，就可以抑制隐式的类类型转换。同样的，需要多个实参的构造函数不能执行隐式转换，所以无须将这些构造函数指定为explicit的。</p><p>explicit关键字只允许出现在类内的构造函数声明处，不允许在类外部定义函数时重复。</p><h4 id="c-的初始化类型"><a href="#c-的初始化类型" class="headerlink" title="c++的初始化类型"></a>c++的初始化类型</h4><table><thead><tr><th>初始化类型</th><th>举例</th></tr></thead><tbody><tr><td>默认初始化</td><td>例如<code>T t;</code></td></tr><tr><td>直接（非列表）初始化</td><td>例如<code>T t(args...);</code></td></tr><tr><td>复制（非列表）初始化</td><td>例如<code>T t = init;</code>）</td></tr><tr><td>直接列表初始化</td><td>例如<code>T t&#123; args... &#125;;</code></td></tr><tr><td>复制列表初始化</td><td>例如<code>T t = &#123; args... &#125;;</code></td></tr></tbody></table><p><a href="https://www.zhihu.com/question/403578855/answer/1306943217">为什么C++的初始化规则这么复杂？ - d41d8c的回答 - 知乎</a> </p><h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><p>使用关键字<code>static</code>可以声明类的静态成员。静态成员可以是public的或是private的，类型可以是常量、引用、指针类类型等。静态成员<strong>存在于任何对象之外</strong>，对象中<strong>不包含与静态成员相关的数据</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span> </span>&#123; amount += amount * interestRate; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">rate</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> interestRate; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rate</span><span class="hljs-params">(<span class="hljs-keyword">double</span>)</span></span>;<br>    <br><span class="hljs-keyword">private</span>:<br>    std::string owner;<br>    <span class="hljs-keyword">double</span> amount;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> interestRate;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">initRate</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure><blockquote><p>静态成员实际上是全局变量，只不过通过语法的封装，让他和所属类建立了耦合的关系。</p></blockquote><p>每个<code>static</code>数据成员<strong>是与类关联的对象</strong>，<strong>并不与该类的对象相关联</strong>。</p><p>由于静态成员不与任何对象绑定，因此静态成员函数不能声明为const，也不能在静态成员函数内使用this指针。</p><p>用户代码可以使用作用域运算符访问静态成员，也可以通过类对象、引用或指针访问。类的成员函数可以直接访问静态成员。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//成员函数无需作用域运算符即可使用静态成员</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span></span>&#123;amount += amount * interestRate;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">rate</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> interestRate;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rate</span><span class="hljs-params">(<span class="hljs-keyword">double</span>)</span></span>;<br><span class="hljs-keyword">private</span>:<br>  std::string owner;<br>  <span class="hljs-keyword">double</span> amount;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> interestRate;<br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">initRate</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">double</span> r;<br>r = Account::<span class="hljs-built_in">rate</span>(); <span class="hljs-comment">//用户代码可以使用作用域运算符访问静态成员</span><br><span class="hljs-comment">//可以通过类对象、引用或指针访问</span><br>Account ac1;<br>Account *ac2 = &amp;ac1;<br>r = ac1.<span class="hljs-built_in">rate</span>();<br>r = ac2-&gt;<span class="hljs-built_in">rate</span>();<br></code></pre></div></td></tr></table></figure><p>在类外部定义静态成员时，<strong>不能重复static关键字</strong>，其只能用于类内部的声明语句。（在类外部定义时不用加<code>static</code>）</p><p>由于静态数据成员不属于类的任何一个对象，因此它们并不是在创建类对象时被定义的。通常情况下，<strong>不应该在类内部初始化静态成员</strong>。而<strong>必须在类外部定义并初始化每个静态成员</strong>。一个静态成员<strong>只能被定义一次</strong>。一旦它被定义，就会一直存在于程序的整个生命周期中。</p><blockquote><p>想要保证对象只被定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一个文件中</p></blockquote><p>如果一定要<strong>在类内部定义</strong>，则要求<strong>必须是字面值常量类型</strong>的<code>constexpr</code></p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>侯捷C++系列(1)</title>
    <link href="/2021/09/12/c++/%E4%BE%AF%E6%8D%B7c++%20(1)/"/>
    <url>/2021/09/12/c++/%E4%BE%AF%E6%8D%B7c++%20(1)/</url>
    
    <content type="html"><![CDATA[<h2 id="1-inline内联函数"><a href="#1-inline内联函数" class="headerlink" title="1.inline内联函数"></a>1.inline内联函数</h2><p><img src="https://i.imgur.com/CjYftqD.png"></p><p>1.inline关键字用来定义一个类的内联函数，引入它的主要原因是用它替代C中表达式形式的宏定义,<strong>解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题</strong>。</p><p>2.inline的使用是有所限制的，inline只适合涵数体内代码简单的涵数使用，不能包含复杂的结构控制语句例如while、switch，并且不能内联函数本身不能是直接递归函数（即，自己内部还调用自己的函数）。</p><p>3.inline函数仅仅是一个对编译器的建议，所以<strong>最后能否真正内联，得看编译器</strong>，它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已。</p><p>4.定义在类中的成员函数<strong>缺省都是内联</strong>的，如果在类定义时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上inline，<strong>否则</strong>就认为不是内联的。</p><h2 id="2-构造函数初始化"><a href="#2-构造函数初始化" class="headerlink" title="2.构造函数初始化"></a>2.构造函数初始化</h2><p><img src="https://i.imgur.com/70WWLCi.png"></p><p>成员变量再构造函数中初始化中使用”:”函数方式性能比直接在构造函数中赋值要快，建议使用这种方式。</p><p>why？</p><ul><li><strong>初始化一个类时，调用构造函数首先执行初始化列表，再执行构造函数函数体内的语句。</strong></li><li><strong>在执行到构造函数函数体内的语句时，变量已经初始化（可能值未定义），产生了消耗。而且const类型的变量只有初始化时可以赋值，在函数体内无法赋值。</strong></li></ul><h2 id="3-构造函数重载注意事项"><a href="#3-构造函数重载注意事项" class="headerlink" title="3.构造函数重载注意事项"></a>3.构造函数重载注意事项</h2><p><img src="https://i.imgur.com/OZzGtLc.png"></p><p>黄色标注的构造函数定义将出现问题，如果该函数与上面构造函数同时出现，在无参初始化该类对象时将产生冲突，因为第一个构造函数已经有参数默认初始化列表了，定义该类对象时可以不加入参数，这就产生了冲突。</p><h2 id="4-常量成员函数"><a href="#4-常量成员函数" class="headerlink" title="4.常量成员函数"></a>4.常量成员函数</h2><p><img src="https://i.imgur.com/NWsQ5HK.png"></p><p>在一个类中，如果成员函数中没有改变成员函数操作（例如get操作），那么建议在该方法声明处加入const关键字，如果不加入const关键字，那么c++编译器将认为该函数可能会修改类的成员变量。这样做有个好处，如果使用者利用了const关键字定义并通过构造函数初始化了一个complex类，这个类将不能被修改，只能读取属性。当使用者调用complex的real()或者imag()方法时，如果这两个方法在定义处没有加入const关键字，那么将报错。</p><p>总结来说，成员函数用const修饰this指针，const关键字显式的告诉编译器无法改变修饰的对象，帮助检查出错。</p><h2 id="5-参数传递和返回值使用const引用"><a href="#5-参数传递和返回值使用const引用" class="headerlink" title="5.参数传递和返回值使用const引用"></a>5.参数传递和返回值使用const引用</h2><p>函数参数传递，如果不需要改变参数值，建议使用<strong>const reference减小开销</strong>。</p><p>下图之中ostream会改变，不能用const传参，返回值也不能加上const。</p><p><img src="https://i.imgur.com/fSYQbDM.png"></p><p>返回值建议使用引用，但如果返回引用的是该函数的一个指向堆局部变量指针，例如*ptr，那么不能使用引用，因为该局部变量在函数调用后就以及销毁了，引用可以认为是给当前对象换了个别名，如果当前对象已经被销毁，那么该“别名”也就失去了意义，不存在了。</p><p>当然，如下图所示，对于临时变量也不能返回引用：<br><img src="https://i.imgur.com/zCKy5kk.png"></p><h2 id="6-友元"><a href="#6-友元" class="headerlink" title="6.友元"></a>6.友元</h2><p><img src="https://i.imgur.com/72ZMZHz.png"></p><p><strong>相同类的各个实例对象互为友元</strong>，可以通过彼此的内部方法调用传入参数的内部私有成员变量。</p><h2 id="7-运算符重载this指针"><a href="#7-运算符重载this指针" class="headerlink" title="7.运算符重载this指针"></a>7.运算符重载this指针</h2><p><img src="https://i.imgur.com/UHP1Am5.png"></p><p>如上图所所示，在运算符重载过程中隐藏了this指针，该指针编译器会处理，使用者不能显式声明。</p><p>所有双目运算符都是这样。</p><h2 id="8-拷贝赋值函数"><a href="#8-拷贝赋值函数" class="headerlink" title="8.拷贝赋值函数"></a>8.拷贝赋值函数</h2><p><img src="https://i.imgur.com/B6W7jnL.png"></p><p>如上图所示，在重载“=”赋值运算符时需要检查自我赋值，原因如下：</p><p><img src="https://i.imgur.com/ymJ6YD2.png"></p><p>如果没有自我赋值检测，那么自身对象的m_data将被释放，m_data指向的内容将不存在，所以该拷贝会出问题。</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>APUE</title>
    <link href="/2021/09/05/linux%20&amp;%20unix/apue/"/>
    <url>/2021/09/05/linux%20&amp;%20unix/apue/</url>
    
    <content type="html"><![CDATA[<h1 id="0-tips"><a href="#0-tips" class="headerlink" title="0.tips"></a>0.tips</h1><h2 id="输入输出问题"><a href="#输入输出问题" class="headerlink" title="输入输出问题"></a>输入输出问题</h2><ul><li><p>在linux系统下使用printf发现有时没有立即输出，有时又能立即输出</p><p>原因是printf使用行缓冲，没有刷新缓冲区，故没有输出。</p><p><strong>缓冲区刷新的条件：</strong><br>1.进程结束。<br>2.遇到\n。<br>3.缓冲区满。<br>4.手动刷新缓冲区fflush(stdout)。</p></li></ul><h2 id="一些有用的函数"><a href="#一些有用的函数" class="headerlink" title="一些有用的函数"></a>一些有用的函数</h2><h3 id="lt-stdlib-h-gt"><a href="#lt-stdlib-h-gt" class="headerlink" title="&lt;stdlib.h&gt;"></a>&lt;stdlib.h&gt;</h3><ul><li><p>atoi(str)</p><p>用法：将字符串里的数字字符转化为整形数。返回整形值。</p><p>注意：转化时跳过前面的空格字符，直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(’/0’)才结束转换，并将结果返回。</p><p>用于转化argv[]的参数</p></li></ul><h2 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h2><ul><li>C/C++规定，一个数如果要指明它采用八进制，必须在它前面加上一个0（数字0），如：123是十进制，但0123则表示采用八进制。这就是八进制数在C、C++中的表达方法。（<strong>很多宏的掩码就是八进制与</strong>）</li></ul><h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h1><h1 id="1-1what-is-os"><a href="#1-1what-is-os" class="headerlink" title="1.1what is os"></a>1.1what is os</h1><h2 id="1-1-1内核"><a href="#1-1-1内核" class="headerlink" title="1.1.1内核"></a>1.1.1内核</h2><ul><li><p>进程线程管理</p><p>进程管理主要为linux，windows只是壳子</p></li><li><p>内存管理</p></li><li><p>设备驱动</p><p>windows  .sys文件    linux .ko文件</p></li><li><p>文件系统</p></li><li><p>中断子系统</p></li></ul><h3 id="1-1-2内核-用户态"><a href="#1-1-2内核-用户态" class="headerlink" title="1.1.2内核/用户态"></a>1.1.2内核/用户态</h3><ul><li><p>ring0/ring3    环0内核态，环3用户态</p><p>ring1/ring2暂时没用到</p></li><li><p>系统调用 内核为应用程序提供的接口   用户态-&gt;内核态</p></li><li><p>体系结构</p><p><img src="https://i.loli.net/2021/10/07/I9bfymOhG5PSKnX.png" alt="image-20211007104949635"></p><p>shell    sh/bash/csh/ksh </p><p>库函数    库函数到系统调用</p></li></ul><h2 id="1-2登录"><a href="#1-2登录" class="headerlink" title="1.2登录"></a>1.2登录</h2><h3 id="1-2-1-tty-psedo-tty"><a href="#1-2-1-tty-psedo-tty" class="headerlink" title="1.2.1 tty/psedo-tty"></a>1.2.1 tty/psedo-tty</h3><p>TTY是电传打字机Teletypewriter的缩写，在带显示屏的视频终端出现之前，TTY是最流行的终端设备</p><h3 id="1-2-2-etc-password"><a href="#1-2-2-etc-password" class="headerlink" title="1.2.2 /etc/password"></a>1.2.2 /etc/password</h3><ul><li>密码可以在etc/password看到</li><li>shadow文件</li><li>起始目录</li><li>用户id</li><li>组id</li><li>shell</li></ul><h2 id="1-3-文件"><a href="#1-3-文件" class="headerlink" title="1.3 文件"></a>1.3 文件</h2><h3 id="1-3-1-一切皆为文件"><a href="#1-3-1-一切皆为文件" class="headerlink" title="1.3.1 一切皆为文件"></a>1.3.1 一切皆为文件</h3><ul><li>目录</li><li>文本文件/二进制文件一视同仁</li><li>设备文件：字符设备、块设备、网络设备（在/dev下ll看第一位）</li><li>socket   linux与windows不同</li><li>管道、消息队列等</li></ul><h3 id="1-3-2-相对路径-绝对路径"><a href="#1-3-2-相对路径-绝对路径" class="headerlink" title="1.3.2 相对路径/绝对路径"></a>1.3.2 相对路径/绝对路径</h3><p> /    ..     .</p><h2 id="1-4-I-O"><a href="#1-4-I-O" class="headerlink" title="1.4 I/O"></a>1.4 I/O</h2><ul><li>文件描述符fd</li><li>stdin/stdout/stderr  对应0/1/2</li></ul><h2 id="1-5-进程"><a href="#1-5-进程" class="headerlink" title="1.5 进程"></a>1.5 进程</h2><ul><li><p>进程与程序的关系</p></li><li><p>进程id</p><p>windows下为4的倍数（复用原因）</p><p>linux下用ps命令查看</p></li><li><p>进程控制</p><p>fork 子进程都是由父进程fork出来的（写时复制）</p><p>exec  fork之后调用，类似windows的winexecute api</p><p>waitpid</p></li></ul><h2 id="1-6-出错处理"><a href="#1-6-出错处理" class="headerlink" title="1.6 出错处理"></a>1.6 出错处理</h2><ul><li><p>errno</p><p>windows下有geterrornumber</p></li><li><p>strerror</p></li></ul><h2 id="1-7信号"><a href="#1-7信号" class="headerlink" title="1.7信号"></a>1.7信号</h2><p>可以理解为用户层的中断，异步打断执行流</p><ul><li><p>信号的处理</p><p>系统默认处理： 忽略/中止进程</p><p>为指定信号注册处理函数</p></li></ul><p>是Linux编程重点，也容易踩坑</p><h2 id="1-8-时间"><a href="#1-8-时间" class="headerlink" title="1.8 时间"></a>1.8 时间</h2><h3 id="日历时间"><a href="#日历时间" class="headerlink" title="日历时间"></a>日历时间</h3><p>UTC</p><p>time-t</p><h3 id="进程时间"><a href="#进程时间" class="headerlink" title="进程时间"></a>进程时间</h3><p>clock_t</p><p>用户CPU时间</p><p>系统CPU时间</p><h1 id="2-UNIX标准"><a href="#2-UNIX标准" class="headerlink" title="2.UNIX标准"></a>2.UNIX标准</h1><h2 id="2-1-标准"><a href="#2-1-标准" class="headerlink" title="2.1 标准"></a>2.1 标准</h2><h3 id="ISO-C组成"><a href="#ISO-C组成" class="headerlink" title="ISO C组成"></a>ISO C组成</h3><ul><li>语法、语义</li><li>标准库</li></ul><h3 id="ISO-C历史"><a href="#ISO-C历史" class="headerlink" title="ISO C历史"></a>ISO C历史</h3><ul><li>ANSI C89</li><li>C99<ul><li>restrict</li><li>long long</li><li>单行注释</li><li>分散代码与声明</li></ul></li><li>C11</li></ul><h3 id="POSIX标准"><a href="#POSIX标准" class="headerlink" title="POSIX标准"></a>POSIX标准</h3><ul><li>提升各种应用程序在各种UNIX系统环境间的可移植性</li><li>只定义接口而非实现</li></ul><h3 id="SUS-single-UNIX-specification"><a href="#SUS-single-UNIX-specification" class="headerlink" title="SUS(single UNIX specification)"></a>SUS(single UNIX specification)</h3><ul><li>POSIX的超集</li><li>扩展了功能</li></ul><h2 id="2-2-实现"><a href="#2-2-实现" class="headerlink" title="2.2 实现"></a>2.2 实现</h2><ul><li>FreeBSD</li><li>Linux</li><li>Mac OS X</li><li>Solaris</li></ul><h2 id="2-3限制"><a href="#2-3限制" class="headerlink" title="2.3限制"></a>2.3限制</h2><h3 id="编译时限制"><a href="#编译时限制" class="headerlink" title="编译时限制"></a>编译时限制</h3><ul><li><p>ISO C</p><p>limits.h    各种最大最小值(宏内定义了，include直接用)</p><p>float.h    浮点数相关</p><p>stdio.h</p></li><li><p>POSIX 限制</p></li></ul><h3 id="运行时限制"><a href="#运行时限制" class="headerlink" title="运行时限制"></a>运行时限制</h3><p>只有运行时才能拿到，例如系统调用给出</p><ul><li>sysconf</li><li>pathconf/fpathconf</li></ul><h1 id="3-无缓冲I-O（文件IO）"><a href="#3-无缓冲I-O（文件IO）" class="headerlink" title="3. 无缓冲I/O（文件IO）"></a>3. 无缓冲I/O（文件IO）</h1><h2 id="3-1-文件描述符fd"><a href="#3-1-文件描述符fd" class="headerlink" title="3.1 文件描述符fd"></a>3.1 文件描述符fd</h2><ul><li><p>所有打开文件都由fd引用，fd为非负int（出错时为负）</p></li><li><p>类似windows的HANDLE</p></li><li><p>STDIN_FILENO  STDOUT_FILENO  STDERR_FILENO</p></li><li><p>OPEN_MAX（文件打开的极限值）</p></li><li><p><img src="https://i.loli.net/2021/10/08/Uto3clnhVJEy12D.png" alt="image-20211008102820346"></p></li><li><p><img src="https://i.loli.net/2021/10/08/gsyILjapZ29F7t6.png" alt="image-20211008103035519"></p><ul><li><strong>进程各自维护自己的文件描述符表，文件描述符表记录文件描述符标志，和一个指向文件表项的指针</strong></li><li><strong>文件表项由内核为每一个打开的文件维护，包括文件状态标志、当前文件偏移、以及指向v结点的指针</strong><ul><li><strong>==不同进程打开同一个文件、同一进程调用多次open同一个文件==并不共享file table entry（文件表项）</strong> 因为各自的偏移可能不同，也可以理解为调用一次open打开一个文件表项，而复制fd与之无关<ul><li>但是fork出来的子进程的fd指向同一个文件表项（因为文件描述符表也copy，p397）</li></ul></li></ul></li></ul></li><li><p>/dev/fd</p><p>/prof/self/fd</p></li></ul><h2 id="3-2-API"><a href="#3-2-API" class="headerlink" title="3.2 API"></a>3.2 API</h2><h3 id="open-openat-create"><a href="#open-openat-create" class="headerlink" title="open/openat/create"></a>open/openat/create</h3><ul><li><p>oflag    <strong>文件状态标志</strong></p><ul><li><p>O_RDONLY    O_WRONLY    O_RDWR</p><p>必须指定且互斥</p></li><li><p>O_APPEND    O_CLOEXEC    O_CREAT    O_DIRECTORY    O_EXCL    O_SYNC    O_DSYNC    O_TRUNC</p></li><li><p>O_CREAT | O_EXCL 配合测试创建文件的原子性</p></li></ul></li><li><p>openat的path可以为相对路径</p></li><li><p>creat只写创建，想要创建写之后再读必须close之后再open，用open实现：</p><p>open(path, O_RDWR | O_CREAT | O_TRUNC, mode)</p></li></ul><h3 id="close"><a href="#close" class="headerlink" title="close"></a>close</h3><ul><li><p>会关闭记录锁</p></li><li><p>进程终止，内核会自动关闭文件对象</p><p>RAII的思想</p></li></ul><h3 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h3><ul><li>当前文件偏移量</li><li>文件空洞</li></ul><h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><ul><li>返回值 &lt; 待读字节数的情景<ul><li>eof</li><li>终端设备/行缓冲</li><li>管道/FIFO</li><li>中断</li></ul></li></ul><h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><ul><li>返回值 &lt; 待写字节数的情景<ul><li>磁盘满</li><li>超过了给定进程的文件长度限制</li></ul></li></ul><h3 id="pread-pwrite"><a href="#pread-pwrite" class="headerlink" title="pread/pwrite"></a>pread/pwrite</h3><p>原子lseek + read/write</p><h3 id="dup-dup2"><a href="#dup-dup2" class="headerlink" title="dup/dup2"></a>dup/dup2</h3><ul><li><img src="https://i.loli.net/2021/10/08/I9dk2Rxzu4bLwXe.png" alt="image-20211008212224736"></li><li>新描述符的FD_CLOEXEC总是被清除 （即fd flag）</li><li>dup(fd) = fcntl(fd, F_DUPFD, 0);</li><li>dup2(fd) = close(fd2); fcntl(fd, F_DUPFD, fd2); //且为<strong>原子操作</strong></li><li>dup 和 fcntl 的 errno 不同</li></ul><h3 id="sync-fsync-fdatasync"><a href="#sync-fsync-fdatasync" class="headerlink" title="sync/fsync/fdatasync"></a>sync/fsync/fdatasync</h3><ul><li>内核维护高速缓存</li><li>延迟写</li><li>update守护进程周期性调用sync</li></ul><h3 id="fcntl（重点）"><a href="#fcntl（重点）" class="headerlink" title="fcntl（重点）"></a>fcntl（重点）</h3><p>#include&lt;fcntl.h&gt;</p><p><strong>int fcntl(int fd, int cmd, … );</strong>  </p><ul><li><p>复制一个已有的描述符</p><ul><li>F_DUPFD/F_DUPFD_CLOEXEC</li></ul></li><li><p>获取/设置文件描述符标志**(fd flag)**</p><ul><li><p>F_GETFD/F_SETFD</p></li><li><p>仅有的就是FD_CLOEXEC标志</p><p>fcntl(fd, F_SETFD, 1);    默认为0，即不关闭</p></li></ul></li><li><p>获取/设置文件状态标志</p><ul><li><p>F_GETFL/F_SETFL</p><p>==注意GETFL与GETFD的区别==</p></li></ul></li><li><p>获取/设置异步I/O所有权</p><ul><li>F_GETOWN/F_SETOWN</li></ul></li><li><p>获取/设置记录锁</p><ul><li>F_GETLK/F_SETLK/F_SETLKW</li></ul></li></ul><h3 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h3><ul><li><p>设备驱动</p><p>某个特定操作的接口</p></li><li><p>类比于windows的 DeviceControl</p><p>应用程序到设备驱动的万用接口</p></li></ul><h1 id="4-文件和目录"><a href="#4-文件和目录" class="headerlink" title="4. 文件和目录"></a>4. 文件和目录</h1><h2 id="4-1-struct-stat"><a href="#4-1-struct-stat" class="headerlink" title="4.1 struct stat"></a>4.1 struct stat</h2><p>POSIX标准 + XSI扩展定义的字段</p><p>描述一个特定文件相关的信息</p><h3 id="linux下的struct-stat"><a href="#linux下的struct-stat" class="headerlink" title="linux下的struct stat"></a>linux下的struct stat</h3><ul><li><p>st_mode</p><ul><li><p>文件类型</p><table><thead><tr><th>文件类型</th><th>宏</th></tr></thead><tbody><tr><td>普通文件 regular file</td><td>S_ISREG()</td></tr><tr><td>目录文件 directory file</td><td>S_ISDIR()</td></tr><tr><td>符号链接 symbolic link</td><td>S_ISLINK()</td></tr><tr><td>块特殊文件 block special file</td><td>S_ISCHR()</td></tr><tr><td>字符特殊文件 character special file</td><td>S_ISBLK()</td></tr><tr><td>FIFO 命名管道</td><td>S_ISFIFO()</td></tr><tr><td>socket</td><td>S_ISSOCK()</td></tr><tr><td>消息队列</td><td>S_TYPEISMQ()</td></tr><tr><td>信号量</td><td>S_TYPEISEM()</td></tr><tr><td>共享内存</td><td>S_TYPEISSHM()</td></tr></tbody></table></li><li><p>mode</p><p>set-user-id bit            S_ISUID</p><p>set-group-id bit         S_ISGID</p><p>进程关联ID：</p><ol><li>实际用户/组ID</li><li>有效用户/组ID  附属组ID</li></ol></li><li><p>文件和目录的权限位</p><ul><li><code>S_ISUID</code>：执行时设置用户ID</li><li><code>S_ISGID</code>：执行时设置组ID</li><li><code>S_ISVTX</code>：粘着位</li><li><code>S_IRWXU</code>：用户读、写和执行</li><li><code>S_IRUSR</code>：用户读</li><li><code>S_IWUSR</code>：用户写</li><li><code>S_IXUSR</code>：用户执行</li><li><code>S_IRWXG</code>：组读、写和执行</li><li><code>S_IRGRP</code>：用户读</li><li><code>S_IWGRP</code>：用户写</li><li><code>S_IXGRP</code>：用户执行</li><li><code>S_IRWXO</code>：其他读、写和执行</li><li><code>S_IROTH</code>：用户读</li><li><code>S_IWOTH</code>：用户写</li><li><code>S_IXOTH</code>：用户执行</li></ul><p><img src="https://i.loli.net/2021/10/10/2q7eFnO8j6xHNyY.png" alt="image-20211010161123024"></p></li><li><p>鉴权流程</p></li></ul></li></ul><h2 id="4-2-文件系统"><a href="#4-2-文件系统" class="headerlink" title="4.2 文件系统"></a>4.2 文件系统</h2><h3 id="VFS"><a href="#VFS" class="headerlink" title="VFS"></a>VFS</h3><ul><li>superblock</li><li>incode<ul><li>与文件一一对应，相当于身份证号</li><li>包含文件的元数据，<strong>不包含名称</strong></li><li>内存中的inode和磁盘中的inode</li><li>名称-&gt;inode-&gt;disk block</li></ul></li><li>dentry<ul><li>文件的逻辑属性</li><li>一个dentry对应一个inode</li><li>多个dentry可能对应一个inode(硬链接/软链接)</li></ul></li><li>file object</li></ul><h2 id="4-3-API"><a href="#4-3-API" class="headerlink" title="4.3 API"></a>4.3 API</h2><h3 id="状态相关"><a href="#状态相关" class="headerlink" title="状态相关"></a>状态相关</h3><ul><li><p>stat / fstat / statat / lstat</p></li><li><p>ls - l命令</p><p>注意是否跟踪符号链接</p></li></ul><h3 id="权限相关"><a href="#权限相关" class="headerlink" title="权限相关"></a>权限相关</h3><ul><li><p>access / faccessat</p><p>探测文件是否存在</p><p><strong>以实际用户</strong>ID和实际组ID测试访问能力</p><p>faccessat提供了 AT_EACCESS  和 AT_SYMLINK_NOFOLLOW</p></li><li><p>umask</p><p>创建新目录或文件时，屏蔽字中置1的权限都会被关闭</p><p>区分umask命令</p></li><li><p>chmod / fchmod / fchmodat</p><ul><li>S_ISUID / S_ISGID</li><li>S_IRWXU / S_IRWXG / S_IRWXO</li><li>S_ISVTX(粘着位在linux无效)</li></ul></li><li><p>chown / fchown / fchownat / lchown</p><p>chown命令</p><p>注意符号链接的处理</p></li></ul><h3 id="变更相关"><a href="#变更相关" class="headerlink" title="变更相关"></a>变更相关</h3><ul><li><p>truncate / ftruncate</p><p>截断/扩充</p></li><li><p>link / linkat</p></li><li><p>unlink / unlinkat</p><p>用于确保临时文件被删除</p><p>标准库的remove</p></li><li><p>rename / renameat</p><ul><li>oldname 非目录<ul><li>newname存在</li><li>newname不存在</li></ul></li><li>oldname 为目录<ul><li>newname 存在</li><li>newname 不存在</li></ul></li><li>符号链接</li><li>. 和 .. 不允许</li></ul></li><li><p>symlink / symlinkat</p></li><li><p>readlink / readlinkat</p><p>open的局限：不能打开link本身</p></li><li><p>mkdir / mkdirat</p></li><li><p>rmdir</p></li></ul><h3 id="控制相关"><a href="#控制相关" class="headerlink" title="控制相关"></a>控制相关</h3><ul><li><p>opendir /  fopendir </p><p>readdir / rewinddir / closedir / telldir / seekdir </p><p>类比文件/标准I/O的接口</p></li><li><p>chdir / fchdir</p></li><li><p>getcwd</p></li></ul><h3 id="时间相关"><a href="#时间相关" class="headerlink" title="时间相关"></a>时间相关</h3><ul><li>futimens</li><li>utimensat</li><li>utimes</li></ul><h1 id="5-标准I-O"><a href="#5-标准I-O" class="headerlink" title="5.标准I/O"></a>5.标准I/O</h1><p><strong>即ISO C标准I/O</strong></p><h2 id="5-1-流-stream"><a href="#5-1-流-stream" class="headerlink" title="5.1 流 (stream)"></a>5.1 流 (stream)</h2><ul><li><p>无缓冲I/O围绕fd展开</p></li><li><p>有缓冲I/O围绕stream展开</p></li><li><p>流的定向(stream’s orientation)</p><ul><li><p>单字节 字节定向</p><p>byte flow                 ASCII</p></li><li><p>多字节 宽定向</p><p>wide bytes flow      国际字符集  </p></li></ul></li><li><p>进程预定义流</p><p>stdin / stdout /stderr</p></li><li><p>流缓冲</p><ul><li><p>意义</p></li><li><p>类型</p><p>全缓冲：填满I/O缓冲区后才进行实际I/O操作</p><p>行缓冲：</p><ol><li><p>输入输出遇到换行符时执行I/O操作</p><div class="hljs code-wrapper"><pre><code>            2. 由于每行缓冲区固定，缓冲区满没有遇到换行符也要执行I/O            3.  任何时候只要通过标准lO库，要求从一个不带缓冲的流或者一个行缓冲的流(从内核请求数据的时机）得到输入数据，那么就会冲洗所有行缓冲输出流。(即要缓冲输入，先冲洗输出缓冲)            4. 指向终端的流通常使用行缓冲</code></pre></div></li></ol><p>不带缓冲：不进行缓冲</p></li></ul></li><li><p>stdin 和 stdout 并不指向交互设备时，才能使全缓冲类型 (通过重定向)</p><p>如果指向终端设备，则是行缓冲的，否则是全缓冲的</p></li><li><p><strong>stderr绝不能时全缓冲的，一般是不带缓冲</strong></p><p>表现为buffersize = 1</p></li></ul><h2 id="5-2-FILE对象"><a href="#5-2-FILE对象" class="headerlink" title="5.2 FILE对象"></a>5.2 FILE对象</h2><ul><li>不同平台的实现不同</li><li>linux<ul><li>fd    用于实际I/O</li><li>buffer指针  buffer尺寸  buffer当前字符数</li><li>出错标志  文件结束标志</li></ul></li></ul><h2 id="5-3-API"><a href="#5-3-API" class="headerlink" title="5.3 API"></a>5.3 API</h2><ul><li><p>fwide</p></li><li><p>setbuf / setvbuf    p118</p></li><li><p>fflush</p></li><li><p>fopen / freopen / fdopen</p></li><li><p>fclose</p></li><li><p>读写</p><ul><li>getc / fgetc /  getchar / ungetc</li><li>putc / fputc / putchar</li><li>fgets / (gets)</li><li>fputs / (puts)</li><li>fread / fwrite</li></ul></li><li><p>ferror / feof / clearerr</p></li><li><p>ftell / ftello / fseek / fseeko / rewind</p></li><li><p>fgetpos / fsetpos</p></li><li><p>格式化输入输出</p><ul><li>printf / fprintf / dprintf / sprintf / snprintf</li><li>scanf / fscanf / sscanf</li></ul></li><li><p>fileno</p><p>标准I/O到无缓冲I/O的adapter</p></li><li><p>tmpnam / tmpfile  临时文件</p></li><li><p>fmemopen  内存流</p></li></ul><h1 id="6-系统信息"><a href="#6-系统信息" class="headerlink" title="6. 系统信息"></a>6. 系统信息</h1><h2 id="6-1-数据文件"><a href="#6-1-数据文件" class="headerlink" title="6.1 数据文件"></a>6.1 数据文件</h2><ul><li><p>/etc/passwd</p><ul><li><p>pwd.h中定义了struct passwd结构</p><p>可以任意由用户读取</p></li><li><p>是ASCII文件，可以用标准I/O读取，但是效率太低</p><p>因此系统提供API接口</p></li></ul></li><li><p>/etc/group</p><ul><li>grp.h中定义了struct group结构</li></ul></li><li><p>/etc/shadow</p><ul><li><p>经单向加密算法处理过的用户口令副本</p></li><li><p>shadow.h中定义了struct spwd</p></li><li><p>阴影口令文件 /etc/shadow 不应该由一般用户读取</p><p>仅有少数几个程序需要访问加密口令,如login, passwd, 这些程序通常是设定 set-user-ID为root的程序</p></li></ul></li></ul><h2 id="6-2-API"><a href="#6-2-API" class="headerlink" title="6.2 API"></a>6.2 API</h2><h3 id="6-2-1-数据文件"><a href="#6-2-1-数据文件" class="headerlink" title="6.2.1 数据文件"></a>6.2.1 数据文件</h3><ul><li>getpwuid / getpwnam</li><li>getpwent / setpwent / endpwent</li><li>getspnam / getspent / setspent / endspent</li><li>getgrgid / getgenam</li><li>getgrent / setgrent / endgrent</li><li>getgroups / setgroups / initgroups</li></ul><p><strong>返回的结构都是一个静态变量，会覆盖前一次的结果，数据文件的API都提供了 get / set / end 组合技</strong></p><h3 id="6-2-2-系统信息"><a href="#6-2-2-系统信息" class="headerlink" title="6.2.2 系统信息"></a>6.2.2 系统信息</h3><ul><li><p>uname</p><p>struct utsname</p></li><li><p>gethostname</p></li><li><p>time</p><p>日历时间</p></li><li><p>clock_gettime</p><p>获取指定的时钟类型的时间</p><ol><li>实时系统时间</li><li>不带负跳数的实时系统时间</li><li>调用进程的CPU时间</li><li>调用线程的CPU时间</li></ol></li><li><p>clock_getres</p><p>时间精度调整</p></li><li><p>clock_settime</p><p>对特定的时钟设置时间（某些需要权限）</p></li><li><p>gettimeofday (deprecate)</p></li><li><p>gmtime / localtime</p><p>日历时间转换为struct tm 结构</p></li><li><p>mktime</p></li><li><p>strftime / strftime_l</p><p>格式化时间，打印字符串</p></li><li><p>strptime</p></li></ul><h1 id="7-进程环境"><a href="#7-进程环境" class="headerlink" title="7. 进程环境"></a>7. 进程环境</h1><h2 id="7-1概念"><a href="#7-1概念" class="headerlink" title="7.1概念"></a>7.1概念</h2><h3 id="1进程终止"><a href="#1进程终止" class="headerlink" title="1进程终止"></a>1进程终止</h3><ul><li><p>从main返回</p><p>exit(main(argc, argv))</p><p>return 和 exit(0) 并无区别</p></li><li><p>exit()库函数</p></li><li><p>_exit / _Exit 系统调用</p></li><li><p>这两者区别： 不同标准定义 、是否做了清理工作</p></li><li><p><img src="https://i.loli.net/2021/10/12/6ILPQsK8ROXj5CF.png" alt="image-20211012235649755"></p></li></ul><h3 id="2-终止处理程序"><a href="#2-终止处理程序" class="headerlink" title="2 终止处理程序"></a>2 终止处理程序</h3><ul><li><p>atexit函数</p><p>事先声明，反向调用，类似栈</p></li></ul><h3 id="3-命令行参数"><a href="#3-命令行参数" class="headerlink" title="3 命令行参数"></a>3 命令行参数</h3><ul><li><p>argc  argv</p></li><li><p>envp   环境表</p><p>全局变量   environ</p><p><img src="https://i.loli.net/2021/10/12/qnl1Hc9s4xKOfUY.png" alt="image-20211012235941033"></p><ul><li>函数 getenv / putenv</li><li>一般调用函数获取环境，而非读取environ</li></ul></li><li><p>进程地址空间</p><p><img src="https://i.loli.net/2021/10/13/9X1HA2xE8dQ7TrI.png" alt="image-20211013000146968"></p><p>.text / .data / .bss / stack / heap / others (so , debug , systab )</p></li></ul><h3 id="4-跨越函数跳转"><a href="#4-跨越函数跳转" class="headerlink" title="4 跨越函数跳转"></a>4 跨越函数跳转</h3><ul><li>setjmp / longjmp</li><li>靠返回值val与正常函数调用区分</li></ul><h3 id="5-进程资源限制"><a href="#5-进程资源限制" class="headerlink" title="5 进程资源限制"></a>5 进程资源限制</h3><ul><li>getrlimit / setrlimit</li></ul><h2 id="7-2-API"><a href="#7-2-API" class="headerlink" title="7.2 API"></a>7.2 API</h2><ul><li>exit / _Exit / _exit</li><li>atexit</li><li>getenv / putenv / setenv / unsetenv / clearenv</li><li>setjmp / longjmp</li></ul><h1 id="8-进程控制"><a href="#8-进程控制" class="headerlink" title="8. 进程控制"></a>8. 进程控制</h1><h2 id="8-1-概念"><a href="#8-1-概念" class="headerlink" title="8.1 概念"></a>8.1 概念</h2><h3 id="进程ID"><a href="#进程ID" class="headerlink" title="进程ID"></a>进程ID</h3><ul><li><p>循环复用</p></li><li><p>特殊的进程ID</p><ul><li><p>swapper：0    内核交换进程</p></li><li><p>init：1</p><p>普通用户进程</p><p>超级用户特权</p><p>所有孤儿进程的父进程</p></li></ul></li></ul><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><h4 id="一次调用两次返回"><a href="#一次调用两次返回" class="headerlink" title="一次调用两次返回"></a>一次调用两次返回</h4><ul><li><p>父进程中返回创建的子进程ID</p></li><li><p>子进程返回0</p><p>getppid ( get parent id) 获取父进程ID</p></li><li><p>父子进程谁先执行不确定</p></li></ul><h4 id="子进程是父进程的副本"><a href="#子进程是父进程的副本" class="headerlink" title="子进程是父进程的副本"></a>子进程是父进程的副本</h4><ul><li><p>拷贝数据空间、堆、栈</p><p>COW （copy on write）写时复制</p><p>试图修改时才真正拷贝</p><p>fork + exec 从中受益</p></li><li><p>代码段共享 （只读）</p></li><li><p>拷贝文件描述符表</p><p><img src="https://i.loli.net/2021/10/13/NQ7HU8TExiwOo3J.png" alt="image-20211013001243684"></p></li><li><p>继承父进程相关属性</p><p>实际用户ID、实际组ID、有效用户ID、有效组ID 附属组ID 进程组ID 会话ID 控制终端 设置用户ID标识和设置组ID标识 当前工作目录 根目录 文件模式创建屏蔽字 信号屏蔽和安排 对任一打开文件描述符的执行时关闭(close-on-exec)标识 环境变量 连接的共享存储段 存储映像 资源限制</p></li><li><p>父子进程的不同之处</p><ul><li>ID / PID</li><li>子进程tms_utime/tms_stime/tms_cutime/tms_ustime被清零</li><li><strong>子进程不继承父进程文件锁</strong></li><li>子进程未处理闹钟将被清除</li><li>子进程未处理信号集设置为空集</li></ul></li></ul><h3 id="父子进程的生死交互"><a href="#父子进程的生死交互" class="headerlink" title="父子进程的生死交互"></a>父子进程的生死交互</h3><h4 id="子进程先于父进程终止"><a href="#子进程先于父进程终止" class="headerlink" title="子进程先于父进程终止"></a>子进程先于父进程终止</h4><ul><li><p>通过信号SIGCHILD发送退出状态给父进程</p></li><li><p>父进程可以通过wait / waitpid获取信息</p><p>子进程ID / 子进程终止状态 / CPU耗时</p></li><li><p>未善后的终止子进程为僵死进程（zombie）</p></li></ul><h4 id="父进程先于子进程终止"><a href="#父进程先于子进程终止" class="headerlink" title="父进程先于子进程终止"></a>父进程先于子进程终止</h4><ul><li><p>子进程父亲改为init 进程（pid 1）</p></li><li><p>init进程会调用wait善后处理终止的子进程（防止全是zombie）</p></li><li><p>wait / waitpid</p><ul><li><p>如果所有子进程都还在运行，则阻塞</p></li><li><p>如果一个子进程终止，正等待父进程获取其终止状态，则取得终止状态立即返回（zombie状态也立即返回）</p></li><li><p>如果没有任何子进程则出错返回</p></li><li><p>waitpid功能补充</p><p>支持异步（需要设置options参数）</p><p>可选择性等待某个进程</p><p>​    pid == -1 / 0 / &gt;0 / &lt;-1</p></li></ul></li><li><p>更灵活的wait系列函数</p></li></ul><h3 id="exec族函数"><a href="#exec族函数" class="headerlink" title="exec族函数"></a>exec族函数</h3><ul><li><p>更进一步的封装</p><ul><li><p>popen</p></li><li><p>system</p><p>fork -&gt; exec -&gt; waitpid</p></li></ul></li></ul><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><ul><li>实际用户 / 组ID</li><li>有效用户 / 组ID</li><li>setuid / setgid<ul><li>进程拥有超级权限，二话不说直接改实际用户/组ID、有效用户/组ID为指定ID </li><li>如果没有超级权限，但是uid或gid设置为实际用户/组ID或保存的设置用户/组ID， 则只将有效用户/组ID改为指定ID </li><li>不满足前两条，通通返回错误(ret = -1, error = EPERM)</li></ul></li></ul><h3 id="解释器文件"><a href="#解释器文件" class="headerlink" title="解释器文件"></a>解释器文件</h3><ul><li>解释型语言源文件起始行标注</li></ul><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><ul><li><p>优先级</p></li><li><p>nice</p><p>0~2*NZERO-1 sysconf获取</p><p>越大越低</p></li><li><p>getpriority setpriority</p></li></ul><h3 id="进程时间-1"><a href="#进程时间-1" class="headerlink" title="进程时间"></a>进程时间</h3><ul><li>时钟时间 </li><li>用户CPU时间 </li><li>系统CPU时间 </li><li>times</li></ul><h1 id="8-2-API"><a href="#8-2-API" class="headerlink" title="8.2 API"></a>8.2 API</h1><ul><li>getpid getppid getuid geteuid getgid getegid</li><li>fork vfork</li><li>wait waitpid</li><li>waitid</li><li>wait3/wait4</li><li>execl execv execle execve execlp execvp fexecve</li><li>setuid/setgid</li><li>seteuid/setegid</li><li>system</li><li>nice</li><li>getpriority/setpriority</li><li>times</li></ul><h1 id="9-进程关系"><a href="#9-进程关系" class="headerlink" title="9. 进程关系"></a>9. 进程关系</h1><h2 id="9-1-概念"><a href="#9-1-概念" class="headerlink" title="9.1 概念"></a>9.1 概念</h2><h3 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h3><p><img src="https://i.loli.net/2021/10/15/pDU7nBhWYsqKtjm.png" alt="image-20211015155106020"></p><ul><li><p>tty1-6</p><p>CTRL ALT F1-6</p></li><li><p>图形终端</p><p>ALT F7</p></li><li><p>pseudo tty（pty） 网络终端</p></li></ul><h3 id="进程组（作业job）"><a href="#进程组（作业job）" class="headerlink" title="进程组（作业job）"></a>进程组（作业job）</h3><ul><li><p>唯一标志ID</p><ul><li><p>getpgrp / getpgid</p></li><li><p>setpgid</p><p><strong>进程只能为自己和它的子进程设置进程组ID</strong></p></li><li><p>唯一标志ID和组长的PID一致</p></li></ul></li><li><p>多个进程的集合，每个进程都有所属的进程组</p></li><li><p>同一进程组的所有进程接受同一终端的各种信号</p></li><li><p><strong>孤儿进程组</strong></p><p>每个成员的父亲要么在本组，要么在其他会话中</p></li></ul><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><ul><li><p>可以有0或一个控制终端（tty / pseudo tty)</p><p>建立与控制终端连接的会话首进程被称为控制进程</p><p>无控制终端可能为守护进程</p></li><li><p>一个到多个进程组的集合</p><ul><li><p>一个前台进程</p><p>这意味着会话有一个控制终端</p><p>接受 ctrl c / ctrl \ 产生的 SIGINT /  SIGQUIT 信号</p></li><li><p>n个后台进程组</p></li><li><p><img src="https://i.loli.net/2021/10/15/qJIVv3AE1sRPOQm.png" alt="image-20211015154131834"></p></li></ul></li><li><p>新建会话 setsid</p><ul><li><p>该进程变成新会话的会话首进程 (session leader)</p><p>此时该 leader 是会话中的唯一进程</p><p>这意味这<strong>要新建会话 要先 fork 再 setsid</strong>     这就保证了进程不是进程组的组长</p></li><li><p>该进程成为一个新进程组的组长进程</p><p>新进程组ID是调用进程的进程ID</p><p>也是会话ID</p></li><li><p>该进程没有控制终端</p><p>如果调用 setsid 前有控制终端，则切断联系</p></li></ul></li></ul><h3 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h3><p><img src="https://i.loli.net/2021/10/15/lSc1txX8ZjoD2sv.png" alt="image-20211015155022811"></p><h2 id="9-2-API"><a href="#9-2-API" class="headerlink" title="9.2 API"></a>9.2 API</h2><ul><li>getpgrp / getpgid / sepgid</li><li>setsid / getsid</li><li>tcgetpgrp / tcsetpgrp / tcgetsid</li></ul><h1 id="10-信号"><a href="#10-信号" class="headerlink" title="10. 信号"></a>10. 信号</h1><h2 id="10-1-概念"><a href="#10-1-概念" class="headerlink" title="10.1 概念"></a>10.1 概念</h2><h3 id="异步事件"><a href="#异步事件" class="headerlink" title="异步事件"></a>异步事件</h3><ul><li>信号的产生是不定时的，随机的</li><li>可以简单理解为用户态的中断（软中断）</li></ul><h3 id="产生信号的方式"><a href="#产生信号的方式" class="headerlink" title="产生信号的方式"></a>产生信号的方式</h3><ul><li>用户按键产生（ctrl C）</li><li>硬件异常产生</li><li>进程或者用户调用kill</li><li>但检测到某种软性条件已经发生，通知有关进程<ul><li>SIGURG / SIGPIPE / SIGALARM / SIGABRT</li></ul></li></ul><h3 id="进程处理信号的方式"><a href="#进程处理信号的方式" class="headerlink" title="进程处理信号的方式"></a>进程处理信号的方式</h3><ul><li><p>忽略 ignore</p><ul><li>大多数信号的默认处理方式</li><li>SIGKILL / SIGSTOP 不能被忽略</li><li>由硬件异常导致的信号最好不要被忽略</li><li>中断允许嵌套，但是一般终端过程中同一个中断会忽略</li></ul></li><li><p>捕捉 catch</p><ul><li>注册一个signal handler</li><li>信号到来时会打断当前执行流，转而去执行handler</li><li>不能捕捉SIGKILL / SIGSTOP</li></ul></li><li><p>执行默认动作</p><p><img src="https://i.loli.net/2021/10/13/oRPtp3KE8DM6zXm.png" alt="image-20211013234629726"></p></li><li><p>函数 signal / sigaction</p></li><li><p>子进程继承了父进程处理信号的方式</p></li></ul><h3 id="被中断的系统调用"><a href="#被中断的系统调用" class="headerlink" title="被中断的系统调用"></a>被中断的系统调用</h3><ul><li><p>低速系统调用</p><p>可能会使进程永久阻塞的一类</p></li><li><p>出错返回</p><p>errno EINTR</p></li><li><p>自动重新启动的系统调用</p><p>ioctl read/readv write/writev wait/waitpid</p></li></ul><h3 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h3><ul><li><p>异步信号安全</p><p><img src="https://i.loli.net/2021/10/13/mTB6qjaRNg81KUw.png" alt="image-20211013235025005"></p></li><li><p>不可重入的情况</p><p>static静态变量</p><p>global全局变量</p><p>调用了不可重入函数</p></li><li><p>malloc是线程安全的（递归锁），但是维护共享内存，故是不可重入的</p></li></ul><h3 id="可靠信号"><a href="#可靠信号" class="headerlink" title="可靠信号"></a>可靠信号</h3><ul><li><p>未决的 pending<br>产生信号和送达之间</p></li><li><p>信号屏蔽字 signal mask （signal procmask）</p><ul><li>进程可以阻塞某种信号递送sigpending<ul><li>保持未决状态</li><li>直到进程接触阻塞或设置为忽略才送达</li><li>阻塞期间同一个信号触发多次（是否排队：sigqueue）</li></ul></li><li>sigsuspend 解除了 使用 sigprocmask 和 pause 组合 的原子性问题</li></ul></li><li><p>信号集 sigset_t</p><p>相关api ： sigemptyset / sigfillset / sigaddset / sigdelset / sigismember</p><p>与 sigprocmask 相配合</p></li></ul><h3 id="递送信号"><a href="#递送信号" class="headerlink" title="递送信号"></a>递送信号</h3><ul><li><p>kill  / raise 库函数</p></li><li><p>kill命令</p></li><li><p>定时器</p><p>alarm：SIGALARM  默认动作为终止进程</p><p>一个进程只能有一个定时器</p></li></ul><h3 id="睡眠"><a href="#睡眠" class="headerlink" title="睡眠"></a>睡眠</h3><ul><li>sleep / nanosleep / clock_nanosleep</li></ul><h3 id="进程控制的延申"><a href="#进程控制的延申" class="headerlink" title="进程控制的延申"></a>进程控制的延申</h3><ul><li>信号做父子进程的同步</li><li>加入信号处理的system实现</li></ul><h3 id="非局部跳出（deprecated）"><a href="#非局部跳出（deprecated）" class="headerlink" title="非局部跳出（deprecated）"></a>非局部跳出（deprecated）</h3><ul><li><p>sigsetjmp / siglongjmp</p></li><li><p>对比 setjmp / longjmp</p><p>handler自动屏蔽某种信号</p><p>跳走后无法保存信号屏蔽字</p></li></ul><h1 id="10-2-API"><a href="#10-2-API" class="headerlink" title="10.2 API"></a>10.2 API</h1><ul><li><p>signal</p></li><li><p>kill / raise</p></li><li><p>alarm</p></li><li><p>pause</p></li><li><p>sigemptyset / sigfillset / sigaddset / sigdelset / sigismember</p></li><li><p>sigprocmask / sigpending</p></li><li><p>sigsetjmp / siglongjmp</p></li><li><p>sigsuspend</p><p>信号屏蔽字被设置为sigmask指向的值然后挂起，在捕捉一个信号之后返回恢复原来的sigmask </p></li><li><p>abort</p></li></ul><h1 id="11-线程"><a href="#11-线程" class="headerlink" title="11. 线程"></a>11. 线程</h1><h2 id="11-1-进程与线程的概念"><a href="#11-1-进程与线程的概念" class="headerlink" title="11.1 进程与线程的概念"></a>11.1 进程与线程的概念</h2><ul><li>进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位）</li><li>进程有自己的独立地址空间，线程是共享进程的地址空间</li><li>线程之间通信更方便，进程则要通过各种IPC机制</li><li>多进程更加健壮，一个进程异常挂掉不会导致其他进程挂掉</li></ul><h2 id="11-2-多线程与多核"><a href="#11-2-多线程与多核" class="headerlink" title="11.2 多线程与多核"></a>11.2 多线程与多核</h2><ul><li>单核也可以多线程</li><li>多核多线程可以达成同时run的效果</li></ul><h2 id="11-3-pthread标准"><a href="#11-3-pthread标准" class="headerlink" title="11.3 pthread标准"></a>11.3 pthread标准</h2><ul><li><p>POSIX 线程</p><p>LinuxThreads的变化（NPTL）</p></li></ul><h2 id="11-4-线程信息"><a href="#11-4-线程信息" class="headerlink" title="11.4 线程信息"></a>11.4 线程信息</h2><p><strong>以下不共享</strong></p><ul><li><p>线程ID</p><p>pthread_t / pthread_equal / pthread_self</p></li><li><p>栈</p></li><li><p>信号屏蔽字</p></li><li><p>调度优先级</p></li><li><p>errno变量</p></li><li><p>线程私有数据</p></li></ul><h2 id="11-5-线程的生与死"><a href="#11-5-线程的生与死" class="headerlink" title="11.5 线程的生与死"></a>11.5 线程的生与死</h2><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><ul><li><p>pthread_creat<strong>e</strong></p></li><li><p>线程创建不能保证哪个线程会先运行</p></li><li><p>线程继承调用线程的浮点环境和信号屏蔽字</p><p>但是 pending 信号集会被清除</p></li></ul><h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h3><ul><li><p>导致进程终止</p><ul><li>任意线程调用 exit / _exit / _Exit</li><li>发送给线程的信号（默认终止进程）</li></ul></li><li><p>单一线程终止</p><ul><li><p>线程从启动历程返回</p><p>pthread_join / pthread_datch</p></li><li><p>线程被同一进程的其他线程取消</p><p>pthread_cancel</p></li><li><p>线程调用 pthread_exit</p></li></ul></li><li><p>线程清理处理程序</p><ul><li>pthread_cleanup_push / pthread_cleanup_pop</li><li>清理情况：<ul><li>主动调用 pthread_exit</li><li>响应 pthread_cancel</li><li>调用 pthread_cleanup_pop 参数不为0的时候</li></ul></li><li>直接 return 并不会执行清理</li><li>执行顺序与注册顺序相反</li></ul></li></ul><h2 id="11-6-进程与线程原语"><a href="#11-6-进程与线程原语" class="headerlink" title="11.6 进程与线程原语"></a>11.6 进程与线程原语</h2><table><thead><tr><th>进程原语</th><th>线程原语</th><th>描述</th></tr></thead><tbody><tr><td>fork</td><td>pthread_create</td><td>创建新的控制流</td></tr><tr><td>exit</td><td>pthread_exit</td><td>从现有的控制流中退出</td></tr><tr><td>waitpid</td><td>pthread_join</td><td>从控制流中得到退出状态</td></tr><tr><td>atexit</td><td>pthread_cancel_push</td><td>注册在退出控制流时调用的函数</td></tr><tr><td>getpid</td><td>pthread_self</td><td>获取控制流的ID</td></tr><tr><td>abort</td><td>pthread_cancel</td><td>请求控制流的非正常退出</td></tr></tbody></table><h2 id="11-7-线程同步、一致性问题"><a href="#11-7-线程同步、一致性问题" class="headerlink" title="11.7 线程同步、一致性问题"></a>11.7 线程同步、一致性问题</h2><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><ul><li><p>POSIX互斥量</p><p>struct pthread_mutex_t</p><ul><li><p>初始化/销毁</p><p>pthread_mutex_init / pthread_mutex_destory</p></li><li><p>上锁</p><p>pthread_mutex_lock / pthread_mutex_timedlock / pthread_mutex_trylock / pthread_mutex_unlock</p></li><li><p>解锁</p><p>pthread_mutex_unlock</p></li></ul></li><li><p>死锁</p><ul><li><p>AB型死锁</p><p>解决方法：</p><ol><li>按序获取锁（程序复杂）</li><li>trylock / timedlock</li></ol></li></ul></li></ul><h3 id="读写锁-共享互斥锁"><a href="#读写锁-共享互斥锁" class="headerlink" title="读写锁(共享互斥锁)"></a>读写锁(共享互斥锁)</h3><ul><li><p>状态</p><ul><li><p>读锁：读请求 pass ，写请求阻塞直到读锁释放（共享锁）</p><p>引用计数实现</p><p>注意写请求的饥饿情况，通常写请求后的读请求被阻塞（FIFO)</p></li><li><p>写锁：阻塞任何的加锁请求（互斥锁）</p></li><li><p>无锁</p></li></ul></li><li><p>一次只有一个线程可以占有写锁，可以有多个线程同时占有读锁</p></li><li><p>适用于读请求&gt;&gt;写请求的情况</p></li><li><p>POSIX读写锁</p><ul><li><p>初始化 / 销毁</p><p>pthread_rwlock_init / pthread_rwlock_destroy</p></li><li><p>读锁</p><p>pthread_rwlock_rdlock / pthread_rwlock_tryrdlock / pthread_rwlock_timedrdlock</p></li><li><p>写锁</p><p>pthread_rwlock_wrlock / pthread_rwlock_trywrlock / pthread_rwlock_timedwrlock</p></li><li><p>解锁</p><p>pthread_rwlock_unlock</p></li></ul></li></ul><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><ul><li><p>配合互斥量使用，提供多线程会合的时间点</p></li><li><p>初始化 / 销毁</p><p>pthread_cond_init / pthread_cond_destroy</p></li><li><p>等待条件变量变为true</p><p>pthread_cond_wait / pthread_cond_timedwait</p></li><li><p>条件变量置信</p><p>pthread_cond_signal 唤醒一个 / pthread_cond_broadcast 唤醒所有</p></li></ul><h3 id="自旋锁-spinlock"><a href="#自旋锁-spinlock" class="headerlink" title="自旋锁 spinlock"></a>自旋锁 spinlock</h3><ul><li>特征：忙等阻塞</li><li>锁持有时间段，线程不希望被调度</li><li>用户态基本不使用自旋锁</li><li>不要调用在持有自旋锁的情况下可能会进入休眠状态的函数</li></ul><h3 id="屏障-barrier"><a href="#屏障-barrier" class="headerlink" title="屏障 barrier"></a>屏障 barrier</h3><ul><li><p>协调多个进程并行工作</p><p>每个线程等待，直到所有线程共同达到某一点</p></li><li><p>初始化 / 销毁</p><p>pthread_barrier_init / pthread_barrier_destory</p></li><li><p>等待</p><p>pthread_barrier_wait</p><p>未满足屏障计数时阻塞 、满足屏障计数时唤醒所有（最后一个线程）</p></li></ul><h1 id="12-线程控制"><a href="#12-线程控制" class="headerlink" title="12. 线程控制"></a>12. 线程控制</h1><h2 id="12-1-属性"><a href="#12-1-属性" class="headerlink" title="12.1 属性"></a>12.1 属性</h2><h3 id="pthread遵循的对于属性的模式"><a href="#pthread遵循的对于属性的模式" class="headerlink" title="pthread遵循的对于属性的模式"></a>pthread遵循的对于属性的模式</h3><ol><li>每个对象都和自己类型的属性对象相关联（互斥量与互斥量属性相关联，线程与线程属性相关联），表现为 attr 指针，每个属性对象可以代表多个属性。属性对应用不透明，便于提高可移植性，因此需要函数来进行管理</li><li>每个属性对象有一个初始化函数，它把属性设置为默认值</li><li>还有一个销毁属性对象的函数，用于释放与属性对象的资源</li><li>获取各个属性值的函数，返回存储它的内存单元</li><li>设置属性值的函数，一般来说属性作为参数用指针传递</li></ol><h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><ul><li><p>初始化 / 销毁</p><p>pthread_attr_init / pthread_attr_destory</p></li><li><p>线程分离状态属性(分离线程的资源在线程终止时立即收回，无法用 join 等待其终止状态)</p><p>pthread_attr_getdetachstate / pthread_attr_setdetachstate</p></li><li><p>以下不建议用</p><p>pthread_attr_getguardsize / pthread_attr_setguardsize</p><p>pthread_attr_getstacksize / pthread_attr_setstacksize</p><p>pthread_attr_getstack / pthread_attr_setstack</p></li><li><p>取消状态（取消点）不建议用</p><p>PTHREAD_CANCEL_ENABLE / PTHREAD_CANCEL_DISABLE </p><p>pthread_setcancelstate</p><p>被取消线程在调用点会感知到取消 (pthread_cancel调用方不等待)</p><p>默认情况延迟取消</p></li></ul><h3 id="同步属性"><a href="#同步属性" class="headerlink" title="同步属性"></a>同步属性</h3><h4 id="互斥量属性-pthread-mutexattr-t"><a href="#互斥量属性-pthread-mutexattr-t" class="headerlink" title="互斥量属性 pthread_mutexattr_t"></a>互斥量属性 pthread_mutexattr_t</h4><p><del>共享属性、健壮属性</del>、类型属性</p><ul><li><p>pthread_mutexattr_init / pthread_mutexattr_destroy</p></li><li><p>以下不建议使用</p><ul><li><p>进程共享(内核开销大，不属于NPTL)</p><p>pthread_mutexattr_getpshared / pthread_mutexattr_setpshared</p></li><li><p>健壮属性</p></li><li><p><strong>类型属性</strong></p><ul><li><p>pthread_mutexattr_gettype / pthread_mutexattr_settype</p></li><li><table><thead><tr><th>互斥量类型</th><th>递归上锁</th><th>不占用时解锁</th><th>已解锁时解锁</th></tr></thead><tbody><tr><td>PTHREAD_MUTEX_NORMAL</td><td>死锁</td><td>未定义</td><td>未定义</td></tr><tr><td>PTHREAD_MUTEX_ERRORCHECK</td><td>返回错误</td><td>返回错误</td><td>返回错误</td></tr><tr><td>PTHREAD_MUTEX_RECURSIVE</td><td>允许</td><td>返回错误</td><td>返回错误</td></tr><tr><td>PTHREAD_MUTEX_DEFAULT</td><td>未定义</td><td>未定义</td><td>未定义</td></tr></tbody></table></li><li><p>递归锁的使用场景</p><p><img src="https://i.loli.net/2021/10/15/adhHkbEo9LBI1gC.png" alt="image-20211015230742334"></p></li></ul></li></ul></li></ul><h4 id="读写锁属性-pthread-rwlockattr-t"><a href="#读写锁属性-pthread-rwlockattr-t" class="headerlink" title="读写锁属性 pthread_rwlockattr_t"></a>读写锁属性 pthread_rwlockattr_t</h4><ul><li>pthread_rwlockattr_init / pthread_rwlockattr_destroy</li><li>pthread_rwlockattr_getpshared / pthread_rwlockattr_setpshared</li></ul><h4 id="条件变量属性-pthread-condattr-t"><a href="#条件变量属性-pthread-condattr-t" class="headerlink" title="条件变量属性 pthread_condattr_t"></a>条件变量属性 pthread_condattr_t</h4><ul><li>pthread_condattr_init / pthread_condattr_destroy</li><li>pthread_condattr_getpshared / pthread_condattr_setpshared</li></ul><h4 id="屏障属性-pthread-barrierattr-t"><a href="#屏障属性-pthread-barrierattr-t" class="headerlink" title="屏障属性 pthread_barrierattr_t"></a>屏障属性 pthread_barrierattr_t</h4><ul><li>pthread_barrierattr_init / pthread_barrierattr_destroy</li><li>pthread_barrierattr_getpshared / pthread_barrierattr_setpshared</li></ul><h2 id="12-2-重入"><a href="#12-2-重入" class="headerlink" title="12.2 重入"></a>12.2 重入</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>如果一个函数对多个线程来说时可重入的，就说这个函数是线程安全的。但并不能说明对信号处理程序来说该函数也是可重入的。</p></li><li><p>如果函数对于异步信号处理程序的重入是安全的，那么可以说函数是异步信号安全的</p></li><li><p><strong>重入的要求高于线程安全</strong></p><p>可重入要求信号安全</p><p>一般来说：</p><p>如果一个函数的实现使用了全局或者静态变量，且访问未加锁，那么这个函数既不是可重入的，也不是线程安全的。</p><p>如果放宽条件，这个函数仍然用到了全局或者静态变量，但是在访问这些变量时，通过加锁来保证互斥访问，那么这个函数就可以变成线程安全的函数。但它此时仍然是不可重入的，因为通常加锁是针对不同线程的访问，对同一线程可能出现问题（发生信号软中断，signal handler中恰巧也执行了该函数）。</p></li></ul><h3 id="非线程安全函数"><a href="#非线程安全函数" class="headerlink" title="非线程安全函数"></a>非线程安全函数</h3><p><img src="https://i.loli.net/2021/10/15/7JrTCHj1DRlBpy6.png" alt="image-20211015231532218"></p><h3 id="替代的线程安全函数"><a href="#替代的线程安全函数" class="headerlink" title="替代的线程安全函数"></a>替代的线程安全函数</h3><p><img src="https://i.loli.net/2021/10/15/3b7pgVX6hin1FEW.png" alt="image-20211015231605762"></p><h2 id="12-3-线程私有数据"><a href="#12-3-线程私有数据" class="headerlink" title="12.3 线程私有数据"></a>12.3 线程私有数据</h2><ul><li><p>由于线程共享地址空间，故线程无法阻止另一个线程访问其私有数据</p><p>因此需要管理线程特定数据的函数（设计上封装隔离）</p></li><li><p>pthread_key_create / pthread_key_delete</p></li><li><p>让不同线程看到同一个键值 pthread_once</p><p>pthread_once_t = PTHREAD_ONCE_INIT</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destructor</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *)</span></span>;<br><span class="hljs-keyword">pthread_key_t</span> key;<br><span class="hljs-keyword">pthread_once_t</span> init_done = PTHREAD_ONCE_INIT;<br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">thread_init</span><span class="hljs-params">(Void)</span></span><br><span class="hljs-function"></span>&#123;<br>err = pthread_key_create(&amp;key, destructor);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">threadfunc</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>pthread_once(&amp;init_done, thread_init);<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>关联键和私有数据</p><p>pthread_getspecific / pthread_setspecific</p></li></ul><h2 id="12-4-线程和信号"><a href="#12-4-线程和信号" class="headerlink" title="12.4 线程和信号"></a>12.4 线程和信号</h2><ul><li><p>线程都有自己的信号屏蔽字</p></li><li><p>线程的处理是进程中所有线程共享的</p></li><li><p>信号是传递给单个线程的</p><ul><li>信号与硬件相关，递送给引起时间的进程</li><li>其他信号发送给任意一个进程</li></ul></li><li><p>pthread_sigmask</p><ul><li><p>sigprocmask在多线程环境中行为未定义</p></li><li><p>用法类似sigprocmask</p></li><li><p>sigwait等待信号出现</p><ul><li><p>先阻塞等待的信号（在外部）</p></li><li><p>原子取消信号集阻塞状态</p></li><li><p>信号递送后返回</p></li><li><p>返回前恢复阻塞信号集</p><p>类比条件变量和互斥量</p></li></ul></li><li><p>多个线程等待同一信号，只有一个会被唤醒</p></li></ul></li><li><p>pthread_kill</p><p>给指定进程发送信号</p></li><li><p>线程与I/O</p><ul><li><p>lseek read</p><p>多线程有问题</p></li><li><p>pread</p><p>lseek read 的原子操作</p></li></ul></li></ul><h2 id="12-5-API"><a href="#12-5-API" class="headerlink" title="12.5 API"></a>12.5 API</h2><ul><li>pthread_attr_init / pthread_attr_destroy</li><li>pthread_attr_getdetachstate / pthread_attr_setdetachstate</li><li>pthread_key_create</li><li>pthread_mutexattr_init / pthread_mutexattr_destroy</li><li>pthread_mutexattr_gettype / pthread_mutexattr_settype</li><li>pthread_key_create / pthread_key_delete</li><li>pthread_getspecific / pthread_setspecific</li><li>pthread_sigmask</li><li>pthread_sigkill</li></ul><h1 id="13-守护进程"><a href="#13-守护进程" class="headerlink" title="13. 守护进程"></a>13. 守护进程</h1><h2 id="13-1-概念"><a href="#13-1-概念" class="headerlink" title="13.1 概念"></a>13.1 概念</h2><h3 id="守护进程的概念"><a href="#守护进程的概念" class="headerlink" title="守护进程的概念"></a>守护进程的概念</h3><ul><li>内核态守护进程（内核线程）<ul><li>eg： 虚拟内存换页kswapd / 脏页面冲刷 flush</li></ul></li><li>用户态守护进程<ul><li>由 init 拉起</li><li>setsid 使其一般是会话首进程，同时也是进程组组长、唯一进程</li></ul></li></ul><h3 id="编写守护进程的惯例"><a href="#编写守护进程的惯例" class="headerlink" title="编写守护进程的惯例"></a>编写守护进程的惯例</h3><ol><li><p>umask 设置文件模式创建屏蔽字</p><p>通常 umask(0)</p></li><li><p>父进程 fork 并 exit</p><p>为子进程 setsid 创建会话创造条件</p></li><li><p> setsid</p></li></ol><p>   会话首进程 / 进程组组长 / 没有控制终端</p><ol start="4"><li><p>当前工作目录改为根目录或者其他位置</p><p>chdir(“/“)            防挂在umount</p></li><li><p>关闭不用的文件描述符</p><p>首先 getrlimit 判定最高文件描述符的值，然后用循环全部关闭</p></li><li><p>打开 /dev/null 使具有文件描述符0、1、2</p><p>因为守护进程并不与终端设备相关联，无从显示也无需输入</p><p>fd0 = open(“/dev/null”, O_RDWR);</p></li><li><p>一般还需要处理 SIGHUP 信号</p><p>原因：孤儿进程</p></li></ol><h3 id="出错记录"><a href="#出错记录" class="headerlink" title="出错记录"></a>出错记录</h3><ul><li><img src="https://i.loli.net/2021/10/15/U2B4Ym8CMXEQ1Lh.png" alt="image-20211015160833072"></li><li>内核例程调用log函数</li><li>用户守护进程调用 syslog 函数</li><li>本地或其他主机可通过 UDP 514端口传递log</li><li>rsyslog</li></ul><h3 id="单例守护进程"><a href="#单例守护进程" class="headerlink" title="单例守护进程"></a>单例守护进程</h3><ul><li><p>文件记录锁</p><p>记录锁</p></li><li><p>惯例</p><ol><li><p>锁通常指定在 /var/run/%name%.pid</p><p>内容一般就是pid号</p></li><li><p>配置文件通常在 /etc/%name%.conf</p></li><li><p>守护进程一般通过初始化脚本之一启动</p><p>/etc/rc*    /etc/init.d/*    /etc/inittab启动自动重启</p></li><li><p>一般注册 SIGHUP 处理程序</p><p>一方面使为了防止默认动作终止</p><p>功能上设置为重新读取配置</p></li></ol></li></ul><h2 id="13-2-API"><a href="#13-2-API" class="headerlink" title="13.2 API"></a>13.2 API</h2><ul><li>openlog / syslog / closelog / setlog / mask</li><li>vsyslog</li></ul><h1 id="14-进阶I-O"><a href="#14-进阶I-O" class="headerlink" title="14 进阶I/O"></a>14 进阶I/O</h1><h2 id="14-1-非阻塞I-O"><a href="#14-1-非阻塞I-O" class="headerlink" title="14.1 非阻塞I/O"></a>14.1 非阻塞I/O</h2><ul><li><p>低速系统调用</p><p>定义：会引起进程永久阻塞</p><ul><li>某些文件类型数据不存在，读引起永久阻塞</li><li>数据不能被相同的文件类型接受，写操作会永久阻塞</li><li>对加了记录锁的文件读写</li><li>ioctl</li><li>进程通信函数</li></ul></li><li><p>open 先天指定 O_NONBLOCK</p></li><li><p>fcntl 后天设置  O_NONBLOCK</p></li><li><p>轮询 polling + 非阻塞I/O</p><p>类似用户态的自旋锁   浪费cpu时间</p></li><li><p>多线程 + 阻塞I/O</p><p>额外的线程开销、同步开销</p></li></ul><h2 id="14-2-记录锁-recording-lock"><a href="#14-2-记录锁-recording-lock" class="headerlink" title="14.2 记录锁 recording lock"></a>14.2 记录锁 recording lock</h2><ul><li><p>确保进程单独写文件</p><p>进程读或写文件的某个部分时，使用记录锁组织其他进程修改同一文件区</p><p>byte range locking</p></li><li><p>fcntl 记录锁</p><ul><li><p>struct flock</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">flock</span>&#123;</span><br><span class="hljs-keyword">short</span> l_type;<br><span class="hljs-keyword">short</span> l_whence;<br><span class="hljs-keyword">off_t</span> l_start;<br><span class="hljs-keyword">off_t</span> l_len;<br><span class="hljs-keyword">pid_t</span> l_pid;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>l_type :  F_GETLK / F_SETLK / F_SETLKW</p></li><li><p>F_GETLK 检测上锁后上锁不是原子操作</p></li><li><p>F_SETLKW 检测到死锁后杀死另一个进程获得资源</p></li></ul></li><li><p>锁的隐含继承与释放</p><ol><li><p>进程终止时，建立的所有锁全部释放</p></li><li><p>关联的fd何时关闭，锁都会释放</p></li><li><p>fork 子进程只能继承文件描述符，不能继承它的锁</p></li></ol></li><li><p>文件尾端加锁</p></li><li><p>建议性锁和强制性锁</p></li></ul><h2 id="14-3-异步I-O"><a href="#14-3-异步I-O" class="headerlink" title="14.3 异步I/O"></a>14.3 异步I/O</h2><p>不建议用</p><h2 id="14-4-I-O多路转接-multiplexing"><a href="#14-4-I-O多路转接-multiplexing" class="headerlink" title="14.4 I/O多路转接(multiplexing)"></a>14.4 I/O多路转接(multiplexing)</h2><h3 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h3><ul><li><p>阻塞模式下在多个fd上写，一个block会导致后面的pending</p><ul><li><p>polling + 无阻塞可以解决</p></li><li><p>异步I/O 用信号通知</p><p>缺点在于不知道哪个fd ready（不够映射）</p></li><li><p>I/O多路复用</p></li></ul></li></ul><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><ul><li>select / pselect</li><li>pselect 支持 timespec 结构，更精确的时间</li><li>最多支持fd 有上限</li></ul><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><ul><li>通过数组表明关心的条件</li><li>解决了fd数量的瓶颈</li></ul><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><ul><li>linux I/O多路转接的最优机制</li><li>性能高<ul><li>规避了所有fd的用户态 copy 到内核态的开销<ul><li>fd常驻内核</li><li>内核以红黑树组织</li></ul></li><li>内核态只回传ready 部分的fd</li><li>边沿触发</li></ul></li></ul><h2 id="14-5-其他"><a href="#14-5-其他" class="headerlink" title="14.5 其他"></a>14.5 其他</h2><h3 id="readv-writev"><a href="#readv-writev" class="headerlink" title="readv / writev"></a>readv / writev</h3><ul><li><p>散布读(scatter read) / 聚集写(gather write)</p><ul><li><p>iovec 结构数组</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span>&#123;</span><br><span class="hljs-keyword">void</span> *iov_base;<br><span class="hljs-keyword">size_t</span> iov_len<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>降低系统调用的次数，获取性能</p></li></ul><h3 id="readn-writen"><a href="#readn-writen" class="headerlink" title="readn / writen"></a>readn / writen</h3><ul><li><p>apue 对 read / write 的一些容错封装</p></li><li><p>原因： 管道、FIFO、网络、终端</p><p>可能读的字节数小于指定数量</p><p>写可能因为内核缓冲区满而失效</p></li></ul><h3 id="mmap-munmap"><a href="#mmap-munmap" class="headerlink" title="mmap / munmap"></a>mmap / munmap</h3><ul><li><p>存储映射I/O</p><p>磁盘文件映射到内存空间</p><p>直接读写内存就是修改磁盘文件</p></li><li><p>mprotect</p><p>修改映射区权限</p></li><li><p>msync</p><p>立刻同步刷新</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>linux / unix</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux Cammand Line 阅读笔记</title>
    <link href="/2021/05/24/linux%20&amp;%20unix/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    <url>/2021/05/24/linux%20&amp;%20unix/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h1><ul><li>人们说，“图形用户界面让简单的任务更容易完成，而命令行界面使 完成复杂的任务成为可能”，到现在这句话仍然很正确。</li></ul><h1 id="2-什么是shell"><a href="#2-什么是shell" class="headerlink" title="2.什么是shell"></a>2.什么是shell</h1><h2 id="2-1终端仿真器"><a href="#2-1终端仿真器" class="headerlink" title="2.1终端仿真器"></a>2.1终端仿真器</h2><p>shell 就是一个程序，它接受从键盘输入的命令，然后 把命令传递给操作系统去执行</p><p>当使用图形用户界面时，我们需要另一个和 shell 交互的叫做终端仿真器的程序。</p><h2 id="2-2第一次按键"><a href="#2-2第一次按键" class="headerlink" title="2.2第一次按键"></a>2.2第一次按键</h2><p>用户名 @ 主机 名，紧接着当前工作目录和一个美元符号</p><p>如果提示符的最后一个字符是“#”, 而不是“$”, 那么这个终端会话就有超级用户权限。 这意味着，我们或者是以 root 用户的身份登录，或者是我们选择的终端仿真器提供超级用户 （管理员）权限。</p><h2 id="2-3命令历史"><a href="#2-3命令历史" class="headerlink" title="2.3命令历史"></a>2.3命令历史</h2><p>默认保存500</p><ul><li><p>上箭头得到上一次命令</p></li><li><p>按下鼠标左键拖动快速复制，鼠标中键粘贴==不要用ctrl c==</p></li><li><p>设置聚焦跟随鼠标代替单机聚焦，可以使复制粘贴更方便</p></li></ul><h2 id="2-4简单命令"><a href="#2-4简单命令" class="headerlink" title="2.4简单命令"></a>2.4简单命令</h2><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">date<br>cal<span class="hljs-regexp">//</span>显示月历<br>df<span class="hljs-regexp">//</span>显示磁盘剩余空间<br>free<span class="hljs-regexp">//</span>空闲内存<br><span class="hljs-keyword">exit</span><span class="hljs-regexp">//</span>终止会话<br></code></pre></div></td></tr></table></figure><h2 id="2-5幕后控制台"><a href="#2-5幕后控制台" class="headerlink" title="2.5幕后控制台"></a>2.5幕后控制台</h2><ul><li><p>按下 Ctrl-Alt-F1 到 Ctrl-Alt-F6 访问</p></li><li><p>当一个会话被访问的时候，它会显示登录提示框，我们需要输入用户名和密码。</p></li><li><p>要从一 个虚拟控制台转换到另一个，按下 Alt 和 F1-F6(中的一个)。返回图形桌面，按下 Alt-F7</p></li></ul><h1 id="3-文件系统中跳转"><a href="#3-文件系统中跳转" class="headerlink" title="3.文件系统中跳转"></a>3.文件系统中跳转</h1><h2 id="3-1文件系统树"><a href="#3-1文件系统树" class="headerlink" title="3.1文件系统树"></a>3.1文件系统树</h2><ul><li>分层目录结构组织文件，所有文件组成一颗树型目录，倒置的树</li><li>总是只有一个单一的文件系统树，不管存储设备的连接（不像 Windows ，每个存储设备都有一个独自的文件系统）</li></ul><h2 id="3-2当前工作目录"><a href="#3-2当前工作目录" class="headerlink" title="3.2当前工作目录"></a>3.2当前工作目录</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">pwd</span><span class="hljs-string">//print</span> working directory显示当前目录<br><span class="hljs-keyword">ls</span><span class="hljs-string">//</span>列出一个目录包含的文件以及子目录<br><span class="hljs-keyword">ls</span> -a<br></code></pre></div></td></tr></table></figure><ul><li>当我们首次登录系统（或者启动终端仿真器会话）后，当前工作目录是我们的家目录。每个d用户都有他自己的家目录，当用户以普通用户的身份操控系统时，家目录是唯一允许用户写入文件的地方。</li><li>以 “.” 字符开头的文件名是隐藏文件，用<strong>ls -a</strong>命令</li><li><img src="https://i.loli.net/2021/05/09/eSIFcb9WpHRC2Od.png" alt="image-20210509210658151"></li></ul><h2 id="3-4更改当前工作目录"><a href="#3-4更改当前工作目录" class="headerlink" title="3.4更改当前工作目录"></a>3.4更改当前工作目录</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> <span class="hljs-string">/usr/bin</span><span class="hljs-string">//</span>绝对路径<br><span class="hljs-keyword">cd</span> <span class="hljs-string">..</span><span class="hljs-string">//</span>相对路径回到usr<br><span class="hljs-keyword">cd</span> <span class="hljs-string">./bin</span><span class="hljs-string">//</span>相对路径进入bin也可以直接<span class="hljs-keyword">cd</span> bin<br></code></pre></div></td></tr></table></figure><ul><li>绝对路径从根目录开始，直到它的目的地，而相对路径开始于工作目录</li><li>符号 “.” 指的是工作目录，”..” 指的是工作目录的父目录</li><li>==./是隐含的可以省略==</li></ul><p><img src="https://i.loli.net/2021/05/09/FNuxWrYnCG5Pv6E.png" alt="image-20210503151718776"></p><ul><li>文件名和命令名是大小写敏感的</li><li>文件没有拓展名，文件名可能包含空格，标点符号，但标点符号仅限 使用“.”，“－”，下划线，但是<strong>不要使用空格</strong></li></ul><h1 id="4-探究操作系统"><a href="#4-探究操作系统" class="headerlink" title="4.探究操作系统"></a>4.探究操作系统</h1><h2 id="4-1ls"><a href="#4-1ls" class="headerlink" title="4.1ls"></a>4.1ls</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">ls</span> <span class="hljs-string">/usr</span><span class="hljs-string">//</span>指定别的目录<br><span class="hljs-keyword">ls</span> ~ <span class="hljs-string">/usr</span><span class="hljs-string">//</span>指定多个目录（家目录和usr目录<br><span class="hljs-keyword">ls</span> -l <span class="hljs-string">//</span>以长模式输出<br></code></pre></div></td></tr></table></figure><ul><li>家目录用**~**代表</li></ul><h2 id="4-2选项和参数"><a href="#4-2选项和参数" class="headerlink" title="4.2选项和参数"></a>4.2选项和参数</h2><ul><li>大多数命令使用的选项，是由一个中划线加上一个字符组成，例如，“-l”，但是许多命令， 包括来自于 GNU 项目的命令，也支持长选项，长选项由两个中划线加上一个字组成。</li></ul><p><img src="https://i.loli.net/2021/05/09/VB2AWDIj95aCro1.png" alt="image-20210503153258807"></p><h2 id="4-3长格式输出"><a href="#4-3长格式输出" class="headerlink" title="4.3长格式输出"></a>4.3长格式输出</h2><p><img src="https://i.loli.net/2021/05/09/lyZe5n2GAqt3CDF.png" alt="image-20210503153900813"></p><h2 id="4-4确定文件类型"><a href="#4-4确定文件类型" class="headerlink" title="4.4确定文件类型"></a>4.4确定文件类型</h2><figure class="highlight sas"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sas"><span class="hljs-meta">file</span> <span class="hljs-meta">filename</span>//<span class="hljs-meta">file</span>命令打印文件内容的简单描述<br></code></pre></div></td></tr></table></figure><h2 id="4-5用less浏览文件内容"><a href="#4-5用less浏览文件内容" class="headerlink" title="4.5用less浏览文件内容"></a>4.5用less浏览文件内容</h2><ul><li>系统配置文件以文本格式储存</li></ul><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">less filename<br>less <span class="hljs-regexp">/etc/</span>passwd<br></code></pre></div></td></tr></table></figure><p>按下<strong>q</strong>键退出less程序</p><p><img src="https://i.loli.net/2021/05/09/LUnIRdDK6xH3NEy.png" alt="image-20210503154749096"></p><p><img src="https://i.loli.net/2021/05/09/TGUYunWPIaeQ8Es.png" alt="image-20210503154821201"></p><h2 id="4-6浏览文件"><a href="#4-6浏览文件" class="headerlink" title="4.6浏览文件"></a>4.6浏览文件</h2><p>目录文件概览</p><p><img src="https://i.loli.net/2021/05/09/DstdF5mrvkyKEM1.png" alt="image-20210503163447945"></p><p><img src="https://i.loli.net/2021/05/09/cmJN4MFztTjoYS7.png" alt="image-20210503163522307"></p><p><img src="https://i.loli.net/2021/05/09/9G3hHiMfbAYNpmL.png" alt="image-20210503163533077"></p><h1 id="5-操作文件和目录"><a href="#5-操作文件和目录" class="headerlink" title="5.操作文件和目录"></a>5.操作文件和目录</h1><h2 id="5-1通配符"><a href="#5-1通配符" class="headerlink" title="5.1通配符"></a>5.1通配符</h2><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">ls <span class="hljs-regexp">/usr/</span>bin/t*<br></code></pre></div></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/09/3ktnvrZ6DVbJoUc.png" alt="image-20210503164153279"></p><p><img src="https://i.loli.net/2021/05/09/C2cqUJ7GwjWR3KF.png" alt="image-20210503164224977"></p><p><img src="https://i.loli.net/2021/05/09/i5FIRYK8HZblUyA.png" alt="image-20210503164238485"></p><p><img src="https://i.loli.net/2021/05/09/rk59JXjBzKW8Ggd.png" alt="image-20210503164255229"></p><h2 id="5-2mkdir创建目录"><a href="#5-2mkdir创建目录" class="headerlink" title="5.2mkdir创建目录"></a>5.2mkdir创建目录</h2><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">mkdir</span> directory... //三个点表示参数可重复<br><span class="hljs-attribute">mkdir</span> dir<span class="hljs-number">1</span> dir<span class="hljs-number">2</span> dir<span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure><h2 id="5-3cp复制文件或目录"><a href="#5-3cp复制文件或目录" class="headerlink" title="5.3cp复制文件或目录"></a>5.3cp复制文件或目录</h2><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">cp</span> item<span class="hljs-number">1</span> item<span class="hljs-number">2</span>//复制单个文件或目录item<span class="hljs-number">1</span>到item<span class="hljs-number">2</span><br><span class="hljs-attribute">cp</span> item... directory//复制多个项目到一个目录下<br></code></pre></div></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/09/dgc9RnFShDr8Gzj.png" alt="image-20210503165042706"></p><p><img src="https://i.loli.net/2021/05/09/3WyqcJzPt6olvHY.png" alt="image-20210503165106591"></p><h2 id="5-4mv移动和重命名文件"><a href="#5-4mv移动和重命名文件" class="headerlink" title="5.4mv移动和重命名文件"></a>5.4mv移动和重命名文件</h2><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">mv</span> item<span class="hljs-number">1</span> item<span class="hljs-number">2</span><br><span class="hljs-attribute">mv</span> item... directory<br></code></pre></div></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/09/4hvScjteluO76Ga.png" alt="image-20210503165417114"></p><h2 id="5-5rm删除文件和目录"><a href="#5-5rm删除文件和目录" class="headerlink" title="5.5rm删除文件和目录"></a>5.5rm删除文件和目录</h2><figure class="highlight gams"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">rm</span></span> item...<br></code></pre></div></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/09/34tPEqJuFDaU7Z1.png" alt="image-20210503165621012"></p><h2 id="5-6ln创建链接"><a href="#5-6ln创建链接" class="headerlink" title="5.6ln创建链接"></a>5.6ln创建链接</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">ln</span> <span class="hljs-built_in">file</span> link<span class="hljs-comment">//创建硬链接</span><br><span class="hljs-built_in">ln</span> -s <span class="hljs-keyword">item</span> link<span class="hljs-comment">//创建符号链接</span><br></code></pre></div></td></tr></table></figure><h2 id="5-7硬链接"><a href="#5-7硬链接" class="headerlink" title="5.7硬链接"></a>5.7硬链接</h2><ul><li><p>一个硬链接不能关联它所在文件系统之外的文件。</p></li><li><p>一个硬链接不能关联一个目录。</p></li></ul><h2 id="5-8符号链接（软链接-symlink）"><a href="#5-8符号链接（软链接-symlink）" class="headerlink" title="5.8符号链接（软链接/symlink）"></a>5.8符号链接（软链接/symlink）</h2><ul><li>类似于windows的快捷方式，其本身与其他符号链接几乎没有区别</li><li>向符号链接写入，写入相关联的文件，删除符号链接不会删除文件自身</li><li>坏链接为红色</li></ul><h2 id="5-9-playground练习（很重要）"><a href="#5-9-playground练习（很重要）" class="headerlink" title="5.9 playground练习（很重要）"></a>5.9 playground练习（很重要）</h2><ul><li>cp命令至少两个地址(本地用.)</li><li>cp -v 看详细做了什么， -i 获得提示</li><li>mv要么两个地址（移动），要么改名字</li><li>ln创建链接 <strong>-s</strong>符号链接 跟文件和目录</li><li>ls -li 可以看到文件索引结点 </li><li>创建符号链接可以绝对路径也可以相对路径</li></ul><h1 id="6-使用命令"><a href="#6-使用命令" class="headerlink" title="6.使用命令"></a>6.使用命令</h1><h2 id="6-1命令四种形式"><a href="#6-1命令四种形式" class="headerlink" title="6.1命令四种形式"></a>6.1命令四种形式</h2><ul><li>可执行程序，编程语言或脚本语言写成</li><li>内建于shell自身的命令,<strong>内建命令</strong></li><li><strong>shell函数</strong>，即小规模shell脚本，混合到环境变量中</li><li><strong>命令别名</strong>，自定义命令建立在其他命令之上</li></ul><h2 id="6-2-type显示命令的类型"><a href="#6-2-type显示命令的类型" class="headerlink" title="6.2 type显示命令的类型"></a>6.2 type显示命令的类型</h2><figure class="highlight elm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-keyword">type</span><br><span class="hljs-keyword">type</span> ls<br></code></pre></div></td></tr></table></figure><h2 id="6-3-显示一个可执行程序的位置"><a href="#6-3-显示一个可执行程序的位置" class="headerlink" title="6.3 显示一个可执行程序的位置"></a>6.3 显示一个可执行程序的位置</h2><figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata"><span class="hljs-keyword">which</span> <span class="hljs-keyword">ls</span><br></code></pre></div></td></tr></table></figure><p>这个命令只对可执行程序有效，不包括内建命令和命令别名，别名是真正的可执行程序的替代物</p><h2 id="6-4-help得到shell内建命令的帮助文档"><a href="#6-4-help得到shell内建命令的帮助文档" class="headerlink" title="6.4 help得到shell内建命令的帮助文档"></a>6.4 help得到shell内建命令的帮助文档</h2><figure class="highlight dos"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dos"><span class="hljs-built_in">help</span> <span class="hljs-built_in">cd</span><br><span class="hljs-built_in">mkdir</span> --<span class="hljs-built_in">help</span><br></code></pre></div></td></tr></table></figure><p><strong>–help</strong>显示用法信息</p><h2 id="6-5-man显示程序手册页"><a href="#6-5-man显示程序手册页" class="headerlink" title="6.5 man显示程序手册页"></a>6.5 man显示程序手册页</h2><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-built_in">man</span> <span class="hljs-built_in">ls</span><br></code></pre></div></td></tr></table></figure><p>man使用less显示参考手册，可以使用less命令进行浏览</p><p>man参考手册分成的章节：</p><p><img src="https://i.loli.net/2021/05/09/Yai7qIrHvQK4Ebp.png" alt="image-20210509164918894"></p><p><img src="https://i.loli.net/2021/05/09/3Gobfrdm4ItChxw.png" alt="image-20210509164939272"></p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">man</span> <span class="hljs-number">5</span> passwd<br></code></pre></div></td></tr></table></figure><p>如果不成功显示No manual entry for passwd in section 5</p><p>则需要yum install man-pages</p><h2 id="6-6-apropos显示适当的命令"><a href="#6-6-apropos显示适当的命令" class="headerlink" title="6.6 apropos显示适当的命令"></a>6.6 apropos显示适当的命令</h2><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">apropos floppy<br>man -k floppy<span class="hljs-regexp">//</span>功能同上<br></code></pre></div></td></tr></table></figure><p>输出结果每行的第一个字段是手册页的名字，第二个字段展示章节</p><h2 id="6-7-whatis显示简洁的命令说明"><a href="#6-7-whatis显示简洁的命令说明" class="headerlink" title="6.7 whatis显示简洁的命令说明"></a>6.7 whatis显示简洁的命令说明</h2><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">whatis 命令<span class="hljs-regexp">/系统调用/</span>库函数/特殊文件名<br></code></pre></div></td></tr></table></figure><p>相当于man -f</p><h2 id="6-8-info显示程序info条目"><a href="#6-8-info显示程序info条目" class="headerlink" title="6.8 info显示程序info条目"></a>6.8 info显示程序info条目</h2><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros"><span class="hljs-builtin-name">info</span> ls<br></code></pre></div></td></tr></table></figure><p>info 文件是树型结构,包含超链接，可以从*号处跳转到另一个结点</p><p><img src="https://i.loli.net/2021/05/09/dCOj72tezXgs39f.png" alt="image-20210509171548454"></p><h2 id="6-9-README以及其他程序文档"><a href="#6-9-README以及其他程序文档" class="headerlink" title="6.9 README以及其他程序文档"></a>6.9 README以及其他程序文档</h2><ul><li><p>许多安装在你系统中的软件，都有自己的文档文件，这些文件位于/usr/share/doc 目录下。大多数是以文本文件的形式存储的，可用 less 阅读器来浏览。</p></li><li><p>以 “.gz” 结尾的文件表示 gzip压缩程序已经压缩了这些文件。gzip软件包包括一个特殊的 less 版本，叫做 zless，zless 可以显示由 gzip 压缩 的文本文件的内容。</p></li></ul><h2 id="6-10用别名（alias）创建命令"><a href="#6-10用别名（alias）创建命令" class="headerlink" title="6.10用别名（alias）创建命令"></a>6.10用别名（alias）创建命令</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">alias</span> foo=&#x27;<span class="hljs-keyword">cd</span> <span class="hljs-string">/usr</span>; <span class="hljs-keyword">ls</span>; <span class="hljs-keyword">cd</span> -&#x27;<br><span class="hljs-keyword">alias</span> name=&#x27;string&#x27;<span class="hljs-string">//</span>格式<br>type foo<br><span class="hljs-keyword">unalias</span> foo<span class="hljs-string">//</span>删除别名<br></code></pre></div></td></tr></table></figure><ul><li><p>在命令 “alias” 之后，输入“name”，紧接着（**<em>没有空格</em> **）是一个等号，等号之后是一串用引 号引起的字符串，字符串的内容要赋值给 name。</p></li><li><p>通常经常使用的命令带有普遍用到的选项，例如    ls is aliased to `ls –color=auto’，使用不带参数的alias查看默认定义的别名</p></li><li><p>==在命令行中定义别名有点儿小问题。当你的 shell 会话结束时，它们会消失。==</p></li></ul><h1 id="7-I-O重定向"><a href="#7-I-O重定向" class="headerlink" title="7.I/O重定向"></a>7.I/O重定向</h1><h2 id="7-1标准输入输出和错误"><a href="#7-1标准输入输出和错误" class="headerlink" title="7.1标准输入输出和错误"></a>7.1标准输入输出和错误</h2><ul><li>默认情况下，标准输出stdout和标准错误都连接屏幕而不是磁盘文件。</li><li>标准输入stdin默认情况下连接键盘</li><li><strong>I/O重定向</strong>允许我们更改输出地点和输入来源</li></ul><h2 id="7-2标准输出重定向"><a href="#7-2标准输出重定向" class="headerlink" title="7.2标准输出重定向"></a>7.2标准输出重定向</h2><ul><li>用 <strong>&gt;</strong>  重定向符接文件名</li></ul><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">ls -l <span class="hljs-regexp">/usr/</span>bin &gt; ls-output.txt<span class="hljs-regexp">//</span>直接创建文件<br>less le-output.txt<br></code></pre></div></td></tr></table></figure><ul><li><strong>当我们使用 “&gt;” 重定向符来重定向输出结果时，目标文件总是 从开头被重写</strong>（如果错误了就清空文件）</li></ul><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">&gt; ls-output.txt<span class="hljs-regexp">//</span>故意用重定向符来清空文件内容<br>ls -l <span class="hljs-regexp">/usr/</span>bin &gt;&gt; ls-output.txt<br></code></pre></div></td></tr></table></figure><ul><li>用 &gt;&gt; 操作符可以把输出结果加到文件内容之后，如果文件不存在则会被创建</li></ul><h2 id="7-3标准错误重定向"><a href="#7-3标准错误重定向" class="headerlink" title="7.3标准错误重定向"></a>7.3标准错误重定向</h2><ul><li>一一个程序可以在几个编号的文件流中的任一个上产生输出。前三个称作标准输入、输出和错误，shell 内部分别将其称为文件描述符 0、1 和 2</li></ul><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">ls -l <span class="hljs-regexp">/bin/u</span>sr <span class="hljs-number">2</span>&gt; ls-error.txt<span class="hljs-regexp">//</span>测试错误输出<br></code></pre></div></td></tr></table></figure><h2 id="7-4-重定向标准输出和错误到同一个文件"><a href="#7-4-重定向标准输出和错误到同一个文件" class="headerlink" title="7.4 重定向标准输出和错误到同一个文件"></a>7.4 重定向标准输出和错误到同一个文件</h2><ul><li>方法一</li></ul><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">ls</span> -l /bin/usr &gt; ls-output.txt <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p><strong>完成两个重定向，首先重定向标准输出到文件，然后重定向标准错误到标准输出，用2&gt;&amp;1。</strong></p><p><strong>注意重定向的顺序安排非常重要。标准错误的重定向必须总是出现在标准输出重定向之后， 要不然它不起作用。</strong></p><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c">&gt; ls-output.txt <span class="hljs-number">2</span>&gt;<span class="hljs-meta">&amp;1<span class="hljs-comment">//重定向标准错误到文件 ls-output.txt</span></span><br><span class="hljs-number">2</span>&gt;<span class="hljs-meta">&amp;1 &gt; ls-output.txt<span class="hljs-comment">//标准错误定向到屏幕</span></span><br></code></pre></div></td></tr></table></figure><ul><li>方法二</li></ul><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">ls -l <span class="hljs-regexp">/bin/u</span>sr &amp;&gt; ls-output.txt<br></code></pre></div></td></tr></table></figure><p>用 &amp;&gt; 来重定向标准输出和错误到文件 ls-output.txt</p><h2 id="7-5处理不需要的输出"><a href="#7-5处理不需要的输出" class="headerlink" title="7.5处理不需要的输出"></a>7.5处理不需要的输出</h2><ul><li>不想要一个命令的输出结果，系统重定向输出结果到 /dev/null 的特殊文件</li></ul><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle">ls -l <span class="hljs-regexp">/bin/u</span>sr <span class="hljs-number">2</span>&gt; <span class="hljs-regexp">/dev/</span><span class="hljs-keyword">null</span><br></code></pre></div></td></tr></table></figure><h2 id="7-6-cat连接文件"><a href="#7-6-cat连接文件" class="headerlink" title="7.6 cat连接文件"></a>7.6 cat连接文件</h2><ul><li>cat 命令读取一个或多个文件，然后复制它们到标准输出</li></ul><figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata"><span class="hljs-keyword">cat</span> [<span class="hljs-keyword">file</span>]<span class="hljs-comment">//复制到标准输出</span><br>cate <span class="hljs-keyword">ls</span>-output.txt<span class="hljs-comment">//显示简短的文本文件</span><br><span class="hljs-keyword">cat</span> -<span class="hljs-keyword">n</span> textfile1 &gt; textfile2<span class="hljs-comment">//把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里,换成&gt;&gt;为附加到文档中</span><br></code></pre></div></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">cat&gt; lazy_dog.txt<span class="hljs-regexp">//</span>等待输入<br>wowowo.<span class="hljs-regexp">//</span>ctrl d结束<br>cat lazy_dog.txt<span class="hljs-regexp">//</span>复制文件内容到标准输出<br>cat &lt; lazy_dog.txt <span class="hljs-regexp">//</span>重定向标准输入，输入源为lazy_dog.txt<br></code></pre></div></td></tr></table></figure><h2 id="7-7管道线"><a href="#7-7管道线" class="headerlink" title="7.7管道线"></a>7.7管道线</h2><ul><li>管道线使得标准输入读取数据并输送到标准输出，一个命令的标准输出可以通过管道传到另一个命令的标准输入</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">command</span>1 | <span class="hljs-keyword">command</span>2<br><span class="hljs-keyword">ls</span> -l <span class="hljs-string">/usr/bin</span> | less<span class="hljs-string">//</span>不加less则直接输出到最后一行等待下一步命令，有less变成浏览文本文件<br></code></pre></div></td></tr></table></figure><ul><li>可以很方便的检测会产生标准输出的命令的运行结果</li></ul><h2 id="7-8过滤器"><a href="#7-8过滤器" class="headerlink" title="7.8过滤器"></a>7.8过滤器</h2><ul><li>用来对数据完成复杂操作，把几个命令放在一起组成一个管道线，过滤器接受输入，以某种方式改变它，然后输出它。</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">ls</span> <span class="hljs-string">/bin</span> <span class="hljs-string">/usr/bin</span> | sort | less<span class="hljs-string">//</span>产生两个目录的有序列表<br></code></pre></div></td></tr></table></figure><h2 id="7-9-uniq-报道或忽略重复行"><a href="#7-9-uniq-报道或忽略重复行" class="headerlink" title="7.9 uniq 报道或忽略重复行"></a>7.9 uniq 报道或忽略重复行</h2><ul><li>uniq 经常和 sort 命令结合起来一起使用，默认情况下在数据列表中删除任何重复行</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">ls</span> <span class="hljs-string">/bin</span> <span class="hljs-string">/usr/bin</span> | sort | uniq | less<br><span class="hljs-keyword">ls</span> <span class="hljs-string">/bin</span> <span class="hljs-string">/usr/bin</span> | sort | uniq -d | less<span class="hljs-string">//</span>只看重复数据列表<br></code></pre></div></td></tr></table></figure><h2 id="7-10-wc-打印行数字数和字节数"><a href="#7-10-wc-打印行数字数和字节数" class="headerlink" title="7.10 wc 打印行数字数和字节数"></a>7.10 wc 打印行数字数和字节数</h2><ul><li>wc（字计数）命令是用来显示文件所包含的行数、字数和字节数。</li><li>如果 wc 不带命令行参数，它接受标准输入。“-l” 选项限制命令输出只能报道行数。添加 wc 到管道线来统计数据，是个很便利的方法。查看我们的有序列表中程序个数</li></ul><figure class="highlight coq"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coq">wc ls-output.txt<br>ls /bin /usr/bin | <span class="hljs-type">sort</span> | <span class="hljs-type">uniq</span> | <span class="hljs-type">wc</span> -l<br></code></pre></div></td></tr></table></figure><h2 id="7-11-grep打印匹配行"><a href="#7-11-grep打印匹配行" class="headerlink" title="7.11 grep打印匹配行"></a>7.11 grep打印匹配行</h2><ul><li>grep用来找到文件中的匹配文本</li></ul><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle"><span class="hljs-keyword">grep</span> pattern [<span class="hljs-keyword">file</span>...]<span class="hljs-comment">//使用方法</span><br>ls <span class="hljs-regexp">/bin /u</span>sr<span class="hljs-regexp">/bin | sort |uniq | grep zip/</span><span class="hljs-regexp">/找到文件名中包含单词zip的所有文件</span><br></code></pre></div></td></tr></table></figure><ul><li> grep   -i 忽略大小写  -v  只打印不匹配的行</li></ul><h2 id="7-12-head-tail打印文件开头部分-结尾部分"><a href="#7-12-head-tail打印文件开头部分-结尾部分" class="headerlink" title="7.12 head/tail打印文件开头部分/结尾部分"></a>7.12 head/tail打印文件开头部分/结尾部分</h2><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">head -n <span class="hljs-number">5</span> ls-output.txt<br>tail -n <span class="hljs-number">10</span> ls-output.txt<br>ls -l <span class="hljs-regexp">/usr/</span>bin | tail -n <span class="hljs-number">5</span> <span class="hljs-regexp">//</span>用于管道线中<br>tail -f <span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/messages/</span><span class="hljs-regexp">/循环读取，跟踪增长情况</span><br></code></pre></div></td></tr></table></figure><h2 id="7-13-tee从stdin读取数据，并同时输出到stdout和文件"><a href="#7-13-tee从stdin读取数据，并同时输出到stdout和文件" class="headerlink" title="7.13 tee从stdin读取数据，并同时输出到stdout和文件"></a>7.13 tee从stdin读取数据，并同时输出到stdout和文件</h2><ul><li>tee 程序从标准输入读入数据，并且同时复制数据到标准输出（允许数据继续随着管道线流动和一个或多个文件。当在某个中间处理阶段来捕捉一个管道线的内容时，这很有帮助。</li></ul><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle">ls <span class="hljs-regexp">/usr/</span>bin | tee ls.txt | <span class="hljs-keyword">grep</span> zip<br></code></pre></div></td></tr></table></figure><ul><li>在 grep 过滤 管道线的内容之前，来捕捉整个目录列表到文件 ls.txt</li></ul><h1 id="8-从shell眼中看世界"><a href="#8-从shell眼中看世界" class="headerlink" title="8.从shell眼中看世界"></a>8.从shell眼中看世界</h1><h2 id="8-1-（字符）展开"><a href="#8-1-（字符）展开" class="headerlink" title="8.1 （字符）展开"></a>8.1 （字符）展开</h2><ul><li>echo 命令显示一行文本</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">echo</span> this is a test<span class="hljs-string">//</span>测试<span class="hljs-keyword">echo</span><br><span class="hljs-keyword">echo</span> *<span class="hljs-string">//</span>观察*的展开,打印了所有文件<br></code></pre></div></td></tr></table></figure><ul><li>shell 中 * 会被展开，当回车键被按下时，shell 在命令被执行前在命令行上自动展开任何符合条件的字符，所以 echo 命令的实际参数并不是 “*”，而 是它展开后的结果。</li></ul><h2 id="8-2-路径名展开"><a href="#8-2-路径名展开" class="headerlink" title="8.2 路径名展开"></a>8.2 路径名展开</h2><ul><li>通配符所依赖的工作机制叫做路径名展开</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">echo</span> <span class="hljs-string">/usr/</span>*<span class="hljs-string">/share</span><br></code></pre></div></td></tr></table></figure><ul><li>隐藏文件的路径名展开</li></ul><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">echo .*<span class="hljs-regexp">//</span>隐藏文件均以原点开头，但是输出包含 <span class="hljs-string">&#x27;.&#x27;</span> 和 <span class="hljs-string">&#x27;..&#x27;</span><br>ls -d .* | less<span class="hljs-regexp">//</span>-d表示只显示当前目录文件，展开正确<br></code></pre></div></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/09/jWC7UYn6ocb1wNM.png" alt="image-20210509211225734"></p><h2 id="8-3波浪线展开"><a href="#8-3波浪线展开" class="headerlink" title="8.3波浪线展开"></a>8.3波浪线展开</h2><ul><li>用在一个单词开头时，它会展开成指定用户的家目录名，如果没有指定用户名，则展开成当前用户的家目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> ~<br><span class="hljs-built_in">echo</span> ~root<br></code></pre></div></td></tr></table></figure><h2 id="8-4-算术表达式展开"><a href="#8-4-算术表达式展开" class="headerlink" title="8.4 算术表达式展开"></a>8.4 算术表达式展开</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> $((expression))<br><span class="hljs-built_in">echo</span> 5+$((<span class="hljs-number">9</span>-<span class="hljs-number">8</span>))<br></code></pre></div></td></tr></table></figure><h2 id="8-5-花括号展开"><a href="#8-5-花括号展开" class="headerlink" title="8.5 花括号展开"></a>8.5 花括号展开</h2><figure class="highlight mathematica"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-variable">echo</span> <span class="hljs-built_in">Front</span><span class="hljs-operator">-</span><span class="hljs-punctuation">&#123;</span><span class="hljs-variable">A</span><span class="hljs-operator">,</span><span class="hljs-variable">B</span><span class="hljs-operator">,</span><span class="hljs-built_in">C</span><span class="hljs-punctuation">&#125;</span><span class="hljs-operator">-</span><span class="hljs-built_in">Back</span><br></code></pre></div></td></tr></table></figure><ul><li>花括号展开模式可能包含一个开头部分叫做<strong>报头</strong>，一个结尾部分叫做<strong>附言</strong>。花括号表达式 本身可能包含一个由<strong>逗号分开</strong>的字符串列表，或者一个<strong>整数区间</strong>，或者单个的字符的区间。这 种模式不能嵌入空白字符</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">echo</span> Number &#123;1.<span class="hljs-string">.5</span>&#125;<br><span class="hljs-keyword">echo</span> &#123;Z.<span class="hljs-string">.A</span>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><strong>花括号展开可以嵌套</strong>，最常见的应用是，创建一系列的文件或目录列表</li></ul><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">mkdir</span> Pics<br><span class="hljs-attribute">cd</span> Pics<br><span class="hljs-attribute">mkdir</span> &#123;<span class="hljs-number">2007</span>..<span class="hljs-number">2019</span>&#125;-<span class="hljs-number">0</span>&#123;<span class="hljs-number">1</span>..<span class="hljs-number">9</span>&#125; &#123;<span class="hljs-number">2007</span>..<span class="hljs-number">2019</span>&#125;-&#123;<span class="hljs-number">10</span>..<span class="hljs-number">12</span>&#125;<br><span class="hljs-attribute">ls</span><br></code></pre></div></td></tr></table></figure><h2 id="8-6-命令替换"><a href="#8-6-命令替换" class="headerlink" title="8.6 命令替换"></a>8.6 命令替换</h2><ul><li>命令替换允许我们把一个命令的输出作为一个展开模式来使用</li><li>不只限制于简单命令,也可以使用整个管道 线</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">ls -l <span class="hljs-constructor">$(<span class="hljs-params">which</span> <span class="hljs-params">cd</span>)</span><span class="hljs-comment">//which得到cd命令的地址，ls显示文件信息</span><br>file <span class="hljs-constructor">$(<span class="hljs-params">ls</span> <span class="hljs-operator">/</span><span class="hljs-params">usr</span><span class="hljs-operator">/</span><span class="hljs-params">bin</span><span class="hljs-operator">/</span><span class="hljs-operator">*</span> | <span class="hljs-params">grep</span> <span class="hljs-params">zip</span>)</span><span class="hljs-comment">//用于管道线，管道线输出结果为file命令的参数列表</span><br></code></pre></div></td></tr></table></figure><h2 id="8-7-引用"><a href="#8-7-引用" class="headerlink" title="8.7 引用"></a>8.7 引用</h2><ul><li><strong>双引号</strong> 把文本放在双引号中，shell 使用的特殊字 符，都失去它们的特殊含义，被当作普通字符来看待</li><li>在双引号中，<strong>参数展开</strong>、<strong>算术表达式展开和命令替换仍然有效</strong></li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">ls</span> -l <span class="hljs-string">&quot;two words.txt&quot;</span><span class="hljs-string">//</span>防止单词分割<br><span class="hljs-keyword">echo</span> $<span class="hljs-params">(cal)</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;$(cal)&quot;</span><span class="hljs-string">//</span>在第一个实例中，没有引用的命令替换导致命令行包含38 个参数。在第二个例子中，命令行只有一个参数，参数中包括嵌入的空格和换行符。<br></code></pre></div></td></tr></table></figure><ul><li><strong>单引号</strong> 禁止所有展开，<strong>包括转义字符</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> text ~/*.txt &#123;a,b&#125; $(<span class="hljs-built_in">echo</span> foo) $((<span class="hljs-number">2</span>+<span class="hljs-number">2</span>)) <span class="hljs-variable">$USER</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;text ~/*.txt &#123;a,b&#125; <span class="hljs-subst">$(echo foo)</span> <span class="hljs-subst">$((2+2)</span>) <span class="hljs-variable">$USER</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER&#x27;</span><br></code></pre></div></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/16/vLt2gD7FqImXs1l.png" alt="image-20210516212438539"></p><h2 id="8-8-转义字符"><a href="#8-8-转义字符" class="headerlink" title="8.8 转义字符"></a>8.8 转义字符</h2><ul><li>\ 作为转义字符，<strong>阻止展开</strong>、<strong>消除特殊含义字符</strong>(比如$)</li><li>在文件名包含特殊字符时起作用</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The balance for user <span class="hljs-variable">$USER</span> is: \$5.00&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The balance for user <span class="hljs-variable">$USER</span> is: <span class="hljs-variable">$5</span>.00&quot;</span><br></code></pre></div></td></tr></table></figure><h1 id="9-键盘高级操作"><a href="#9-键盘高级操作" class="headerlink" title="9 键盘高级操作"></a>9 键盘高级操作</h1><h2 id="9-1-移动光标"><a href="#9-1-移动光标" class="headerlink" title="9.1 移动光标"></a>9.1 移动光标</h2><p><img src="https://i.loli.net/2021/05/16/uBoMmTyZ1h6O8pY.png" alt="image-20210516214256754"></p><p><img src="https://i.loli.net/2021/05/16/uzLkp8iWBnDydVQ.png" alt="image-20210516214317134"></p><h2 id="9-2-修改文本"><a href="#9-2-修改文本" class="headerlink" title="9.2 修改文本"></a>9.2 修改文本</h2><p><img src="https://i.loli.net/2021/05/16/zSIBo6ApVjiXK1t.png" alt="image-20210516214447911"></p><h2 id="9-3-剪切和粘贴文本"><a href="#9-3-剪切和粘贴文本" class="headerlink" title="9.3 剪切和粘贴文本"></a>9.3 剪切和粘贴文本</h2><p><img src="https://i.loli.net/2021/05/16/2byUAgY1EZij9dF.png" alt="image-20210516214558968"></p><h2 id="9-4-自动补全"><a href="#9-4-自动补全" class="headerlink" title="9.4 自动补全"></a>9.4 自动补全</h2><ul><li>按下tab，<strong>自动补全路径名</strong>、<strong>对变量补全</strong>、<strong>用户名</strong>、<strong>命令</strong>、<strong>主机名</strong></li></ul><p><img src="https://i.loli.net/2021/05/16/KutXY6kR3BIFNSm.png" alt="image-20210516215654911"></p><h2 id="9-5-利用历史命令"><a href="#9-5-利用历史命令" class="headerlink" title="9.5 利用历史命令"></a>9.5 利用历史命令</h2><ul><li>搜索历史命令</li></ul><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">history | less <span class="hljs-regexp">//</span>浏览历史列表的内容<br>history | grep <span class="hljs-regexp">/usr/</span>bin<br>!<span class="hljs-number">88</span><span class="hljs-regexp">//</span>展开历史列表中<span class="hljs-number">88</span>行的内容<br></code></pre></div></td></tr></table></figure><ul><li>ctrl-r进入搜索</li></ul><p><img src="https://i.loli.net/2021/05/16/oiT3qkejra7hNlZ.png" alt="image-20210516220947075"></p><p><img src="https://i.loli.net/2021/05/16/2gcmzBNGIEpxy56.png" alt="image-20210516220959790"></p><h2 id="9-8-历史命令展开"><a href="#9-8-历史命令展开" class="headerlink" title="9.8 历史命令展开"></a>9.8 历史命令展开</h2><p><img src="https://i.loli.net/2021/05/16/yMKihNQA8zb9w7c.png" alt="image-20210516221107108"></p><h1 id="10-权限"><a href="#10-权限" class="headerlink" title="10 权限"></a>10 权限</h1><h2 id="10-1-拥有者、组成员和其他人"><a href="#10-1-拥有者、组成员和其他人" class="headerlink" title="10.1 拥有者、组成员和其他人"></a>10.1 拥有者、组成员和其他人</h2><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">id<span class="hljs-regexp">//</span>显示用户id并且映射到一个用户名<br></code></pre></div></td></tr></table></figure><ul><li>用户帐户定义在/etc/passwd 文件里面,用户组定义在/etc/group</li></ul><h2 id="10-2-读取写入和执行"><a href="#10-2-读取写入和执行" class="headerlink" title="10.2 读取写入和执行"></a>10.2 读取写入和执行</h2><p><img src="https://i.loli.net/2021/05/17/eWbKZa19Sig8xMR.png" alt="image-20210517082421786"></p><p><img src="https://i.loli.net/2021/05/17/xRAJLGdOCZpetN1.png" alt="image-20210517082452333"></p><ul><li>剩下的九个字符叫做文件模式，代表着文件所有者、文件组所有者和其他人的读、写和执 行权限。</li></ul><table><thead><tr><th>owner</th><th>group</th><th>world</th></tr></thead><tbody><tr><td>rwx</td><td>rwx</td><td>rwx</td></tr></tbody></table><table><thead><tr><th>属性</th><th>文件</th><th align="center">目录</th></tr></thead><tbody><tr><td>r</td><td>允许打开并 读取文件内 容</td><td align="center">允许列出目录中的内容，前提是目录必须设置了可执 行属性（x）</td></tr><tr><td>w</td><td>允许写入文 件内容或截 断文件。但 是 不允 许 对文件进行重命名或删 除，重命名 或删除是由 目录的属性 决定的</td><td align="center">允许在目录下新建、删除或重命名文件，前提是目录 必须设置了可执行属性（x）</td></tr><tr><td>x</td><td>允许将文件 作为程序来 执行，使用 脚本语言编 写的程序必 须设置为可 读才能被执 行。</td><td align="center">允许进入目录，例如：cd directory</td></tr></tbody></table><p><img src="https://i.loli.net/2021/05/17/hudfGzH9YXKQUoy.png" alt="image-20210517084100337"></p><h2 id="10-3-chomod更改文件模式"><a href="#10-3-chomod更改文件模式" class="headerlink" title="10.3 chomod更改文件模式"></a>10.3 chomod更改文件模式</h2><p>分为八进制表示法和符号表示法两种</p><ul><li>八进制对应3个二进制数字，正好用于映射存储文件模式所使用的方案</li></ul><p><img src="https://i.loli.net/2021/05/17/jcXRZST5bxfyost.png" alt="image-20210517084424709"></p><p><img src="https://i.loli.net/2021/05/17/jXoYl6UBkHpKQLZ.png" alt="image-20210517084701149"></p><p><code>chomod 600 foo.txt</code></p><ul><li>常见映射7 (rwx)，6 (rw-)，5 (r-x)，4 (r–)，和 0 (—)</li></ul><p><img src="https://i.loli.net/2021/05/17/mKYhNkQyPbc94n3.png" alt="image-20210517084931091"></p><table><thead><tr><th>符号表示法</th><th>操作内容</th></tr></thead><tbody><tr><td>u+x</td><td>为文件所有者添加可执行权限</td></tr><tr><td>u-x</td><td>为文件所有者添加可执行权限</td></tr><tr><td>+x</td><td>为文件所有者，用户组，和其他所有人添加可执行权限。等 价于 a+x</td></tr><tr><td>o-rw</td><td>除了文件所有者和用户组，删除其他人的读权限和写权限</td></tr><tr><td>go=rw</td><td>给文件所属的组和文件所属者/组以外的人读写权限。如果 文件所属组或其他人已经拥有执行的权限，执行权限将被移 除</td></tr><tr><td>u+x,go=rw</td><td>给文件拥有者执行权限并给组和其他人读和执行的权限。 多种设定可以用逗号分开</td></tr></tbody></table><h2 id="10-4-借助GUI来设置文件模式"><a href="#10-4-借助GUI来设置文件模式" class="headerlink" title="10.4 借助GUI来设置文件模式"></a>10.4 借助GUI来设置文件模式</h2><ul><li>右击文件或者目录图标</li></ul><p><img src="https://i.loli.net/2021/05/17/J4PnSak8cEHus3z.png" alt="image-20210517085505660"></p><h2 id="10-5-umask设置默认权限"><a href="#10-5-umask设置默认权限" class="headerlink" title="10.5 umask设置默认权限"></a>10.5 umask设置默认权限</h2><table><thead><tr><th>umask值</th><th>权限</th></tr></thead><tbody><tr><td>0000</td><td>-rw-rw-rw-</td></tr><tr><td>0002</td><td>-rw-rw-r–</td></tr></tbody></table><p>有二进制数字1的位置属性被删除</p><p><img src="https://i.loli.net/2021/05/17/JhOeiR3IjDVkBaA.png" alt="image-20210517090349654"></p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">umask<span class="hljs-regexp">//</span>得到掩码值<br>umask <span class="hljs-number">0000</span><span class="hljs-regexp">//</span>设置掩码值<br></code></pre></div></td></tr></table></figure><ul><li>setuid、setgid、sticky位特殊权限</li></ul><p><img src="https://i.loli.net/2021/05/17/q6xOAMbG7DvVsQp.png" alt="image-20210517093707217"></p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">chmod u+s program<span class="hljs-regexp">//</span>授予一个程序 setuid 权限<br>chmod g+s dir<span class="hljs-regexp">//</span>授予一个目录 setgid 权限<br>chmod +t dir<span class="hljs-regexp">//</span>授予一个目录 sticky 权限<br></code></pre></div></td></tr></table></figure><table><thead><tr><th>属性</th><th>结果</th></tr></thead><tbody><tr><td>具有 setuid 属性的程序</td><td>-rw**<u>s</u>**r-xr-x</td></tr><tr><td>具有 setgid 属性的目录</td><td>drwxrw**<u>s</u>**r-x</td></tr><tr><td>设置了 sticky 位的目录</td><td>drwxrwxrw<u><strong>t</strong></u></td></tr></tbody></table><h2 id="10-6-更改身份"><a href="#10-6-更改身份" class="headerlink" title="10.6 更改身份"></a>10.6 更改身份</h2><ol><li>注销系统并以其他用户身份重新登录系统。</li><li> 使用 su 命令</li><li>使用 sudo 命令</li></ol><h2 id="10-7-su命令"><a href="#10-7-su命令" class="headerlink" title="10.7 su命令"></a>10.7 su命令</h2><figure class="highlight inform7"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs inform7">su <span class="hljs-comment">[-<span class="hljs-comment">[l]</span>]</span> <span class="hljs-comment">[user]</span><br></code></pre></div></td></tr></table></figure><ul><li><p>如果包含 “-l” 选项，那么会为指定用户启动一个需要登录的 shell。这意味着会加载此用户 的 shell 环境，并且工作目录会更改到这个用户的家目录。这通常是我们所需要的。**-l可以缩写为-**</p></li><li><p>如果不指 定用户，那么就假定是超级用户</p></li><li><p>输入exit回到原来的shell</p></li></ul><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">su -c <span class="hljs-string">&#x27;command&#x27;</span><span class="hljs-regexp">//</span>格式<br>su -c <span class="hljs-string">&#x27;ls -l /root/*&#x27;</span><br></code></pre></div></td></tr></table></figure><ul><li>传递命令command到新的shell中执行，而不启动这个shell，<strong>引号防止命令展开</strong></li></ul><h2 id="10-8-sudo命令"><a href="#10-8-sudo命令" class="headerlink" title="10.8 sudo命令"></a>10.8 sudo命令</h2><ul><li>sudo 命令不要求超级用户的密码，使用 sudo 命令时，用户 使用他/她自己的密码来认证</li><li>管理员能够配置 sudo 命令，从而允许一个普通用户以不同的身份（通常是超级用户），通过一种非常可控的方式来执行命令</li><li>su 和 sudo 之间的一个重要区别是 sudo 不会重新启动一个 shell，也不会加载 另一个用户的 shell 运行环境</li></ul><h2 id="10-9-chown更改文件所有者和用户组"><a href="#10-9-chown更改文件所有者和用户组" class="headerlink" title="10.9 chown更改文件所有者和用户组"></a>10.9 chown更改文件所有者和用户组</h2><figure class="highlight inform7"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs inform7">chown <span class="hljs-comment">[owner]</span><span class="hljs-comment">[:<span class="hljs-comment">[group]</span>]</span> file<br></code></pre></div></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/17/7x8GI3KmLXQdzCo.png" alt="image-20210517092431871"></p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-selector-attr">[janet@linuxbox ~]</span>$ sudo cp myfile<span class="hljs-selector-class">.txt</span> ~tony<span class="hljs-comment">//用户 janet 把文件从她的目录复制到 tony 的家目录</span><br>Password:<br><span class="hljs-selector-attr">[janet@linuxbox ~]</span>$ sudo ls -l ~tony/myfile<span class="hljs-selector-class">.txt</span><br>-rw-r--r-- <span class="hljs-number">1</span> root root <span class="hljs-number">8031</span> <span class="hljs-number">2008</span>-<span class="hljs-number">03</span>-<span class="hljs-number">20</span> <span class="hljs-number">14</span>:<span class="hljs-number">30</span> /home/tony/myfile<span class="hljs-selector-class">.txt</span><br><span class="hljs-selector-attr">[janet@linuxbox ~]</span>$ sudo chown tony: ~tony/myfile<span class="hljs-selector-class">.txt</span><span class="hljs-comment">//janet 把文件所有者从 root（使用 sudo 命令的原因）改到 tony,同时把文件用户组改为 tony 登录系统时，所属的用户组，碰巧是用户组 tony</span><br><span class="hljs-selector-attr">[janet@linuxbox ~]</span>$ sudo ls -l ~tony/myfile<span class="hljs-selector-class">.txt</span><br>-rw-r--r-- <span class="hljs-number">1</span> tony tony <span class="hljs-number">8031</span> <span class="hljs-number">2008</span>-<span class="hljs-number">03</span>-<span class="hljs-number">20</span> <span class="hljs-number">14</span>:<span class="hljs-number">30</span> /home/tony/myfile.txt<br></code></pre></div></td></tr></table></figure><p><strong>可能存在的问题：</strong></p><ul><li><p>系统中默认的掩码值是 0022，这会禁止用户组成员编辑 属于同组成员的文件，<strong>修改掩码值解决</strong></p></li><li><p>用户组成员创建的文件和目录的用户组，将会设置为用户的主要组，而不是想要的用户组，<strong>设置此目录的setgid位来解决</strong></p></li></ul><h2 id="10-10-更改用户密码"><a href="#10-10-更改用户密码" class="headerlink" title="10.10 更改用户密码"></a>10.10 更改用户密码</h2><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">passwd</span><span class="hljs-meta"> [user]</span><br></code></pre></div></td></tr></table></figure><ul><li>如果你具有超级用户权限，你可以指定一个用户名作为 passwd 命令的参数，这样可以设置 另一个用户的密码。还有其它的 passwd 命令选项对超级用户有效，允许帐号锁定，密码失效,详细内容参考 passwd 命令的手册页</li></ul><p><strong>还有一系列的命令行程序，可以用来创建和维护用户和用户组：</strong></p><ul><li>adduser</li><li>useradd</li><li>groupadd</li></ul><h1 id="11-进程"><a href="#11-进程" class="headerlink" title="11 进程"></a>11 进程</h1><h2 id="11-1-ps查看进程"><a href="#11-1-ps查看进程" class="headerlink" title="11.1 ps查看进程"></a>11.1 ps查看进程</h2><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">ps<br>ps x<span class="hljs-regexp">//</span>显示所有进程<br>ps aux<span class="hljs-regexp">//</span>显示所有进程并获得详细信息<br></code></pre></div></td></tr></table></figure><ul><li>stat状态含义</li></ul><p><img src="https://i.loli.net/2021/05/20/hrSk6liUX3PBRnH.png" alt="image-20210520000339163"></p><h2 id="11-1-top查看进程"><a href="#11-1-top查看进程" class="headerlink" title="11.1 top查看进程"></a>11.1 top查看进程</h2><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">top<span class="hljs-regexp">//</span>动态显示进程<br></code></pre></div></td></tr></table></figure><ul><li>h查看帮助，q退出</li></ul><p><img src="https://i.loli.net/2021/05/20/oUcTAKvsMzGL1nw.png" alt="image-20210520150337666"></p><h2 id="11-2信号"><a href="#11-2信号" class="headerlink" title="11.2信号"></a>11.2信号</h2><p><strong>kill命令可以像进程发送信号，默认是term</strong></p><p><strong>注意，信号既可以用号码，也可以用名字来 指定，包括在前面加上字母“SIG”的名字</strong></p><p><img src="https://i.loli.net/2021/05/20/ebAnMy62OZmvQKG.png" alt="image-20210520151425593"></p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">kill</span> -signal PID<br><span class="hljs-attribute">kill</span> -<span class="hljs-number">1</span> <span class="hljs-number">13546</span><br></code></pre></div></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/20/YZaRbGSUpgExONi.png" alt="image-20210520151123810"></p><p><img src="https://i.loli.net/2021/05/20/8mOYToHh9N2iGvw.png" alt="image-20210520151509766"></p><p><img src="https://i.loli.net/2021/05/20/8SIwb9BRZsUpfl5.png" alt="image-20210520151519019"></p><h2 id="11-3-killall向多个进程发送信号"><a href="#11-3-killall向多个进程发送信号" class="headerlink" title="11.3 killall向多个进程发送信号"></a>11.3 killall向多个进程发送信号</h2><figure class="highlight prolog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs prolog">killall [-u user] [-signal] name...<br></code></pre></div></td></tr></table></figure><h2 id="10-4-关闭系统"><a href="#10-4-关闭系统" class="headerlink" title="10.4 关闭系统"></a>10.4 关闭系统</h2><p>4种方式</p><p>halt    poweroff     reboot    shutdown</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino">sudo reboot<br>sudo shutdown -h now<span class="hljs-comment">//挂起</span><br>sudo shutdown -r now<span class="hljs-comment">//重启</span><br></code></pre></div></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/20/9kgRDvCjIe78wqx.png" alt="image-20210520153312540"></p><h1 id="12-环境"><a href="#12-环境" class="headerlink" title="12 环境"></a>12 环境</h1><h2 id="12-1检查环境"><a href="#12-1检查环境" class="headerlink" title="12.1检查环境"></a>12.1检查环境</h2><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">printenv | less<br>printenv USER<span class="hljs-regexp">//</span>列出指定环境变量的值<br>set | less<br>echo <span class="hljs-variable">$HOME</span><span class="hljs-regexp">//</span>用echo命令查看变量内容<br></code></pre></div></td></tr></table></figure><ul><li>环境中的别名无法使用set命令和printenv命令显示，想要查看别名，可以使用不包含参数的alias</li><li>查找用/  ,区分大小写         </li></ul><h2 id="12-2-值得注意的环境变量"><a href="#12-2-值得注意的环境变量" class="headerlink" title="12.2 值得注意的环境变量"></a>12.2 值得注意的环境变量</h2><p><img src="https://i.loli.net/2021/05/20/gLDkbYCN5SIizAs.png" alt="image-20210520190132204"></p><p><img src="https://i.loli.net/2021/05/20/ToLVdIyuvtKcSqh.png" alt="image-20210520190143788"></p><h2 id="12-3-如何建立环境"><a href="#12-3-如何建立环境" class="headerlink" title="12.3 如何建立环境"></a>12.3 如何建立环境</h2><ul><li>是登录 shell 会话</li></ul><p><img src="https://i.loli.net/2021/05/20/hmF93cLQfusD74e.png" alt="image-20210520190605756"></p><p><img src="https://i.loli.net/2021/05/20/z9yAQ1RnCbrXg8a.png" alt="image-20210520190645227"></p><ul><li>非登录shell会话</li></ul><p><img src="https://i.loli.net/2021/05/20/9gfGsCna7NMTFAc.png" alt="image-20210520190712283"></p><p>非登录 shell 会话也会继承它们父进程的环境设置，通常是一 个登录 shell</p><h2 id="12-4-启动文件"><a href="#12-4-启动文件" class="headerlink" title="12.4 启动文件"></a>12.4 启动文件</h2><ul><li>当我们 输入 ls 后，shell 不会查找整个计算机系统来找到 /bin/ls（ls 命令的全路径名），相反，它查找 一个目录列表，这些目录包含在 PATH 变量中</li></ul><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HOME</span><span class="hljs-regexp">/bin/</span><span class="hljs-regexp">/修改 PATH 变量，添加目录 $HOME/</span>bin 到目录列表的末尾<br></code></pre></div></td></tr></table></figure><h2 id="12-5-修改环境、使用文本编辑器"><a href="#12-5-修改环境、使用文本编辑器" class="headerlink" title="12.5 修改环境、使用文本编辑器"></a>12.5 修改环境、使用文本编辑器</h2><ul><li>添加目录到你的 PATH 变量或者是定义额外的环境变量，要把这些更改放置 到.bash_profile 文件中</li></ul><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">gedit some_file<span class="hljs-regexp">//</span>如果所输入的文件名不存在，编辑器则会假定你想要创建一个新文件<br></code></pre></div></td></tr></table></figure><ul><li><strong>当我们编辑一个重要的配置文件时</strong>，<strong>首先创建一个这个文件的备份总是一个不错的主意</strong>。<strong>这样能避免我们在编辑文件时弄乱文件</strong></li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">cp <span class="hljs-string">.bashrc</span> <span class="hljs-string">.bashrc.bak</span><br></code></pre></div></td></tr></table></figure><ul><li>ctrl O 保存文件，ctrl X 退出</li></ul><p><img src="https://i.loli.net/2021/05/20/M9YAjK1rveEpHuf.png" alt="image-20210520192935152"></p><ul><li>我们对于文件.bashrc 的修改不会生效，直到我们关闭终端会话，再重新启动一个新的会话，因 为.bashrc 文件只是在刚开始启动终端会话时读取。然而，我们可以强迫 bash 重新读取修改过 的.bashrc 文件,用命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> .bashrc<br></code></pre></div></td></tr></table></figure><h1 id="13-vi入门"><a href="#13-vi入门" class="headerlink" title="13 vi入门"></a>13 vi入门</h1><h2 id="13-1-启动和退出"><a href="#13-1-启动和退出" class="headerlink" title="13.1 启动和退出"></a>13.1 启动和退出</h2><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">vi<span class="hljs-regexp">//</span>启动vi<br>:q<span class="hljs-regexp">//</span>退出vi<br>:q!<span class="hljs-regexp">//</span>强制退出（一般是修改没保存）<br><span class="hljs-regexp">//</span>连按两下esc可以回到命令模式<br></code></pre></div></td></tr></table></figure><h2 id="13-2-编辑模式"><a href="#13-2-编辑模式" class="headerlink" title="13.2 编辑模式"></a>13.2 编辑模式</h2><ul><li><p>刚进入vi<strong>进入到命令模式</strong>，每一个按键都是命令，按i键进入输入模式</p></li><li><p>按两下esc回到命令模式，输入:w保存</p></li><li><p>小贴示：如果你阅读 vim 的文档，你会发现命令模式被（令人困惑地）叫做普通模式（<strong>normal mode</strong>)，ex 命令叫做命令模式</p></li></ul><h2 id="13-3-光标移动"><a href="#13-3-光标移动" class="headerlink" title="13.3 光标移动"></a>13.3 光标移动</h2><p><img src="https://i.loli.net/2021/05/20/sW1jMBxfzVZ93YL.png" alt="image-20210520194709123"></p><ul><li>G是大写，要配合shift</li><li>vi命令都可以加上数字前缀，<strong>5j</strong>可以使光标下移5行</li></ul><h2 id="13-4-基本编辑"><a href="#13-4-基本编辑" class="headerlink" title="13.4 基本编辑"></a>13.4 基本编辑</h2><h3 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h3><ul><li><p>insert命令做不到</p></li><li><p>a 命令，在当前光标后追加（进入插入模式）</p></li><li><p>A命令，在当前行末尾追加（进入插入模式）</p></li></ul><h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><p><img src="https://i.loli.net/2021/05/20/XwC2vM6HSQy7oE5.png" alt="image-20210520195958743"></p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><img src="https://i.loli.net/2021/05/20/cdAWblZTEtoHj9U.png" alt="image-20210520200056415"></p><ul><li><strong>手速要快</strong></li><li>按u撤销删除</li></ul><h3 id="剪切复制和粘贴"><a href="#剪切复制和粘贴" class="headerlink" title="剪切复制和粘贴"></a>剪切复制和粘贴</h3><ul><li>d 命令不仅删除文本，<strong>它还“剪切”文本</strong>。每次我们使用 d 命令，删除的部分被复制到一 个粘贴缓冲区中（看作剪切板）</li><li>y命令复制文本</li></ul><p><img src="https://i.loli.net/2021/05/20/qo8fx7X9ebzU6hM.png" alt="image-20210520201812389"></p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>p</td><td>粘贴至下一行（无论光标在这一行的哪里）</td></tr><tr><td>P</td><td>粘贴至上一行（无论光标在这一行的哪里）</td></tr></tbody></table><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><ul><li>J 命令合并光标所在行与下一行</li></ul><h2 id="13-5-搜索和替换"><a href="#13-5-搜索和替换" class="headerlink" title="13.5 搜索和替换"></a>13.5 搜索和替换</h2><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><ul><li><strong>行内搜索</strong>用 <strong>fa</strong> 命令；按 <strong>;</strong> 继续行内搜索</li><li>搜索整个文件 <code>/</code>,重复搜索<code>n</code>即可</li></ul><h3 id="全局搜索和替换"><a href="#全局搜索和替换" class="headerlink" title="全局搜索和替换"></a>全局搜索和替换</h3><figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata">:%s/<span class="hljs-keyword">Line</span>/<span class="hljs-keyword">line</span>/<span class="hljs-keyword">g</span><span class="hljs-comment">//把文件中所有的单词Line都更改为line</span><br>:1,<span class="hljs-variable">$s</span>/<span class="hljs-keyword">Line</span>/<span class="hljs-keyword">line</span>/<span class="hljs-keyword">g</span><span class="hljs-comment">//与前面那个一样</span><br>:%s/<span class="hljs-keyword">line</span>/<span class="hljs-keyword">Line</span>/gv<span class="hljs-comment">//把line改回去，c要求每一次替换前确认替换</span><br></code></pre></div></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/20/1sBe7koihgSEmqO.png" alt="image-20210520203830502"></p><p><img src="https://i.loli.net/2021/05/20/oyv7kOZlnewbJ6q.png" alt="image-20210520210031330"></p><h2 id="13-6-编辑多个文件"><a href="#13-6-编辑多个文件" class="headerlink" title="13.6 编辑多个文件"></a>13.6 编辑多个文件</h2><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">vim file1 file2 file3...<span class="hljs-regexp">//</span>用vi会出现问题（可能vi不支持）<br>:bn<span class="hljs-regexp">//</span>切换到下一个文件（强制切换加上！）<br>:bp<span class="hljs-regexp">//</span>切换到上一个文件<br>:buffers<span class="hljs-regexp">//</span>显示缓冲区<br>:buffer <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><ul><li>载入更多文件</li></ul><figure class="highlight elixir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elixir"><span class="hljs-symbol">:e</span> ls-output.txt<br></code></pre></div></td></tr></table></figure><ul><li>将一个文件的内容复制到另一个文件: 用yy复制buffer切换p粘贴即可</li><li>将整个文件插入另一个文件（<strong>注意是在光标位置之后</strong>）</li></ul><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">:r foo.txt<span class="hljs-regexp">//</span>在光标位置之后将文件读入并<br></code></pre></div></td></tr></table></figure><h2 id="13-7-保存工作"><a href="#13-7-保存工作" class="headerlink" title="13.7 保存工作"></a>13.7 保存工作</h2><ul><li>在命令模式下输入 <strong>ZZ</strong> 即可</li><li>输入:w</li><li><strong>另存为</strong>   <code>:w foo1.txt</code>    (<strong>注意这样是另存为foo1，现在仍在编辑foo</strong>)</li></ul><h1 id="14-定制提示符"><a href="#14-定制提示符" class="headerlink" title="14. 定制提示符"></a>14. 定制提示符</h1><h2 id="14-1-分解提示符"><a href="#14-1-分解提示符" class="headerlink" title="14.1 分解提示符"></a>14.1 分解提示符</h2><figure class="highlight autoit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autoit">echo $PS1<br>[\u<span class="hljs-symbol">@\h</span> \W]\$<br></code></pre></div></td></tr></table></figure><ul><li>转移字符表</li></ul><p><img src="https://i.loli.net/2021/05/20/3qRmSN1zsGfYDFt.png" alt="image-20210520212857378"></p><h2 id="14-2-换一种提示符"><a href="#14-2-换一种提示符" class="headerlink" title="14.2 换一种提示符"></a>14.2 换一种提示符</h2><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">ps1_old=<span class="hljs-string">&quot;$PS1&quot;</span><span class="hljs-regexp">//</span>首先备份现有的提示符<br>PS1=<span class="hljs-string">&quot;$ps1_old&quot;</span><span class="hljs-regexp">//</span>恢复原有的提示符<br>PS1=<span class="hljs-string">&quot;\[\033[0;41m\]&lt;\u@\h \W&gt;\$\[\033[0m\]&quot;</span><span class="hljs-regexp">//</span>前一个使输出系统信息为红色，后一个使输入文字信息为黑色<br></code></pre></div></td></tr></table></figure><ul><li><p><img src="https://i.loli.net/2021/05/20/WNLgqOom8sxfa67.png" alt="image-20210520214444090"></p></li><li><p>背景颜色</p></li></ul><p><img src="https://i.loli.net/2021/05/20/izWGYmSojlecdby.png" alt="image-20210520214456315"></p><ul><li>光标设置</li></ul><p><img src="https://i.loli.net/2021/05/20/6v5FyTnUad3pf2E.png" alt="image-20210520214523060"></p><ul><li><code>PS1=&quot;\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\]&lt;\u@\h \W&gt;\$&quot;</code>使用上面的编码，我们将构建一个提示符，每次当这个提示符出现的时候，会在屏幕的上方 画出一个包含时钟（由黄色文本渲染）的红色长条</li></ul><p><img src="https://i.loli.net/2021/05/20/aRQklMexicdyg7v.png" alt="image-20210520214744772"></p><p><img src="https://i.loli.net/2021/05/20/uCLZIvj36J9mbMa.png" alt="image-20210520214754413"></p><h2 id="14-3-保存提示符"><a href="#14-3-保存提示符" class="headerlink" title="14.3 保存提示符"></a>14.3 保存提示符</h2><ul><li>把下面两行添加到.bashr文件中去</li></ul><figure class="highlight taggerscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs taggerscript">PS1=&quot;<span class="hljs-symbol">\[</span><span class="hljs-symbol">\0</span>33[s<span class="hljs-symbol">\0</span>33[0;0H<span class="hljs-symbol">\0</span>33[0;41m<span class="hljs-symbol">\0</span>33[K<span class="hljs-symbol">\0</span>33[1;33m<span class="hljs-symbol">\t</span><span class="hljs-symbol">\0</span>33[0m<span class="hljs-symbol">\0</span>33[u<span class="hljs-symbol">\]</span>&lt;<span class="hljs-symbol">\u</span>@<span class="hljs-symbol">\h</span> <span class="hljs-symbol">\W</span>&gt;<span class="hljs-symbol">\$</span>&quot;<br>export PS1<br></code></pre></div></td></tr></table></figure><h1 id="15-软件包管理"><a href="#15-软件包管理" class="headerlink" title="15 软件包管理"></a>15 软件包管理</h1><h2 id="15-1-打包系统"><a href="#15-1-打包系统" class="headerlink" title="15.1 打包系统"></a>15.1 打包系统</h2><p><img src="https://i.loli.net/2021/05/21/5Lc8zKxlAhk6sbF.png" alt="image-20210521001903091"></p><h2 id="15-2-软件包的工作方式"><a href="#15-2-软件包的工作方式" class="headerlink" title="15.2 软件包的工作方式"></a>15.2 软件包的工作方式</h2><ul><li>Linux系统中几乎所有的软件都可以在互联网上找到。其中大多数软件由发行商以包文件的形式提供，剩下的则以源码形式存在，可以手动安装。</li><li>在包管理系统中软件的基本单元是包文件。包文件是一个构成软件包的文件压缩集合。一个软件包可能由大量程序以及支持这些程序的数据文件组成。</li><li>系统发行版的用户可以在一个中心资源库中得到这些软件包，这个资 源库可能包含了成千上万个软件包，每一个软件包都是专门为这个系统发行版建立和维护的。</li><li>程序很少独立工作；他们需要依靠其他程序的组件来完成他们的工作。现代的软件包管理系统都提供了一些依赖项解析方法，以确保安装软 件包时，其所有的依赖也被安装。</li></ul><p><img src="https://i.loli.net/2021/05/21/drgCb8nsiqyk2xo.png" alt="image-20210521002838341.png"></p><h2 id="15-3-常见的软件包管理任务"><a href="#15-3-常见的软件包管理任务" class="headerlink" title="15.3 常见的软件包管理任务"></a>15.3 常见的软件包管理任务</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><img src="https://i.loli.net/2021/05/21/LedzpiuMHOkWIqY.png" alt="image-20210521004022448"></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>下载安装</li></ul><p><img src="https://i.loli.net/2021/05/21/tHxnfUcEde1Z5pL.png" alt="image-20210521004553392"></p><ul><li>下载好文件直接安装</li></ul><p><img src="https://i.loli.net/2021/05/21/GypJB4ZO7KVkMr1.png" alt="image-20210521004702263"></p><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p><img src="https://i.loli.net/2021/05/21/EytqX3gmzhMAP4O.png" alt="image-20210521004901986"></p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p><img src="https://i.loli.net/2021/05/21/7L4jvUham3ocM6i.png" alt="image-20210521004921977"></p><ul><li>通过下载的软件包升级</li></ul><p><img src="https://i.loli.net/2021/05/21/fKUDZSp84tj2J7F.png" alt="image-20210521004952589"></p><h3 id="列出"><a href="#列出" class="headerlink" title="列出"></a>列出</h3><p><img src="https://i.loli.net/2021/05/21/hIwbFPQ5T6jiYL2.png" alt="image-20210521005010163"></p><h3 id="确认是否安装"><a href="#确认是否安装" class="headerlink" title="确认是否安装"></a>确认是否安装</h3><p><img src="https://i.loli.net/2021/05/21/56pQj3VXBNYA2SI.png" alt="image-20210521005036005"></p><h3 id="显示安装包信息"><a href="#显示安装包信息" class="headerlink" title="显示安装包信息"></a>显示安装包信息</h3><p><img src="https://i.loli.net/2021/05/21/arlJ9ZHDbm2qy3B.png" alt="image-20210521005059496"></p><h3 id="查找安装了某个文件的包"><a href="#查找安装了某个文件的包" class="headerlink" title="查找安装了某个文件的包"></a>查找安装了某个文件的包</h3><p><img src="https://i.loli.net/2021/05/21/ysDFz2bCWNqKOjo.png" alt="image-20210521005132673"></p><h1 id="16-存储介质"><a href="#16-存储介质" class="headerlink" title="16 存储介质"></a>16 存储介质</h1><h2 id="16-1存储设备的挂载与卸载"><a href="#16-1存储设备的挂载与卸载" class="headerlink" title="16.1存储设备的挂载与卸载"></a>16.1存储设备的挂载与卸载</h2><ul><li><p>Linux 在<strong>单一文件系统树中</strong>维 护连接在各个节点的各种设备。在MS-DOS 和 Windows 系 统中，每个设备（例如 C:\，D:\，等）保持着单独的文件系统树</p></li><li><p>文件 <strong>/etc/fstab</strong> 列出了系统启动时要挂载的设备 <code> cat /etc/fstab</code></p></li></ul><p><img src="https://i.loli.net/2021/05/21/xjSkL7WBlRZEidI.png" alt="image-20210521083937799"></p><p><img src="https://i.loli.net/2021/05/21/zx9uHMw3dt7W5hC.png" alt="image-20210521083901885"></p><ul><li>查看已挂载的文件系统列表   <code>mount</code>命令</li></ul><p>若有光盘：<img src="https://i.loli.net/2021/05/21/Gtmx9kXPFuNiscj.png" alt="image-20210521084629825"></p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">umount <span class="hljs-regexp">/dev/</span>hdc<span class="hljs-regexp">//</span>卸载CDROM（需要root权限）<br>mkdir <span class="hljs-regexp">/mnt/</span>cdrom<span class="hljs-regexp">//</span>建立新目录<br>mount -t iso9660 <span class="hljs-regexp">/dev/</span>hdc <span class="hljs-regexp">/mnt/</span>cdrom<span class="hljs-regexp">//</span>将CDROM挂载到新的挂载点，-t指定文件系统类型<br></code></pre></div></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/21/fAJVmgIrEhOsU9B.png" alt="image-20210521084925810"></p><h2 id="16-2-确定设备名称"><a href="#16-2-确定设备名称" class="headerlink" title="16.2 确定设备名称"></a>16.2 确定设备名称</h2><ul><li>列出/dev 目录下的内容 <code>ls /dev</code></li></ul><p><img src="https://i.loli.net/2021/05/21/eQScTwflgDy3sI9.png" alt="image-20210521085528629"></p><ul><li><code> tail -f /var/log/messages</code> 对操作系统实时监测，<strong>插入设备观察设备名称</strong>，知道设备名称之后挂载设备</li><li>挂载之后设备只要不拔下来，并且系统不重启，设备名称就不会发生变化</li><li>用<code>df</code>命令显示目前在 Linux 系统上的文件系统磁盘使用情况统计</li></ul><h2 id="16-3-创建新文件系统"><a href="#16-3-创建新文件系统" class="headerlink" title="16.3 创建新文件系统"></a>16.3 创建新文件系统</h2><h3 id="用fdisk修改文件系统"><a href="#用fdisk修改文件系统" class="headerlink" title="用fdisk修改文件系统"></a>用fdisk修改文件系统</h3><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo umount <span class="hljs-regexp">/dev/</span>sdb1<br>sudo fdisk <span class="hljs-regexp">/dev/</span>sdb<br>Command (m <span class="hljs-keyword">for</span> help):m<span class="hljs-regexp">//</span>显示菜单<br>Command (m <span class="hljs-keyword">for</span> help):p<span class="hljs-regexp">//</span>显示设备分区表<br>Command (m <span class="hljs-keyword">for</span> help):l<span class="hljs-regexp">//</span>显示可能的文件系统列表及对应的id<br>Command (m <span class="hljs-keyword">for</span> help):t<span class="hljs-regexp">//</span>修改<br>Hex code (type L to list codes): <span class="hljs-number">83</span><br>Command (m <span class="hljs-keyword">for</span> help):w<span class="hljs-regexp">//</span>保存<br></code></pre></div></td></tr></table></figure><h3 id="使用mkfs创建新的文件系统"><a href="#使用mkfs创建新的文件系统" class="headerlink" title="使用mkfs创建新的文件系统"></a>使用mkfs创建新的文件系统</h3><p>make file system</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo mkfs -t ext3 <span class="hljs-regexp">/dev/</span>sdb1<span class="hljs-regexp">//</span>指定ext4为文件系统类型<br>sudo mkfs -t vfat <span class="hljs-regexp">/dev/</span>sdb1<span class="hljs-regexp">//</span>指定vfat为文件系统类型<br></code></pre></div></td></tr></table></figure><h2 id="16-4-文件系统的检查与修复"><a href="#16-4-文件系统的检查与修复" class="headerlink" title="16.4 文件系统的检查与修复"></a>16.4 文件系统的检查与修复</h2><ul><li><code> sudo fsck /dev/sdb1</code>修复损坏的文件系统</li><li>已修复的文件会存放在各个文件系统根目录下的lost+found 目录里面</li></ul><h2 id="16-5-设备之间直接移动数据"><a href="#16-5-设备之间直接移动数据" class="headerlink" title="16.5 设备之间直接移动数据"></a>16.5 设备之间直接移动数据</h2><ul><li> <code>dd</code>命令实现将数据块从一处复制到另一处</li></ul><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">dd <span class="hljs-keyword">if</span>=input_file of=output_file [bs=block_size [count=blocks]]<br>dd <span class="hljs-keyword">if</span>=<span class="hljs-regexp">/dev/</span>sdb of=<span class="hljs-regexp">/dev/</span>sdc<span class="hljs-regexp">//</span>如果连接两个设备到计算机上，它们各自被分配到设备<span class="hljs-regexp">/dev/</span>sdb和<span class="hljs-regexp">/dev/</span>sdc<br>上把第一个驱动器中的所有数据复制到第二个驱动器中<br>dd <span class="hljs-keyword">if</span>=<span class="hljs-regexp">/dev/</span>sdb of=flash_drive.img<span class="hljs-regexp">//</span>如果只有第一个驱动器被连接到计算机上，我们可以把它的内容复制到一个普通文件<br>中供以后恢复或复制数据<br></code></pre></div></td></tr></table></figure><p>==注意==：</p><p>dd命令的功能非常强大，起名取自“data definition”（数据定义），然而有时候也会被成为“destory disk”（摧毁磁盘），因为用户经常不小心输错if 或者of 说明。<strong>在Enter之前，一定要检查一遍if of说明</strong>！</p><h3 id="向可刻录CD写入数据"><a href="#向可刻录CD写入数据" class="headerlink" title="向可刻录CD写入数据"></a>向可刻录CD写入数据</h3><p><strong>写入一个可记录的 CD-ROM（一个 CD-R 或者是 CD-RW）由两步组成</strong></p><ul><li>首先，构建一个 iso 映像文件，这就是一个 CD-ROM 的文件系统映像</li><li>第二步，把这个映像文件写入到 CD-ROM 媒介中。</li></ul><h4 id="创建iso映像文件"><a href="#创建iso映像文件" class="headerlink" title="创建iso映像文件"></a>创建iso映像文件</h4><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-selector-tag">dd</span> <span class="hljs-keyword">if</span>=/dev/cdrom of=ubuntu<span class="hljs-selector-class">.iso</span><span class="hljs-comment">//使用 dd 命令来读取 CD-ROW 中的所有数据块，并把它们复制到本地文件中</span><br>genisoimage -o cd-rom<span class="hljs-selector-class">.iso</span> -R -J ~/cd-rom-files<span class="hljs-comment">//用genisoimage命令来从文件集合中创建一个映像</span><br><span class="hljs-comment">//“-R” 选项添加元数据为 Rock Ridge 扩展，这允许使用长文件名和 POSIX 风格的文件权限。 “-J” 选项使 Joliet 扩展生效，这样Windows中就支持长文件名了</span><br></code></pre></div></td></tr></table></figure><h4 id="写入CD-ROM中"><a href="#写入CD-ROM中" class="headerlink" title="写入CD-ROM中"></a>写入CD-ROM中</h4><ul><li>直接挂载iso映像文件</li></ul><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">mkdir <span class="hljs-regexp">/mnt/i</span>so_image<span class="hljs-regexp">//</span>创建挂载点<br>mount -t iso9660 -o loop image.iso <span class="hljs-regexp">/mnt/i</span>so_image<span class="hljs-regexp">//</span>使用mount命令的-o loop选项、指定文件系统类型的-t iso9660选项，将iso映像文件当作设备挂载到文件系统树（可以把它当作真实的CD使用）<br>md5sum image.iso<span class="hljs-regexp">//</span>使用md5sum命令产生十六进制书校验文件(检查完整性)<br>md5sum <span class="hljs-regexp">/dev/</span>cdrom<br></code></pre></div></td></tr></table></figure><ul><li>擦除可刻录CD、刻录映像文件</li><li><img src="https://i.loli.net/2021/05/21/Zxok4GRg3XhEPYT.png" alt="image-20210521101401935"></li></ul><h1 id="17-联网"><a href="#17-联网" class="headerlink" title="17 联网"></a>17 联网</h1><h2 id="17-1-网络检查与监控"><a href="#17-1-网络检查与监控" class="headerlink" title="17.1 网络检查与监控"></a>17.1 网络检查与监控</h2><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><ul><li><p><code>ping</code>命令： ping 命令发送一个特殊的网络数据包，叫做 ICMP ECHO_REQUEST，到一台指定的主机。大多数接收这个包的网络设备将会回复它，来 允许网络连接验证</p></li><li><p><strong>注意</strong>：大多数网络设备（包括 Linux 主机）都可以被配置为忽略这些数据包。通常，这样 做是出于网络安全原因，部分地遮蔽一台主机免受一个潜在攻击者地侵袭。配置防火墙来阻塞 IMCP 流量也很普遍。</p></li></ul><h3 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h3><ul><li>traceroute程序完整过程：首先它发送一份TTL字段为1的IP数据包给目的主机，处理这个数据包的第一个路由器将TTL值减1，然后丢弃该数据报，并给源主机发送一个ICMP报文（“超时”信息，这个报文包含了路由器的IP地址，这样就得到了第一个路由器的地址），然后traceroute发送一个TTL为2的数据报来得到第二个路由器的IP地址，继续这个过程，直至这个数据报到达目的主机</li><li>输出结果中会<strong>列出网络流量从本地系统到指定主机的所有跳（hop）数</strong>，其中没有提供标识信息的路由器用*号表示</li></ul><h3 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h3><ul><li><code>ip a</code>检查系统的网络接口和路由表</li><li>当执行日常网络诊断时，要查看的重要信息是每个网络接口第四行开头出现的单词“<strong>UP</strong>”， 说明这个网络接口已经生效，还要查看第二行中 inet字段出现的有效 IP 地址。</li></ul><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><ul><li><code>netstat</code>t 程序被用来检查各种各样的网络设置和统计数据。通过此命令的许多选项，我们可以看 看网络设置中的各种特性</li><li>使用“-ie”选项，我们能够查看系统中的网络接口</li><li>“-r”选项能够显示内核的网络路由表，从中能够看出分组时如何在网络之间传送的</li></ul><h2 id="17-2-通过网络来传输文件"><a href="#17-2-通过网络来传输文件" class="headerlink" title="17.2 通过网络来传输文件"></a>17.2 通过网络来传输文件</h2><h3 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h3><ul><li><strong>FTP指的是协议，ftp指的是与之同名的程序</strong></li></ul><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>ftp fileserver</td><td>连接名叫fileserver的ftp服务器</td></tr><tr><td>cd pub/</td><td>在大多数匿名的 FTP 服务器中，支持公共 下载的文件都能在目录 pub 下找到</td></tr><tr><td>lcd Desktop</td><td>将本地目录改为 ~/Desktop,ftp程序工作目录默认在 ~/Desktop下</td></tr><tr><td>get …iso</td><td>将远程系统文件传至本地，即~/Desktop</td></tr><tr><td>bye</td><td>登出远程服务器</td></tr></tbody></table><ul><li>lftp-更好的ftp：包括多协议支持（包括 HTTP），若下载失败会自动地重新下载， 后台处理，用 tab 按键来补全路径名</li></ul><h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3><ul><li>支持递归下载、后台下载、断点续传</li></ul><p><code>wget http://linuxcommand.org/index.php</code></p><h2 id="17-3-与远程主机的通信"><a href="#17-3-与远程主机的通信" class="headerlink" title="17.3 与远程主机的通信"></a>17.3 与远程主机的通信</h2><ul><li><strong>都在OpenSSH包中</strong></li></ul><h3 id="ssh（Secure-Shell"><a href="#ssh（Secure-Shell" class="headerlink" title="ssh（Secure Shell)"></a>ssh（Secure Shell)</h3><ul><li>认证身份</li><li>加密本地与远程主机通信<strong>（从22端口）</strong></li></ul><p><strong>SSH 由两部分组成。</strong>(<strong>必须都要安装</strong>)</p><p>1.SSH服务端运行在远端主机上，在端口 22 上监听收到的外部连接</p><p>2.SSH客户端用在本地系统中，用来和远端服务器通信</p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>ssh bob@remote-sys</td><td>以用户bob的身份连接远程主机</td></tr><tr><td>ssh remote-sys free</td><td>在远程主机上运行free命令并在本地显示结果</td></tr><tr><td><code>ssh remote-sys &#39;ls *&#39; &gt; dirlist.txt</code></td><td>输出到本地主机文件（ls命令用单引号括起来防止在本地展开）</td></tr><tr><td><code>ssh remote-sys &#39;ls * &gt; dirlist.txt&#39;</code></td><td>输出到远程主机（注意单引号位置）</td></tr><tr><td><code>ssh -X remote-sys;xload</code></td><td>在远程主机上运行xload窗口出现在本地主机（-X传界面）</td></tr></tbody></table><h2 id="scp与sftp"><a href="#scp与sftp" class="headerlink" title="scp与sftp"></a>scp与sftp</h2><h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><ul><li>scp（安全复制）被用来复制文件，与熟悉的 cp 程序非常相似。<strong>最显著的区别就是</strong>源或者目标 路径名要以远端主机的名字，后跟一个冒号字符开头</li></ul><figure class="highlight dart"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dart">scp bob<span class="hljs-meta">@remote</span>-sys:<span class="hljs-built_in">document</span>.txt<span class="hljs-comment">//以bob账号登入远程主机并复制文件</span><br></code></pre></div></td></tr></table></figure><h3 id="sftp"><a href="#sftp" class="headerlink" title="sftp"></a>sftp</h3><ul><li><p>ftp 程序的安全替代品,是 sftp 不需要远端系统中运行 FTP 服务端。 它<strong>仅仅需要 SSH 服务端</strong>。这意味着任何一台能用 SSH 客户端连接的远端机器，也可当作类似 于 FTP 的服务器来使用。</p></li><li><p>用法参照ftp</p></li></ul><h1 id="18-查找文件"><a href="#18-查找文件" class="headerlink" title="18 查找文件"></a>18 查找文件</h1><h2 id="18-1-locate查找文件"><a href="#18-1-locate查找文件" class="headerlink" title="18.1 locate查找文件"></a>18.1 locate查找文件</h2><ul><li><p><code>locate bin/zip</code>列出所有<strong>以zip开头的程序，目录以bin/结尾</strong>的程序</p></li><li><p>结合grep命令使用更高效</p></li><li><p><img src="https://i.loli.net/2021/05/21/yo7RNv5YcCdBLOJ.png" alt="image-20210521150632972"></p></li></ul><h2 id="18-2-find-复杂的文件的查找方法"><a href="#18-2-find-复杂的文件的查找方法" class="headerlink" title="18.2 find-复杂的文件的查找方法"></a>18.2 find-复杂的文件的查找方法</h2><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino">find ~<span class="hljs-comment">//指定一个目录为查找范围</span><br>find ~ | wc -l<br></code></pre></div></td></tr></table></figure><h3 id="测试条件"><a href="#测试条件" class="headerlink" title="测试条件"></a>测试条件</h3><figure class="highlight sqf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sqf"><span class="hljs-built_in">find</span> ~ -<span class="hljs-built_in">type</span> d | wc -l<span class="hljs-comment">//type d限制只查找目录</span><br><span class="hljs-built_in">find</span> ~ -<span class="hljs-built_in">type</span> f | wc -l<span class="hljs-comment">//限制只查找普通文件</span><br><span class="hljs-built_in">find</span> ~ -<span class="hljs-built_in">type</span> f -<span class="hljs-built_in">name</span> <span class="hljs-string">&quot;*.JPG&quot;</span> -<span class="hljs-built_in">size</span> +<span class="hljs-number">1</span>M | wc -l<span class="hljs-comment">//查找所有匹配*.JPG而且大于1MB的普通文件（加入双引号防止路径名扩展）</span><br></code></pre></div></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/21/YWR1kuLNoGfaeDC.png" alt="image-20210521151825372"></p><p><img src="https://i.loli.net/2021/05/21/OUr4HMtkezm3GFA.png" alt="image-20210521151931893"></p><p><img src="https://i.loli.net/2021/05/21/7NWjYOqUIm6g4cx.png" alt="image-20210521151953549"></p><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><ul><li>查找权限不为0600的文件和权限不为0700的目录</li></ul><figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">find ~ \( -<span class="hljs-keyword">type</span> <span class="hljs-type">f </span>-<span class="hljs-keyword">not</span> -perm <span class="hljs-number">0600</span> \) -<span class="hljs-keyword">or</span> \( -<span class="hljs-keyword">type</span> <span class="hljs-type">d </span>-<span class="hljs-keyword">not</span> -perm <span class="hljs-number">0700</span> \)<br></code></pre></div></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/21/sbKMCjn3u47NfJa.png" alt="image-20210521154546432"></p><ul><li>注意默认使用and    以及括号组合字符</li><li>对于被分隔的表达式，不一定默认求值        <code>expr1 -operator expr2</code></li></ul><p><img src="https://i.loli.net/2021/05/21/ZUD9pGVQPNCs68o.png" alt="image-20210521154738960"></p><h3 id="预定义操作"><a href="#预定义操作" class="headerlink" title="预定义操作"></a>预定义操作</h3><ul><li><code>-print</code> 为默认操作</li></ul><p><img src="https://i.loli.net/2021/05/21/YKfGtiyvV6e24LT.png" alt="image-20210521154921293"></p><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua"><span class="hljs-built_in">find</span> ~ -<span class="hljs-built_in">type</span> f -name <span class="hljs-string">&#x27;*.bak&#x27;</span> -<span class="hljs-built_in">print</span>//先筛选再<span class="hljs-built_in">print</span><br><span class="hljs-built_in">find</span> ~ -<span class="hljs-built_in">print</span> -<span class="hljs-built_in">type</span> f -name <span class="hljs-string">&#x27;*.bak&#x27;</span> //先<span class="hljs-built_in">print</span>再筛选<br></code></pre></div></td></tr></table></figure><ul><li>在使用<code>delete</code>命令之前，先用print检查输出，确保万无一失</li></ul><h3 id="自定义操作"><a href="#自定义操作" class="headerlink" title="自定义操作"></a>自定义操作</h3><ul><li>find的-exec选项</li><li>command是命令名， <strong>{}</strong> 是代表当前路径名的符号， <strong>;</strong> 作为分隔符，表示命令结束（需要转义，用\ 和 ‘’ 都可以） </li></ul><figure class="highlight sqf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sqf">-<span class="hljs-built_in">exec</span> command &#123;&#125; ;<span class="hljs-comment">//-exec操作用法</span><br><span class="hljs-built_in">find</span> ~ -<span class="hljs-built_in">type</span> f -<span class="hljs-built_in">name</span> <span class="hljs-string">&#x27;.*&#x27;</span> -<span class="hljs-built_in">exec</span> ls -l <span class="hljs-string">&#x27;&#123;&#125;&#x27;</span> <span class="hljs-string">&#x27;;&#x27;</span><span class="hljs-comment">//在当前目录下，找到所有的隐藏文件并ls -l输出</span><br><span class="hljs-built_in">find</span> ~ -<span class="hljs-built_in">type</span> f -<span class="hljs-built_in">name</span> <span class="hljs-string">&#x27;.*&#x27;</span> -ok ls -l <span class="hljs-string">&#x27;&#123;&#125;&#x27;</span> <span class="hljs-string">&#x27;;&#x27;</span><span class="hljs-comment">//加入 -ok 在执行操作前提示用户</span><br></code></pre></div></td></tr></table></figure><ul><li>提高效率 （使用xargs 或者find命令自身新特性）</li></ul><p>将结尾的分号改成加号，就能让find命令将查找结果组合成参数列表，共指定的命令一次性使用</p><figure class="highlight sqf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sqf"><span class="hljs-built_in">find</span> ~ -<span class="hljs-built_in">type</span> f -<span class="hljs-built_in">name</span> <span class="hljs-string">&#x27;.*&#x27;</span> -<span class="hljs-built_in">exec</span> ls -l <span class="hljs-string">&#x27;&#123;&#125;&#x27;</span> +<br></code></pre></div></td></tr></table></figure><p>虽然得到一样的结果，但是只执行了一次ls命令</p><h3 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h3><ul><li>从标注输入接受输入，将其转换为指定命令的参数列表</li><li>命令参数数量不是无限制的，超出shell支持的最大参数xargs会重复使用最大参数直至完成</li></ul><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">find</span> ~ -<span class="hljs-built_in">type</span> <span class="hljs-keyword">f</span> -name <span class="hljs-string">&#x27;.*&#x27;</span> -<span class="hljs-keyword">print</span> | xargs <span class="hljs-keyword">ls</span> -<span class="hljs-keyword">l</span>//<span class="hljs-keyword">find</span>命令的输出结果通过管道传给了xargs命令，后者构造<span class="hljs-keyword">ls</span>命令的参数列表，然后执行该命令<br><span class="hljs-keyword">find</span> ~ -<span class="hljs-built_in">type</span> <span class="hljs-keyword">f</span> -name <span class="hljs-string">&#x27;.*&#x27;</span> -<span class="hljs-keyword">print</span> | xargs --show-limits <span class="hljs-keyword">ls</span> -<span class="hljs-keyword">l</span>//执行xargs 时加入--show-limits显示最大支持参数(注意是在xargs命令后面加入)<br></code></pre></div></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/21/oHwevKW64iNFmS3.png" alt="image-20210521164911871"></p><h2 id="18-3-实战演练"><a href="#18-3-实战演练" class="headerlink" title="18.3 实战演练"></a>18.3 实战演练</h2><ul><li> <code>mkdir -p</code> 命令创建指定路径的父目录以及子目录</li><li><code>touch</code> 命令通常被用来<strong>设置或更新文件的访问，更改，和修改时间</strong>。如果一个文件名参数是一个不存在的文件，则会<strong>创建一个空文件</strong>。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">[me<span class="hljs-meta">@linuxbox</span> ~]$ mkdir -p playground/dir-&#123;<span class="hljs-number">00</span>&#123;<span class="hljs-number">1.</span><span class="hljs-number">.9</span>&#125;,<span class="hljs-number">0</span>&#123;<span class="hljs-number">10.</span><span class="hljs-number">.99</span>&#125;,<span class="hljs-number">100</span>&#125;<span class="hljs-comment">//创建100个子目录</span><br>[me<span class="hljs-meta">@linuxbox</span> ~]$ touch playground/dir-&#123;<span class="hljs-number">00</span>&#123;<span class="hljs-number">1.</span><span class="hljs-number">.9</span>&#125;,<span class="hljs-number">0</span>&#123;<span class="hljs-number">10.</span><span class="hljs-number">.99</span>&#125;,<span class="hljs-number">100</span>&#125;/file-&#123;A..Z&#125;<span class="hljs-comment">//每个目录26个空文件</span><br>[me<span class="hljs-meta">@linuxbox</span> ~]$ find playground -<span class="hljs-keyword">type</span> f -name <span class="hljs-string">&#x27;file-A&#x27;</span> | wc -l<br>[me<span class="hljs-meta">@linuxbox</span> ~]$ touch playground/timestamp<span class="hljs-comment">//创建timestamp将其时间设置当前时间</span><br>[me<span class="hljs-meta">@linuxbox</span> ~]$ stat playground/timestamp<span class="hljs-comment">//查看属性（ls增强版）</span><br>[me<span class="hljs-meta">@linuxbox</span> ~]$ touch playground/timestamp<br>[me<span class="hljs-meta">@linuxbox</span> ~]$ stat playground/timestamp<br>[me<span class="hljs-meta">@linuxbox</span> ~]$ find playground -<span class="hljs-keyword">type</span> f -name <span class="hljs-string">&#x27;file-B&#x27;</span> -exec touch <span class="hljs-string">&#x27;&#123;&#125;&#x27;</span> <span class="hljs-string">&#x27;;&#x27;</span><span class="hljs-comment">//更新所有file-B文件</span><br>[me<span class="hljs-meta">@linuxbox</span> ~]$ find playground -<span class="hljs-keyword">type</span> f -newer playground/timestamp<span class="hljs-comment">//识别所有更新</span><br>[me<span class="hljs-meta">@linuxbox</span> ~]$ find playground \( -<span class="hljs-keyword">type</span> f -not -perm <span class="hljs-number">0600</span> \) -or \( -<span class="hljs-keyword">type</span> d -not -perm <span class="hljs-number">0700</span> \)<br>[me<span class="hljs-meta">@linuxbox</span> ~]$ find playground \( -<span class="hljs-keyword">type</span> f -not -perm <span class="hljs-number">0600</span> -exec chmod <span class="hljs-number">0600</span> <span class="hljs-string">&#x27;&#123;&#125;&#x27;</span> <span class="hljs-string">&#x27;;&#x27;</span> \) -or \( -<span class="hljs-keyword">type</span> d -not -perm <span class="hljs-number">0711</span> -exec chmod <span class="hljs-number">0700</span> <span class="hljs-string">&#x27;&#123;&#125;&#x27;</span> <span class="hljs-string">&#x27;;&#x27;</span> \)<span class="hljs-comment">//为所有文件设置新的权限</span><br></code></pre></div></td></tr></table></figure><h2 id="18-4-find命令选项"><a href="#18-4-find命令选项" class="headerlink" title="18.4 find命令选项"></a>18.4 find命令选项</h2><p><img src="https://i.loli.net/2021/05/21/q1wQrevGEVBgLtI.png" alt="image-20210521171219346"></p><h1 id="19-归档与备份"><a href="#19-归档与备份" class="headerlink" title="19 归档与备份"></a>19 归档与备份</h1><h2 id="19-1-文件压缩"><a href="#19-1-文件压缩" class="headerlink" title="19.1 文件压缩"></a>19.1 文件压缩</h2><h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">gzip foo.txt<br>gzip -tv foo.txt.gz<span class="hljs-string">//</span>没有v只验证完整性不输出结果<br>gunzip foo.txt<span class="hljs-string">//</span>解压，不用带<span class="hljs-string">.gz</span>的后缀名<br><span class="hljs-keyword">ls</span> -l <span class="hljs-string">/etc</span> | gzip &gt; foo.txt.gz<span class="hljs-string">//</span>输出直接压缩成文件（加上后缀表名是压缩过的）<br>gunzip -c foo.txt.gz | less <span class="hljs-string">//</span>只查看压缩文件的文本内容（注意-c后缀的作用）<br>zcat foo.txt.gz | less<span class="hljs-string">//</span>等同于-c的gzip<br></code></pre></div></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/21/OGaeib7dWuZ6yq5.png" alt="image-20210521172237328"></p><ul><li>zless 程序共功能等同于管道操作符</li></ul><h3 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h3><ul><li>用法与gzip差不多</li><li>扩展名为<code>.bz2</code></li><li>牺牲压缩速度实现了更高的压缩率</li></ul><h3 id="二次压缩"><a href="#二次压缩" class="headerlink" title="二次压缩"></a>二次压缩</h3><ul><li> 二次压缩并不会节省空间，所有压缩技术都涉及额外信息，用来描述压缩过程</li><li>尝试压缩不包含任何冗余信息的文件，省下来的空间不足以抵消额外信息使用的空间</li></ul><h2 id="19-2-文件归档"><a href="#19-2-文件归档" class="headerlink" title="19.2 文件归档"></a>19.2 文件归档</h2><ul><li>文件归档：收集多个文件将其组合成一个大文件(可以同时压缩)</li></ul><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><ul><li>f选项指定名称，是必须的，“-”不是必须的</li><li>v选项获得详细清单</li><li>tar命令从归档中提取出来的文件所有权属于执行提取操作的用户，而非原先的用户（超级用户操作除外）</li><li>tar命令<strong>归档、提取都是</strong>相对路径</li><li><strong>归档tar，归档压缩tgz、tbz</strong></li></ul><p><img src="https://i.loli.net/2021/05/23/Y64cEeFZLMUshRw.png" alt="image-20210523192843787"></p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">tar mode<span class="hljs-selector-attr">[options]</span> pathname<br>tar cf playground<span class="hljs-selector-class">.tar</span> playground<span class="hljs-comment">//为playgorund归档，f选项为指定名称</span><br>tar tvf playground<span class="hljs-selector-class">.tar</span><span class="hljs-comment">//列出归档文件的详细内容</span><br></code></pre></div></td></tr></table></figure><ul><li>通过硬盘把一台电脑系统主目录复制到另一台电脑</li></ul><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo tar cf <span class="hljs-regexp">/media/</span>BigDisk<span class="hljs-regexp">/home.tar /</span>home<span class="hljs-regexp">//</span>硬盘自动挂载在/media目录下<br><span class="hljs-regexp">//</span>卸载硬盘接入另一台计算机<br>cd <span class="hljs-regexp">//</span><span class="hljs-regexp">/提取归档是相对路径，不进入根目录就会出现/</span>home<span class="hljs-regexp">/usr/</span>home...<br>sudo tar xf <span class="hljs-regexp">/media/</span>BigDisk/home.tar<br></code></pre></div></td></tr></table></figure><ul><li>限制提取</li></ul><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">tar xf archive.tar pathname<span class="hljs-regexp">//</span>只提取指定文件，可多指定<br>tar xf ..<span class="hljs-regexp">/playground2.tar --wildcards &#x27;home/</span>playground<span class="hljs-regexp">/dir-*/</span>file-A<span class="hljs-string">&#x27;//提取所有的fileA，--wildcards加入对通配符的支持</span><br></code></pre></div></td></tr></table></figure><ul><li>与find配合</li></ul><figure class="highlight sqf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sqf"><span class="hljs-built_in">find</span> playground -<span class="hljs-built_in">name</span> <span class="hljs-string">&#x27;file-A&#x27;</span> -<span class="hljs-built_in">exec</span> tar rvf playground.tar <span class="hljs-string">&#x27;&#123;&#125;&#x27;</span> <span class="hljs-string">&#x27;+&#x27;</span><span class="hljs-comment">//以追加模式（r）调用tar，将查找到的所有文件添加进来</span><br></code></pre></div></td></tr></table></figure><p>可以通过find查找更新的文件，创建上一次归档之后出现的那些文件的归档</p><ul><li>利用标准输入输出</li></ul><figure class="highlight sqf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sqf"><span class="hljs-built_in">find</span> playground -<span class="hljs-built_in">name</span> <span class="hljs-string">&#x27;file-A&#x27;</span> | tar cvf - --files-<span class="hljs-keyword">from</span>=- | gzip &gt; playground.tgz<span class="hljs-comment">//先用find匹配文件列表，通过管道线传给tar，“-”为标准输入输出的惯例，--files-from (也可以写为-T)使其从文件中而不是命令行中读取文件列表，最后传给gzip压缩</span><br><span class="hljs-built_in">find</span> playground -<span class="hljs-built_in">name</span> <span class="hljs-string">&#x27;file-A&#x27;</span> | tar czf playground.tgz -T -<span class="hljs-comment">//简化命令，通过z选项指定gzip压缩，j选项可有指定bzip2压缩（文件后缀改为tbz）</span><br></code></pre></div></td></tr></table></figure><ul><li>通过ssh打包远程主机文件</li></ul><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">ssh remote-sys <span class="hljs-string">&#x27;tar cf - Documents&#x27;</span> | tar xf -<span class="hljs-regexp">//</span>在远程主机上执行tar命令，标准输出传到本地主机，本地主机把标准输出提取（x命令）<br></code></pre></div></td></tr></table></figure><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><ul><li>zip既能压缩也能归档（gzip、bzip2在linux上才是主流）</li><li>zip与tar不同之处在于，如果内容已存在（同名），zip是<strong>添加新文件并且替换</strong>，而tar是<strong>直接替换</strong></li></ul><figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata"><span class="hljs-keyword">zip</span> options zipfile <span class="hljs-keyword">file</span><br><span class="hljs-keyword">zip</span> -r playground.<span class="hljs-keyword">zip</span> playground <span class="hljs-comment">//不加入递归（-r)则只保留目录不包含内容</span><br>unzip playground.<span class="hljs-keyword">zip</span><span class="hljs-comment">//提取并解压缩</span><br>unzip -<span class="hljs-keyword">l</span> playground.<span class="hljs-keyword">zip</span> playground/<span class="hljs-keyword">dir</span>-087/<span class="hljs-keyword">file</span>-Z<span class="hljs-comment">//指定文件-l选项只列出不提取解压缩</span><br></code></pre></div></td></tr></table></figure><ul><li>zip 的标准输入输出（unzip不接受标准输入）</li></ul><figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata">find playground -name <span class="hljs-string">&quot;file-A&quot;</span> | <span class="hljs-keyword">zip</span> -@ <span class="hljs-keyword">file</span>-A.<span class="hljs-keyword">zip</span><span class="hljs-comment">//-@选项将文件名列表传给zip</span><br><span class="hljs-keyword">ls</span> -<span class="hljs-keyword">l</span> /etc/ | <span class="hljs-keyword">zip</span> <span class="hljs-keyword">ls</span>-etc.<span class="hljs-keyword">zip</span> -<span class="hljs-comment">//结尾的“-”是标准输入</span><br>unzip -p <span class="hljs-keyword">ls</span>-etc.<span class="hljs-keyword">zip</span> | less<span class="hljs-comment">//将unzip结果发送到标准输出</span><br></code></pre></div></td></tr></table></figure><h2 id="19-3-同步文件与目录"><a href="#19-3-同步文件与目录" class="headerlink" title="19.3 同步文件与目录"></a>19.3 同步文件与目录</h2><ul><li>rsync 远程更新协议</li><li>这里 source 和 destination 是下列选项之一：<br>• 一个本地文件或目录<br>• 一个远端文件或目录，以 [user@]host:path的形式存在<br>• 一个远端 rsync 服务器，由rsync://[user@]host[:port]/path指定</li></ul><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle">rsync <span class="hljs-keyword">options</span> <span class="hljs-keyword">source</span> destination<br>rsync -av playground foo<span class="hljs-comment">//playground的所有内容包括自身都同步到foo中（-a表示递归且保留文件属性，-v显示详细）</span><br>rsync <span class="hljs-keyword">source</span><span class="hljs-regexp">/ destination/</span><span class="hljs-regexp">/source下的所有文件不包括自身被同步，只复制目录不复制目录本身</span><br></code></pre></div></td></tr></table></figure><ul><li>硬盘备份</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">mkdir <span class="hljs-string">/media/BigDisk/backup</span><br>sudo rsync -av <span class="hljs-params">--delete</span> <span class="hljs-string">/etc</span> <span class="hljs-string">/home</span> <span class="hljs-string">/usr/local</span> <span class="hljs-string">/media/BigDisk/bcakup</span><span class="hljs-string">//</span>添加<span class="hljs-params">--delete</span>选项，用于删除存在于备份设备而原设备不存在的文件<br><span class="hljs-string">//</span> <span class="hljs-keyword">alias</span> backup=&#x27;sudo rsync -av <span class="hljs-params">--delete</span> <span class="hljs-string">/etc</span> <span class="hljs-string">/home</span> <span class="hljs-string">/usr/local</span> <span class="hljs-string">/media/BigDisk/bcakup</span>&#x27;定义别名备份更方便<br></code></pre></div></td></tr></table></figure><ul><li>在网络上使用rsync</li><li>方法一</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">sudo rsync -av <span class="hljs-params">--delete</span> <span class="hljs-params">--rsh=ssh</span> <span class="hljs-string">/etc</span> <span class="hljs-string">/home</span> <span class="hljs-string">/usr/local</span> remote-sys:<span class="hljs-string">/backup</span><br><span class="hljs-string">//</span>加入<span class="hljs-params">--rsh=ssh</span>选项，用于指示rsync用远程shell备份<br></code></pre></div></td></tr></table></figure><ul><li>方法二</li></ul><p><img src="https://i.loli.net/2021/05/23/DAYV8THo1N9gKIm.png" alt="image-20210523210628205"></p><h1 id="20-正则表达式"><a href="#20-正则表达式" class="headerlink" title="20.正则表达式"></a>20.正则表达式</h1><p><a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md">https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md</a></p><p><img src="https://i.loli.net/2021/06/02/QUbws2cA1TvhLma.png" alt="image-20210602211824794"></p><h1 id="21-文本处理"><a href="#21-文本处理" class="headerlink" title="21. 文本处理"></a>21. 文本处理</h1>]]></content>
    
    
    <categories>
      
      <category>linux / unix</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
