{"meta":{"title":"wuyifff's blog","subtitle":"hello","description":"this is my blog","author":"wuyifff","url":"https://wuyifff.github.io","root":"/"},"pages":[{"title":"about","date":"2021-10-17T07:55:55.000Z","updated":"2021-10-17T07:55:55.415Z","comments":false,"path":"about/index-1.html","permalink":"https://wuyifff.github.io/about/index-1.html","excerpt":"","text":""},{"title":"about","date":"2021-10-17T07:14:00.000Z","updated":"2021-10-24T15:46:23.795Z","comments":false,"path":"about/index.html","permalink":"https://wuyifff.github.io/about/index.html","excerpt":"","text":"世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。"}],"posts":[{"title":"introduction to Distributed Systems","slug":"Distributed System/1. introduction to Distributed Systems ","date":"2022-03-09T07:02:00.000Z","updated":"2022-03-09T10:03:44.102Z","comments":true,"path":"2022/03/09/Distributed System/1. introduction to Distributed Systems /","link":"","permalink":"https://wuyifff.github.io/2022/03/09/Distributed%20System/1.%20introduction%20to%20Distributed%20Systems%20/","excerpt":"剑桥大学分布式系统第一章","text":"1. introduction to Distributed Systems1.1 About Distributed Systems单机的并发（concurrency）又称为是共享内存(shared-memory)的并发，通过指针或变量可以很方便的进行 而非单机场景下，不同的电脑可以并行执行程序，他们只能通过网络通信，构成分布式系统 分布式系统中每一个电脑被称为结点(node)，结点可以是任何互相连接的计算设备 为何构建分布式系统？（优点） 一些应用是天然(intrinsically)的分布式系统，例如接打电话 分布式系统比单机更加可靠 分布式系统有更好的性能，更快的响应速度（地理相邻） 一些数据太大而不能放在一个机器上 缺点 网络错误导致结点无法相互通信 结点可能会崩溃(crash)、运行缓慢 因此： 我们需要有方法检测crash 分布式系统需要有容错处理 1.2 RPC（远程过程调用）分布式系统不关心网络如何传输，只关心网络的两个指标：时延(latency)、吞吐量(bandwidth) RPC的调用其他本地的函数一样，只是在本地的代码中，一部分的执行需要等待别的结点上的程序的执行结果返回。 RPC 会隐藏底层的通讯细节（不需要直接处理Socket通讯或Http通讯），在调用时会留下一个stub，就像其他本地的代码一样。 通信流程 首先寻址通讯，建立TCP连接 当A服务器上的应用发起远程过程调用时，方法的参数需要通过底层的网络协议如TCP传递到B服务器，由于网络协议是基于二进制的，内存中的参数的值要序列化成二进制的形式，也就是序列化（Serialize）或编组（marshal），通过寻址和传输将序列化的二进制发送给B服务器。 B服务器收到请求后，需要对参数进行反序列化（序列化的逆操作），恢复为内存中的表达方式，然后找到对应的方法（寻址的一部分）进行本地调用，然后得到返回值。 返回值还要发送回服务器A上的应用，也要经过序列化的方式发送，服务器A接到后，再反序列化，恢复为内存中的表达方式，交给A服务器上的应用 rpc rpc2 如果RPC调用失败，则会重试不止一次。但如果一直错误，不能无限的重试，因此需要设置超时(timeout) RPC框架要做到最基本的3件事情： 服务端如何确定客户端要调用的函数；在远程调用中，客户端和服务端分别维护一个【ID-&gt;函数】的对应表， ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，附上这个ID，服务端通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。 如何进行序列化和反序列化；客户端和服务端交互时将参数或结果转化为字节流在网络中传输，那么数据转化为字节流的或者将字节流转换成能读取的固定格式时就需要进行序列化和反序列化，序列化和反序列化的速度也会影响远程调用的效率。 如何进行网络传输多数RPC框架选择TCP作为传输协议，也有部分选择HTTP。如gRPC使用HTTP2。不同的协议各有利弊。TCP更加高效，而HTTP在实际应用中更加的灵活 RESTrepresentational state transfer 表征状态转移（REST） REST是一种架构风格，指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。REST规范把所有内容都视为资源，网络上一切皆资源。 6个约束： 客户端—服务器服务端与客户端独立实现并独立开发，只要接口不改变即可。提高跨多个平台的用户接口的可移植性并提高可伸缩性。 统一接口系统中的多个组件都依赖于统一接口，包含4个子约束： 资源的标识资源通过URL区分，当访问一个URL时，能够获取该资源或对它执行相应的操作。 通过表述操作资源客户端请求资源时，可以指定期望的格式，服务器返回响应时，响应包含了指定格式的资源。访问同一个资源的不同格式无须修改资源的标识符，客户端也可以通过资源的表述对资源进行操作。 自描述消息客户端和服务器之间传递的消息都应包含足够的信息（如资源表述的格式和内容长度，甚至相关的其他操作信息）。 超媒体作为应用程序状态的引擎（HATEOAS）服务器返回的资源表述中包含与之相关的链接，这些链接能够对资源执行其他操作。 分层系统服务端和客户端不知道网络中介（代理或网关等）的存在，增强安全、负载均衡和响应缓存等。 缓存客户端和网络中介都可以缓存服务器返回的响应，以便于减少数据获取延迟和服务器的请求次数，提高系统性能。 无状态服务器不会记录或存储客户端的状态信息。从客户端到服务器的每个请求都必须包含理解请求所需的所有信息，并且不能利用服务器上任何存储的上下文。 按需编码（可选）允许服务器临时向客户端返回可执行的程序代码用于客户端拓展和自定义功能，简化客户端。 SOA（Service-Oriented Architecture）将一个大型软件分成多个服务（或多个结点），其间通过RPC来通信 微服务是SOA架构的一种变体","categories":[{"name":"Distributed Systems","slug":"Distributed-Systems","permalink":"https://wuyifff.github.io/categories/Distributed-Systems/"}],"tags":[]},{"title":"C++ primer 读书笔记 chapter 14 重载运算与类型转换","slug":"c++/14.重载运算与类型转换","date":"2021-11-02T03:16:00.000Z","updated":"2021-11-02T03:16:43.499Z","comments":true,"path":"2021/11/02/c++/14.重载运算与类型转换/","link":"","permalink":"https://wuyifff.github.io/2021/11/02/c++/14.%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"运算符重载实质上是函数的重载","text":"C++ Primer - 重载运算与类型转换基本概念重载的运算符是具有特殊名字的函数（关键字operator接要定义的运算符号）。 既然是函数，所以也有返回类型、参数列表和函数体。其中参数数量与该运算符作用的运算对象一样多。一元运算符有一个参数，二元运算符有两个（唯一的一个三元运算符不能重载）。对二元运算符来说，左侧运算对象传递给第一个参数，而右侧运算对象传递给第二个参数。除了重载的函数调用运算符operator()之外，其他重载运算符不能含有默认实参。 有的运算符既可以当一元也可以当二元，这个时候要根据重载参数个数来判断语义。 如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的this指针上，因此，成员运算符函数（显式）的参数数量比运算符的运算对象总是少一个。 运算符函数要么是类的成员，要么至少含有一个类类型参数，这就意味着无法对内置类型的运算对象进行运算符重载。 比如int operator+(int, int);就是错误的语法，不能改变内置类型的运算符行为。 只能重载已有的运算符，不能搞新发明。不是所有的运算符都能重载。 可重载运算符 + - * / % ^ &amp; \\ ~ ! , = &lt; &gt; &lt;= &gt;= ++ – &lt;&lt; &gt;&gt; == != &amp;&amp; \\ \\ += -= /= %= ^= &amp;= \\ = *= &lt;&lt;= &gt;&gt;= [] () -&gt; -&gt;* new new[] delete delete[] 不能重载运算符 :: .* . ? : 运算符函数一般通过间接调用，当然也可以直接调用。 12345data1 + data2;operator+(data1, data2); data1 += data2;data1.operator+=(data2); 尽管有些运算符可以重载，但大多数情况下不建议重载，它们是, &amp; || &amp;&amp;。 运算符重载虽然可以为所欲为，但最好让他们的含义与内置类型一致，不要违直觉定义。 如果类执行IO操作，那么&lt;&lt;和&gt;&gt;就应该与内置类型的IO一致。 如果类的某个操作是检查相等性，则定义operator==，通常也应该有operator!=。 如果类包含一个内在的单序比较操作，则定义operator&lt;，如果有了&lt;，一般也有其他关系操作。 重载运算符的返回类型通常应与内置版本的返回类型兼容：逻辑运算符和关系运算符应该返回bool，算术运算符应该返回类类型的值，赋值运算符和复合赋值运算符应该返回左侧运算对象的一个引用。 定义重载运算符时，必须要先决定是声明为类成员函数还是普通的非成员函数。对此，有一些准则： 赋值、下标、调用和成员访问箭头运算符必须是成员。 复合赋值运算符一般来说应该是成员，但并非必须。 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，应该是成员。 具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，它们应该是普通的非成员函数（成员函数则会引发string u = &quot;hi&quot; + s;错误的灾难）。 输入输出运算符必须是非成员函数。 是否成员函数 运算符类型 必须是成员函数 赋值运算、下标运算、调用、箭头运算符 应该是成员函数 复合赋值、递增递减、解引用 应该非成员函数（应该友元函数） 算术运算符、关系运算符、位运算 必须非成员函数（必须友元函数） 输入输出 输入和输出运算符重载&lt;&lt;通常输出运算符的第一个形参是一个非常量ostream对象引用。非常量是因为向流写入内容会改变其状态，而引用则是因为ostream不能拷贝。第二个形参一般是一个常量的引用，该常量是我们想要打印的类类型。这里的引用是因为我们希望避免复制实参，常量则是因为打印对象通常不会改变对象内容。 为了与其他&lt;&lt;一致，operator&lt;&lt;一般返回它的ostream形参。 12345ostream &amp;Sales_data::operator&lt;&lt;(ostream &amp;os, const Sales_data &amp;item)&#123; os &lt;&lt; item.isbn() &lt;&lt; &quot; &quot; &lt;&lt; item.units_sold &lt;&lt; &quot; &quot; &lt;&lt; item.revenue &lt;&lt; &quot; &quot; &lt;&lt; item.avg_price(); return os;&#125; IO运算符往往需要读写类的非公有数据成员，所以IO运算符一般被声明为友元。 重载&gt;&gt;12345678910istream &amp;operator&gt;&gt;(istream &amp;is, Sales_data &amp;item)&#123; double price; is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price; if(is) //检查输入是否成功 item.revenue = item.units_sold * price; else item = Sales_data(); //输入失败，对象被赋予默认的状态 return is;&#125; 和&lt;&lt;类似，但&gt;&gt;要额外考虑失败的情况。 流含有错误类型的数据读取操作，或是到达文件末尾或遇到输入流的其他错误时会失败。 算术和关系运算符重载==、!=123456789bool operator==(const Sales_data &amp;lhs, const Sales_data &amp;rhs)&#123; return lhs.isbn() == rhs.isbn() &amp;&amp; lhs.units_sold == rhs.units_sold &amp;&amp; lhs.revenue == rhs.revenue;&#125;bool operator!=(const Sales_data &amp;lhs, const Sales_data &amp;rhs)&#123; return !(lhs == rhs);&#125; 重载关系运算符定义了相等运算符的类一般也包含关系运算符。特别的，关联容器需要用到小于运算符，所以定义operator&lt;很有用。 通常情况下，关系运算符应该： 定义顺序关系，令其与关联容器中对关键字的要求一致，并且 如果类同时含有==运算符的话，则定义一种关系令其与==保持一致。特别是，如果两个对象是!=的，那么一个对象应该&lt;另一个。 对Sales_data类来说，关系运算符没有什么必要，因为语义上违直觉。 赋值运算符除了拷贝赋值和移动赋值运算符以外，类还可以定义其他赋值运算符，把别的类型作为右侧运算对象。 比如vector支持操作： 12vector&lt;string&gt; v;v = &#123;&quot;a&quot;, &quot;an&quot;, &quot;the&quot;&#125;; 之所以可以这样赋值，是因为vector类似这样重载了=运算符： 12345class StrVec&#123;public: StrVec &amp;operator=(std::initializer_list&lt;std::string&gt;);&#125; 复合赋值运算符虽然不一定非要是类成员，但语义上作为类成员函数更符合直觉。 下标运算符如果一个类包含下标运算符，则通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用。 12345678910111213class StrVec&#123;public: std::string&amp; operator[](std::size_t n) &#123; return elements[n]; &#125; const std::string&amp; operator[](std::size_t n) const &#123; return elements[n]; &#125;private: std::string *elements; //指向数组首元素的指针&#125;； 常量对象取下标会匹配调用const版本。 递增和递减这个比较特别，有前置版本和后置版本，所以也要定义两个版本。语义上建议作为成员函数。 前置123456789101112131415161718class StrBlobPtr&#123;public: StrBlobPtr&amp; operator++(); //前置 strBlobPtr&amp; operator--();&#125;;StrBlobPtr&amp; StrBlobPtr::operator++()&#123; check(curr, &quot;increment past end of StrBlobPtr&quot;); ++curr; return *this;&#125;StrBlobPtr&amp; StrBlobPtr::operator--()&#123; --curr; check(curr, &quot;decrement past bgin of StrBlobPtr&quot;); return *this;&#125; 前置运算符返回的是递增或递减后的对象引用。 后置为了区分前置和后置，后置接受一个额外的不被使用的int型形参。 1234567891011121314151617class StrBlobPtr&#123;public: StrBlobPtr operator++(int); //后置 StrBlobPtr operator--(int); &#125;;StrBlobPtr StrBlobPtr::operator++(int)&#123; StrBlobPtr ret = *this; ++*this; return ret;&#125;StrBlobPtr StrBlobPtr::operator--(int)&#123; StrBlobPtr ret = *this; --*this; return ret;&#125; 重载*/-&gt;123456789101112class StrBlobPtr&#123;public: std::string&amp; operator*() const &#123; auto p = check(curr, &quot;dereference past end&quot;); return (*p)[curr]; //(*p)是对象所指的vector &#125; std::string* operator-&gt;() const &#123; return &amp; this-&gt;operator*(); &#125;&#125; 重载()最特别的一个。 123456789struct absInt&#123; int operator()(int val) const&#123; return val &lt; 0 ? -val : val; &#125;&#125;;int i = -42;absInt absObj;int ui = absObj(i); //i传递给absObj.operator() 只能作为类成员定义，可以重载多个函数，以参数区分。 类如果定义了调用运算符，那么该类的对象就被称为函数对象。 lambda会被编译器翻译成一个未命名类的未命名对象。lambda表达式产生的类中含有一个重载的函数调用运算符，所以lambda表达式实际上是函数对象。 标准库也定义了一组函数对象，plus类定义了一个函数调用运算符用于对一对运算对象执行+操作，modules类定义了调用运算符执行二元%操作，equal_to类执行==等。 这些类都是类模板，需要使用时指定具体应用类型。 12345plus&lt;int&gt; intAdd;negate&lt;int&gt; intNegate;int sum = intAdd(10, 20);sum = intNegate(intAdd(10,20));sum = intAdd(10, intNegate(10)); 它们定义在functional头文件中。 算术 关系 逻辑 plus&lt;Type&gt; equal_to&lt;Type&gt; logical_and&lt;Type&gt; minus&lt;Type&gt; not_equal_to&lt;Type&gt; logical_or&lt;Type&gt; multiplies&lt;Type&gt; greater&lt;Type&gt; logical_not&lt;Type&gt; divides&lt;Type&gt; greater_equal&lt;Type&gt; modules&lt;Type&gt; less&lt;Type&gt; negate&lt;Type&gt; less_equal&lt;Type&gt; 函数对象的一个坑： 123vector&lt;string *&gt; nameTable;sort(nameTable.begin(), nameTable.end(), [](string *a, string *b)&#123;return a &lt; b;&#125;);//错误，nameTable中指针彼此之间没有关系，所以&lt;将产生未定义行为sort(nameTable.begin(), nameTable.end(), less&lt;string*&gt;());//正确，标准库规定指针的less是定义良好的 后者可以用指针地址值来排序，标准库规定其函数对象对于指针同样适用，而手写的lambda就不行了。 C++语言中几种可调用的对象：函数、函数指针、lambda表达式、bind创建的对象以及重载了函数调用运算符的类。调用形式指明了调用返回的类型以及传递给调用的实参类型。不同的可调用对象可能具有相同的调用形式。 标准库function类型是一个模板，定义在头文件functional中，用来表示对象的调用形式。 function的操作 function&lt;T&gt; f; f是一个用来存储可调用对象的空function，这些可调用对象的调用形式应该与函数类型T相同（即T是retType(args)） function&lt;T&gt; f(nullptr); 显式地构造一个空function function&lt;T&gt; f(obj); 在f中存储可调用对象obj的副本 f 将f作为条件：当f含有一个可调用对象时为真，否则为假 f(args) 调用f中的对象，参数是args 定义为function&lt;T&gt;的成员的类型 result_type 该function类型的可调用对象返回的类型 argument_type T有一个或两个实参时定义的类型。如果T只有一个实参， first_argument_type 则argument_type是该类型的同义词；如果T有两个实参， second_argument_type 则first_argument_type和second_argument_type分别代表两个实参的类型 1234567function&lt;int(int,int)&gt; f1 = add; //函数指针function&lt;int(int,int)&gt; f2 = devide(); //函数对象类的对象function&lt;int(int,int)&gt; f3 = [](int i, int j)&#123;return i * j;&#125;; //lambdacout &lt;&lt; f1(4,2) &lt;&lt; endl; //6cout &lt;&lt; f2(4,2) &lt;&lt; endl; //2cout &lt;&lt; f3(4,2) &lt;&lt; endl; //8 重载、类型转换与运算符转换构造函数和类型转换运算符共同定义了类类型转换（class-type conversion）。 类型转换运算符这是类的一种特殊成员函数，负责将一个类类型的值转为其他类型。它不能声明返回类型，形参列表也必须为空，形式如下： 1operator type() const; 类型转换运算符可以面向除了void以外的任意类型进行定义。 123456789101112131415161718class SmallInt&#123;public: SmallInt(int i = 0): val(i) &#123; if (i &lt; 0 || i &gt; 255) throw std::out_of_range(&quot;Bad SmallInt value&quot;); &#125; operator int() const &#123; return val; &#125; private: std::size_t val;&#125;;// 内置类型转换将double实参转换成intSmallInt si = 3.14; // 调用SmallInt(int)构造函数// SmallInt类型转换运算符将si转换成intsi + 3.14; // 内置类型转换将所得的int继续转换成double 应该避免过度使用类型转换函数。如果在类类型和转换类型之间不存在明显的映射关系，则这样的类型转换可能具有误导性。 C++11引入了显示的类型转换运算符（explicit conversion operator）。和显式构造函数一样，编译器通常不会将显式类型转换运算符用于隐式类型转换。 一旦给了类型转换运算符explicit标志，那么： 123SmallInt si = 3; //正确，SmallInt的构造函数不是显式的si + 3; //错误：此处需要隐式的类型转换，但类型转换运算符是显式的static_cast&lt;int&gt;(si)+3; //正确，显式地请求类型转换 如果表达式被用作条件，则编译器会隐式地执行显式类型转换。 if、while、do语句的条件部分。 for语句头的条件表达式。 条件运算符? :的条件表达式。 逻辑非运算符!、逻辑或运算符||、逻辑与运算符&amp;&amp;的运算对象。 在两种情况下可能产生多重转换路径： A类定义了一个接受B类对象的转换构造函数，同时B类定义了一个转换目标是A类的类型转换运算符。 类定义了多个类型转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起。 可以通过显式调用类型转换运算符或转换构造函数解决二义性问题，但不能使用强制类型转换，因为强制类型转换本身也存在二义性。 所以，请避免有二义性的类型转换。","categories":[{"name":"c++","slug":"c","permalink":"https://wuyifff.github.io/categories/c/"}],"tags":[]},{"title":"effective C++ 第三版 第一章","slug":"c++/effect 1-4","date":"2021-10-26T16:12:00.000Z","updated":"2021-10-26T16:24:54.655Z","comments":true,"path":"2021/10/27/c++/effect 1-4/","link":"","permalink":"https://wuyifff.github.io/2021/10/27/c++/effect%201-4/","excerpt":"第一章：让自己习惯C++ 条款1-4","text":"守则01：把C++看做一个语言的集合，而不是单一的语言 “C++ is a federation of languages” 早期的C++只是叫”C with classes”，但发展到今天已经成为一个多重泛型编程语言(Multi-paradigm programming language)，它具有4种“子语言”: C 面向对象的C++ 模板C++ STL 高效的C++编程守则取决于你所使用的“子语言” 例如**:** 在C中，一般使用值传递 (Pass by value) 在**面向对象的C++和模板C++**中，使用常量引用传递 (Pass by const reference)更加高效 对于STL，因为迭代器是基于指针构造而成，直接使用值传递即可 守则02：尽量使用const, enum, inline, 减少宏变量#define的使用或者说，尽量多用编译器，少用预处理器 “Prefer the compiler to the preprocessor” C++提供的编译预处理功能主要有以下三种： ① 宏定义 ② 文件包含 ③条件编译 1#define A 1.653 在上面这个语句中，字符串’A’是不会被编译器看到的，而编译器看到的是’1.653’，这就会导致在调试过程中，编译器的错误信息只显示’1.653’而不是’A’，让你不知从何下手。 解决方法：定义全局常量 1const double A = 1.653; 使用全局常量还有一个好处：预处理器只会把每次对’A’的引用变成’1.653’而不管其是否已经存在，这就导致多次引用’A’会造成多个重复对象出现在目标代码中(Object code)，造成资源浪费。 当定义或声明全局变量时，常数指针和类的常数需要另加考虑 对于指针 对于指针要把指针本身和它指向的数据都定义为const，例如 1const char* const myWord = &quot;Hello&quot;; (指向常量的常量指针) 在C++中可以更方便地使用std::string这样基于char*类型的推广，例如 1const std::string myWord(&quot;Hello&quot;); 对于类的常数 声明为类的私有静态成员，这样既保证变量只能被这个类的对象接触到，又不会生成多个拷贝 1234class Player&#123; private: static const int numPlayer = 5;........ 注意，因为此处是类的成员声明范围内，所以上面只是变量的声明和初始化，而并非定义，因此如果想获取变量的地址，需要在别处另加定义。这个定义不能有任何赋值语句，因为在类内已经规定为const: 1const int Player::numPlayer; 额外的补充：类内const推荐用static细节可见（4） static的const对象赋初值与否编译器都能通过 非static的const对象不允许赋初值 赋值会报错 error: non-static const member ‘const int A::NUM_TURNS’, can’t use default assignment operator 不赋值且无构造函数也会报错 error: non-static const member ‘const int A::NUM_TURNS’, can’t use default assignment operator 对于#define的宏函数，尽量使用inline修饰的函数来代替#define C中经常会用形如#define max(a,b) ((a) &gt; (b) ? (a) : (b))这样的宏而不是定义成函数，一方面为了代码编写简洁而另一方面，又不增加函数调用的开销。 为什么要加()呢，因为怕运算符优先级问题引起歧义，这在C中已是路人皆知的技巧。 但实际上这种手法捉襟见肘，缺陷很多，比如: 123int a = 5, b = 0;max(++a, b); //a的值会增加2次max(++a, b+10); //a的值只增加了1次 虽然有点故意刁难的意思。 C++的inline完全规避了这种缺陷，可以改为inline函数： 12template&lt;typename T&gt;inline const T&amp; max(const T&amp; a, const T&amp; b)&#123; return a &gt; b ? a : b; &#125; inline还有一个好处就是现代的编译器都比程序员聪明，你显式声明inline实际上最终不一定是inline，而有一些即使不声明inline也会被编译器优化成inline，这是C++的一大性能优化。 守则03: 尽可能使用const关键字 “Use const whenever possible” 指针与const: 记忆法: const在星号左边修饰数据，const在星号右边修饰指针 以及如下两个语句的功能是相同的，不需要对此产生困惑: 12const char* pw; //都表示指向常量char的指针char const* pw; 迭代器与const 迭代器在功能上相当于指向某类型T的指针 T* 区分 const iterator 和 const_iterator 因此，如果想定义某迭代器指向一个常数，使用const iterator是不可以的，这样只相当于定义一个迭代器为一个常量(T* const)，例如:（相当于指向常量的指针） 123const std::vector&lt;int&gt;::iterator it = v.begin(); //注意，此声明只表示迭代器本身是常量 *it = 10; //编译通过，迭代器是常量，数据可以被修改++it; //编译失败！因为const迭代器不允许改变！ 解决方法，使用const_iterator:（相当于指针本身为常量） 123std::vector&lt;int&gt;::const_iterator it = v.begin(); //使用了const_iterator类型*it = 10; //编译失败，数据不允许被改变！++it; 尽量使用const可以帮助调试 类的成员函数与const 成员函数的常量性(Constness) 在定义常量与非常量成员函数时，避免代码重复 既然两个版本的成员函数都要有，为什么又要避免重复? 其实在这里指的是函数的实现要避免重复。试想某函数既要检查边界范围，又要记录读取历史，还要检查数据完整性，这样的代码复制一遍，既不显得美观，又增加了代码维护的难度和编译时间。因此，我们可以使用非常量的函数来调用常量函数。(绝对不能是常量调用非常量版本) 1234567const char&amp; operator[](std::size_t pos) const&#123;....&#125;char&amp; operator[](std::size_t pos)&#123; return const_cast&lt;char&amp;&gt;( //const_cast去掉const关键字，并转换为char&amp; static_cast&lt;const Text&amp;&gt;(*this) //给当前变量加上const关键字，才可以调用const操作符 [position]);&#125; 为了避免无限递归调用当前非常量的操作符，我们需要将(*this)转换为const Text&amp;类型才能保证安全调用const的操作符，最后去掉const关键字(const_cast)再将其返回，巧妙避免了代码的大段复制。 守则04: 在使用前保证对象是初始化的 自有类型(built-in type)的初始化 C++的自有类型继承于C，因此不能保证此类型的变量在定义时被初始化。使用未初始化的数据可能会导致程序不正常运作，因此在定义变量的时候，需要对其进行初始化。 类的初始化 对于用户自定义的类，我们需要构造函数(constructor)来完成此类的初始化 C++规定，在进入构造函数之前，如果用户没有规定初始化过程，C++将自动调用各成员对应类型的默认构造函数。 这样一来，此构造函数就相当于先调用了C++的默认构造函数，又做了一次赋值操作覆盖掉了先前的结果，造成了浪费。 解决方法：使用**初始化列表(initialization list)**，C++就不必额外调用默认构造函数了。 某些初始化是语法必要的 例如在定义引用(reference)和常量(const)时，不将其初始化会导致编译器报错 123456const int a; //报错，需要初始化！int&amp; b; //报错，需要初始化！//现在对其进行初始化：const int a = 3; //编译通过int c = 3;int&amp; b = c; //编译通过！ 数据初始化的顺序 在继承关系中，基类(base class)总是先被初始化。 在同一类中，成员数据的==初始化顺序与其声明顺序是一致的==，而不是初始化列表的顺序。因此，为了代码一致性，要保证初始化列表的顺序与成员数据声明的顺序是一样的。 初始化非本地静态对象 编译单元(translation unit): 可以让编译器生成代码的基本单元，一般一个源代码文件就是一个编译单元。 非本地静态对象(non-local static object): 静态对象可以是在全局范围定义的变量，在名空间范围定义的变量，函数范围内定义为static的变量，类的范围内定义为static的变量，而除了函数中的静态对象是本地的，其他都是非本地的。 此外注意，静态对象存在于程序的开始到结束，所以它不是基于堆(heap)或者栈(stack)的。初始化的静态对象存在于.data中，未初始化的则存在于.bss中。 回到问题，现有以下服务器代码: 12class Server&#123;...&#125;; extern Server server; //在全局范围声明外部对象server，供外部使用 又有某客户端： 123456class Client&#123;...&#125;;Client::Client(...)&#123; number = server.number;&#125;Client client; //在全局范围定义client对象，自动调用了Client类的构造函数 以上问题在于，定义对象client自动调用了Client类的构造函数，此时需要读取对象server的数据，但全局变量的不可控性让我们不能保证对象server在此时被读取时是初始化的。试想如果还有对象client1, client2等等不同的用户读写，我们不能保证当前server的数据是我们想要的。 解决方法: 将全局变量变为本地静态变量 使用一个函数，只用来定义一个本地静态变量并返回它的引用。==因为C++规定在本地范围(函数范围)内定义某静态对象时，当此函数被调用，该静态变量一定会被初始化。==(singleton模式) 123456class Server&#123;...&#125;;Server&amp; server()&#123; //将直接的声明改为一个函数 static Server server; return server;&#125; 12345678910class Client&#123;...&#125;;Client::client()&#123; //客户端构造函数通过函数访问服务器数据 number = server().number;&#125;Client&amp; client()&#123; //同样将客户端的声明改为一个函数 static Client client; return client;&#125; 第一章总结 视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL） 宁可以编译器替换预处理器（尽量以 const、enum、inline 替换 #define） 尽可能使用 const 确定对象被使用前已先被初始化（构造时赋值（copy 构造函数）比 default 构造后赋值（copy assignment）效率高）","categories":[{"name":"c++","slug":"c","permalink":"https://wuyifff.github.io/categories/c/"}],"tags":[]},{"title":"C++ primer 读书笔记 chapter 13 拷贝控制","slug":"c++/13.拷贝控制","date":"2021-10-25T11:47:42.009Z","updated":"2021-10-25T11:49:42.159Z","comments":true,"path":"2021/10/25/c++/13.拷贝控制/","link":"","permalink":"https://wuyifff.github.io/2021/10/25/c++/13.%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/","excerpt":"析构、拷贝构造、拷贝赋值、移动构造、移动赋值","text":"C++ primer chapter 13拷贝控制定义一个类，会显式或隐式指定此类型的对象拷贝、移动、赋值和销毁时做什么。类通过定义五种特殊的成员函数来控制这些操作，包括：拷贝构造函数（copy constructor）、拷贝赋值运算符（copy-assignment operator）、移动构造函数（move constructor）、移动赋值运算符（move-assignment operator）和析构函数（destructor）。 拷贝、赋值与销毁移动语义是C++11新引入的 拷贝构造函数仅有一个参数为自身类类型引用的构造函数就是拷贝构造函数，形如： 12345class Foo&#123;public: Foo(); //默认构造函数 Foo(const Foo&amp;); //拷贝构造函数&#125;; 该参数==必须是引用类型==，一般是const引用。由于拷贝构造函数会在几种情况下隐式地调用，所以一般不是explicit。 如果自己不定义，编译器就会合成一个默认的、合成的拷贝构造函数会把参数成员逐个拷贝到正在创建的对象中（非static成员）。 成员的类型决定了拷贝的方式：类类型的成员会用它自己的拷贝构造函数来拷贝；内置类型则直接值拷贝。数组会逐个复制，如果数组成员是类类型，会逐个调用成员本身的拷贝构造函数。 123456789101112131415class Sales_data&#123;public: Sales_data(const Sales_data&amp;);private: std::string bookNo; int units_sold = 0; double revenue = 0.0;&#125;;//与Sales_data的合成拷贝构造函数等价Sales_data::Sales_data(const Sales_data &amp;orig) : bookNo(orig.bookNo), //使用string的拷贝构造函数 units_sold(orig.units_sold), //拷贝orig.units_sold revenue(orig.revenue) //拷贝orig.revenue &#123;&#125; //空函数体 拷贝初始化拷贝初始化和直接初始化的差异： 直接初始化：==普通的函数匹配== 拷贝初始化：==类型转换== 12345string dots(10,&#x27;,&#x27;); //直接初始化string s(dots); //直接初始化string s2 = dots; //拷贝初始化string null_book = &quot;9-999-99999-9&quot;; //拷贝初始化string nines = string(100, &#x27;9&#x27;); //拷贝初始化 拷贝初始化一般由拷贝构造函数完成，之所以说一般是因为移动语义的引入，导致如果类由移动构造函数时，拷贝初始化有时会使用移动构造函数而非拷贝构造函数。 拷贝初始化不仅在用=定义变量时发生，在下列情形也会发生： 将一个对象作为实参传递给一个非引用类型的形参 从一个返回类型为非引用类型的函数返回一个对象 用花括号列表初始化一个数组中的元素或一个聚合类中的成员 某些类类型还会对它们所分配的对象使用拷贝初始化。如初始化标准库容器或调用其insert或push成员时，容器会对其元素进行拷贝初始化。而emplace创建的元素都是直接初始化。 参数和返回值拷贝构造函数被用来初始化非引用类类型参数，所以拷贝构造函数自身的参数必须是引用类型。不然的话，就二者矛盾而无限循环了。 如果可以不是引用类型，为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数。（套娃） 拷贝初始化的限制构造函数为explicit类型，拷贝初始化只能是直接初始化 12345vector&lt;int&gt; v1 10; //正确，直接初始化vector&lt;int&gt; v2 = 10; //错误，vector接受大小的构造函数是explicit的void(f(vector&lt;int&gt;)); //f的参数进行拷贝初始化f(10); //错误，不能用一个explicit的构造函数拷贝一个实参f(vector&lt;int&gt;(10)); //正确，从一个int直接构造一个临时vector 对于explicit的构造函数，我们不能隐式的使用它（如第4行），必须显式的使用（如第5行）。 拷贝赋值运算符12Sales_data trans, accum;trans = accum; //使用Sales_data的拷贝赋值运算符 如果类未定义，编译器会合成一个。 这个函数的定义涉及了重载运算符的概念，这里重载的是赋值运算符（ 即 = ）。 重载运算符本质上是函数，名字由operator关键字接要定义的运算符符号组成。所以，赋值运算符就对应operator=的函数。 重载运算符的参数表示运算符的运算对象，某些运算符包括赋值必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的this参数。对一个二元运算符，例如赋值运算符，右侧运算对象作为显式参数传递。 拷贝赋值运算符接受一个与其所在类相同类型的参数： 12345class Foo&#123;public: Foo&amp; operator=(const Foo&amp;); //赋值运算符 // ...&#125; 为了与内置类型的赋值保持一直，赋值运算符通常返回一个指向其左侧运算对象的引用。另外，标准库通常要求保存在容器中的类型具有赋值运算符，且返回值是左侧运算符对象的引用。 编译器合成的拷贝赋值运算符类似拷贝构造，也是逐一进行成员拷贝（非static），类类型通过它自身的拷贝赋值运算符来完成，数组成员为类类型的，也会逐一调用自身的拷贝赋值运算符。最后，返回一个指向左侧运算对象的引用。 12345678//该函数等价于合成的拷贝赋值运算符Sales_data&amp; Sales_data::operator=(const Sales_data &amp;rhs)&#123; bookNo = rhs.bookNo; //调用string::operator= units_sold = rhs.units_sold; //使用内置的int赋值 revenue = rhs.revenue; //使用内置的double赋值 return *this; //返回左侧对象的引用&#125; 析构函数与构造执行的操作相反。 析构函数名字比构造函数多了一个**~**。没有返回值，也没有参数。 12345class Foo&#123;public: ~Foo(); //析构函数 ...&#125;; 析构函数不能被重载（因为它也不接受参数），是惟一的。 调用析构的时机： 变量在离开作用域时被销毁 当一个对象被销毁时，其成员被销毁 容器被销毁时（标准库容器或数组），其元素被销毁 动态分配的对象，当对指向它的指针应用delete时被销毁 临时对象，当创建它的完整表达式结束时被销毁 隐式的销毁一个内置指针类型的成员不会delete它所指向的对象 与普通指针不同,智能指针是类类型,所以具有析构函数,在析构时会被自动销毁. 1234567891011&#123;//新作用域 //p和p2指向动态分配对象 Sales_data *p = new Sales_data;//p是一个内置指针 auto p2 = make_shared&lt;Sales_data&gt;(); //p2是一个shared_ptr Sales_data item(*p); //拷贝构造函数将*p拷贝到item中 vector&lt;Sales_data&gt; vec; //局部对象 vec.push_back(*p2); //拷贝p2指向的对象 delete p; //对p指向的对象执行析构函数&#125;//退出局部作用域；对item、p2和vec调用析构函数//销毁p2会递减其引用计数；如果引用计数变为0，则对象释放//销毁vec会销毁它的元素 当指向一个对象的应用或指针离开作用域时,析构函数不会执行 如果类未定义析构，则编译器会自动合成(合成析构函数)。 1234567class Sales_data&#123;public: //成员会被自动销毁，除此之外不需要做其他事情 ~Sales_data()&#123;&#125; //其他成员的定义 ...&#125;; 析构函数体（空）执行完毕后，成员会被自动销毁。本例中string的析构函数会被调用，释放bookNo的内存。析构函数体本身不直接销毁成员，它们是==在函数体之后隐含的析构阶段中被销毁==的。析构函数体只是析构过程的一部分。 三五法则需要析构函数的类也需要拷贝和赋值操作因为析构函数需要去手工delete成员指针。这种情况下，编译器合成的拷贝构造和赋值运算符就会有问题，因为仅仅只是完成了浅拷贝，拷贝了成员指针的地址值（指向同一个对象），这可能引起问题。所以这种情况我们要自己写深拷贝代码。 需要拷贝操作的类也需要赋值操作，反之亦然因为语义上拷贝构造和赋值操作是一致的，只是调用时机不同。提供了一个就说明需要特化某些操作，那么对应的另一个也要一致。但需要二者却不一定需要一个析构。 =default=default可以显式地要求编译器生成合成的版本。 12345678910class Sales_data&#123;public: Sales_data() = default; Sales_data(const Sales_data&amp;) = default; Sales_data &amp;operator=(const Sales_data &amp;); ~Sales_data() = default; //其他成员 ...&#125;;Sales_data &amp;Sales_data::operator=(const Sales_data&amp;) = default; 类内使用=default声明，合成的函数会隐式地声明为inline。 =delete有些情况我们希望阻止类的拷贝或赋值。比如iostream就阻止了拷贝，避免多个对象写入或读取相同的IO缓冲。 123456struct NoCopy&#123; NoCopy() = default; //合成的默认构造函数 NoCopy(const NoCopy&amp;) = delete; //阻止拷贝 NoCopy&amp; operator=(const NoCopy&amp;) = delete; //阻止赋值 ~NoCopy() = default;&#125;; =delete通知编译器，不希望定义这些成员。 注意，析构函数不能删除，其他任何函数都可以指定=delete。虽然语法上允许析构函数指定=delete，但这样一来涉及到该类的对象都不能用，因为它无法销毁。 所以，记着析构函数不能加=delete这条软规则即可。 如果一个类有某个数据成员不能默认构造、拷贝、复制或销毁，那么对应的成员函数将被定义为删除的。 具有引用成员或无法默认构造的const成员的类，编译器不会合成默认构造函数。如果类有const成员，则它不能使用合成的拷贝赋值运算符（新值是不能给const对象的）。 在没有=delete之前，C++是通过private权限限制拷贝构造函数和拷贝赋值运算符来阻止拷贝的。这种方法有一个疏漏，就是友元函数和成员函数是可以进行拷贝的。 与 = default 不同， = delete 必须出现在函数第一次声明的时候，这个差异与这些声明的含义在逻辑上是吻合的，默认成员只影响为这个成员生成的代码，因此 = default 直到编译器生成代码时才需要。而对于被删除的函数，编译器需要一开始就直到，以便禁止试图使用它的操作。 希望组织拷贝的类应该使用 = delete 来定义自己的拷贝构造函数和拷贝赋值运算符，而不是将他们声明为private的，如 NoCopy(const NoCopy&amp;) = delete; 拷贝控制和资源管理类一旦管理了类外资源，往往就需要自定义析构，根据三五法则也就意味着要自定义拷贝构造和拷贝赋值运算符。 而定义拷贝控制成员时，首先要确定类的拷贝语义，我们是让类的行为看起来像值还是像指针。 如果是像值，比如string、标准库容器类等，它们的拷贝会使得副本对象和原对象完全独立，改变副本不会影响原对象。 如果是像指针，比如shared_ptr，那么拷贝的就是指针，指向的是同一个对象。 当然，也可以设置为不允许拷贝或赋值，此时既不像值也不像指针。 行为像值的类12345678910111213141516171819202122class HasPtr&#123;public: HasPtr(const std::string &amp;s = std::string()):ps(new std::string(s)), i(0)&#123;&#125; //对ps指向的string，每个HasPtr对象都有自己的拷贝 HasPtr(const HasPtr &amp;p):ps(new std::string(*p.ps)), i(p.i)&#123;&#125; HasPtr&amp; operator=(const HasPtr &amp;); ~HasPtr()&#123;delete ps;&#125;private: std::string *ps; int i;&#125;;HasPtr&amp; HasPtr::operator=(const HasPtr &amp;rhs)&#123; //这里一定要先new再delete，因为赋值操作赋值给自己是合法的 //如果赋值给自己，先delete意味着rhs.ps就丢了 auto newp = new string(*rhs.ps); //拷贝底层string delete ps; //释放旧内存 ps = newp; //从右侧运算对象拷贝数据到本对象 i = rhs.i; return *this; //返回本对象&#125; 赋值运算符要谨记一个好习惯，在销毁左侧运算对象资源之前先拷贝右侧运算对象资源。 行为像指针的类12345678910111213141516171819202122232425262728293031323334class HasPtr&#123;public: //构造函数分配新的string和新的计数器，将计数器置为1 HasPtr(const std::string &amp;s = std::string()):ps(new std::string(s)), i(0), use(new std::size_t(1))&#123;&#125; //拷贝构造函数拷贝所有3个数据成员，并递增计数器 HasPtr(const HasPtr &amp;p):ps(p.ps), i(p.i), use(p.use)&#123;++*use;&#125; HasPtr&amp; operator=(const HasPtr&amp;); ~HasPtr();private: std::string *ps; int i; std::size_t *use; //用来记录有多少个对象共享*ps的成员&#125;;HasPtr::~HasPtr()&#123; if(--*use == 0)&#123; //如果引用计数变为0 delete ps; //释放string内存 delete use; //释放计数器内存 &#125;&#125;HasPtr&amp; HasPtr::operator=(const HasPtr &amp;rhs)&#123; ++*rhs.use; //递增右侧运算对象的引用计数 if(--*use == 0)&#123; //然后递减本对象的引用计数 delete ps; //如果没有其他用户 delete use; //释放本对象分配的成员 &#125; ps = rhs.ps; //将数据从rhs拷贝到本对象 i = rhs.i; use = rhs.use; return *this; //返回本对象&#125; 赋值运算符要考虑自赋值的情况，所以在左侧递减引用计数之前先递增右侧引用计数。 交换操作除了拷贝控制成员外，管理资源的类一般还定义一个swap函数。对与重排元素顺序的算法一起使用的类来说，swap非常重要，因为这些算法交换两个元素时会调用swap。 如果类自己定义了swap，算法就使用自定义版本，否则使用标准库定义的swap。 123456789101112class HasPtr&#123; friend void swap(HasPtr&amp;, HasPtr&amp;); //其他成员定义 ...&#125;;inline void swap(HasPtr &amp;lhs, HasPtr &amp;rhs)&#123; using std::swap; swap(lhs.ps, rhs.ps); // 交换指针，而不是string数据 swap(lhs.i, rhs.i); // 交换int成员&#125; swap不是必要的，但对分配了资源的类来说，定义swap是一种很重要的优化手段。 swap定义的一个坑： 123456789101112131415//Foo有类型为HasPtr的成员hvoid swap(Foo &amp;lhs, Foo &amp;rhs)&#123; //错误：这个函数使用了标准库版本的swap，而不是HasPtr版本 std::swap(lhs.h, rhs.h); // 交换类型Foo的其他成员&#125;//正确的写法：void swap(Foo &amp;lhs, Foo &amp;rhs)&#123; using std::swap; swap(lhs.h, rhs.h); //使用HasPtr版本的swap //交换类型Foo的其他成员&#125; 这种未加限定的写法之所以可行，本质上是因为类型特定的swap版本匹配程度优于声明的std::swap版本。而对std::swap的声明可以使得在找不到类型特定版本时可以正确的找到std中的版本。 swap常用于赋值运算符，它可以一步到位完成拷贝并交换的技术。 1234567//注意rhs是按值传递的，意味着HasPtr的拷贝构造函数将右侧运算对象中的string拷贝到rhsHasPtr&amp; HasPtr::operator=(HasPtr rhs)&#123; //交换左侧运算对象和局部变量rhs的内容 swap(*this, rhs); //rhs现在指向本对象曾经使用的内存 return *this; //rhs被销毁，从而delete了rhs中的指针&#125; 这里的参数不是引用，右侧运算对象是值传递，所以rhs是右侧运算对象的副本。因此直接swap就一步到位了，自动销毁rhs时就自动销毁了原对象（执行析构）。 使用拷贝和交换的赋值运算符天生异常安全，且能正确处理自赋值。 对象移动C++11引入了一个特性：可以移动而非拷贝对象。移动而非拷贝对象会大幅度提升性能。 旧版本即使在不必拷贝对象的情况下，也不得不拷贝，对象如果巨大，那么拷贝的代价是昂贵的。在旧版本的标准库中，容器所能保存的类型必须是可拷贝的。但在新标准中，可以用容器保存不可拷贝，但可移动的类型。 标准库容器、string和shared_ptr类既支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝。 右值引用为了支持移动操作，C++11引入了一个新的引用类型——右值引用(rvalue reference)。所谓右值引用就是必须绑定到右值的引用。通过&amp;&amp;来获得右值引用（左值引用是通过&amp;）。右值引用只能绑定到一个将要销毁的对象。因此，才得以自由地将一个右值引用的资源转移给另一个对象。 123456int i = 42; int &amp;r = i; //正确：r引用i，r是左值引用int &amp;&amp;rr = i; //错误：右值引用不能绑定到左值上int &amp;r2 = i*42; //错误：i*42是右值const int &amp;r3 = i*42; //正确：可以将一个const引用绑定到一个右值上int &amp;&amp;rr2 = i*42; //正确：将rr2绑定到乘法结果上 最特别的就是const左值引用是可以绑定到右值的。 变量表达式都是左值，所以不能将一个右值引用直接绑定到一个变量上，即使这个变量的类型是右值引用也不行。 12int &amp;&amp;rr1 = 42; //正确：字面常量是右值int &amp;&amp;rr2 = rr1; //错误：表达式rr1是左值 左值是持久的，右值是短暂的。 标准库move函数虽然右值引用不能绑定到左值，但可以显式地将左值转换为对应的右值引用类型。调用move函数可以获得绑定在左值上的右值引用，此函数定义在头文件utility中。 1int &amp;&amp;rr3 = std::move(rr1); //正确 move告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。但使用move就意味着承诺：除了对rr1赋值或销毁它外，我们将不再使用它。 可以销毁一个移后源对象，也可以赋予它新值，但不能使用移后源对象的值。 调用move函数的代码应该使用std::move而非move，这样做可以避免潜在的名字冲突。 移动构造函数和移动赋值运算符移动构造函数类似拷贝构造，第一个参数是该类类型的引用。不同于拷贝构造函数，这个引用参数在移动构造函数中是一个右值引用。其他任何额外参数都必须有默认值（与拷贝构造一致）。 除了完成资源移动，移动构造函数还要保证移后源对象处于一个状态：销毁它是无害的。移动之后，源对象必须不再指向被移动的资源，这些资源归新对象所有。 1234567StrVec::StrVec(StrVec &amp;&amp;s) noexcept //移动构造不应该抛任何异常 //成员初始化器接管s中资源 : elements(s.elements), first_free(s.first_free), cap(s.cap)&#123; //令s进入这样一个状态————对其运行析构函数是安全的 s.elements = s.first_free = s.cap = nullptr;&#125; 移动构造函数不会分配任何新内存，它接管给定的StrVec的内存。接管之后，源对象的指针置nullptr。 移动操作通常不分配任何资源，因此移动操作通常不抛出任何异常。而通过noexcept可以通知标准库构造函数不会抛出异常，如果不通知，那么标准库会认为移动构造函数可能会抛出异常，为此会做一些额外的工作。 为什么要指出移动操作不抛出异常呢？因为标准库能对异常发生时其自身的行为提供保证，比如vector保证push_back时发生异常不会改变vector本身。 之所不异常时不改变vector，是因为拷贝构造函数中发生异常时，旧元素的内存空间是没有变化的，至于新内存空间尽管发生了异常，vector可以直接释放新分配的内存（尚未成功构造）并返回，这不会影响vector原有的元素。但移动语义就不同，如果移动了部分元素时发生了异常，那么这时源元素就已经被改变了，这就无法满足自身保持不变的要求了。 所以除非vector知道元素类型的移动构造函数不会抛异常，否则在重新分配内存时，它必须使用拷贝构造而不是移动构造。基于此，如果希望vector重新分配内存时可以使用自定义类型对象的移动操作而不是拷贝操作，那就要显式的声明我们的移动构造函数是noexcept的。 移动赋值运算符类似移动构造，如果不抛出任何异常，也要标记为noexcept。 12345678910111213StrVec &amp;StrVec::operator=(StrVec &amp;&amp;rhs) noexcept&#123; //直接检测自赋值 if(this != &amp;rhs)&#123; free(); //释放已有元素 elements = rhs.elements; /从rhs接管资源 first_free = rhs.first_free; cap = rhs.cap; //将rhs置于可析构状态 rhs.elements = rhs.first_free = rhs.cap = nullptr; &#125; return *this;&#125; 合成的移动操作如果自己不定义，编译器也会自动合成移动操作，但这和拷贝操作不同，它需要一些条件。 如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会合成移动操作。 只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造和移动赋值运算符。 12345678910//编译器为X和hasX合成移动操作struct X&#123; int i; //内置类型可以移动 std::string s; //string定义了自己的移动操作&#125;;struct hasX&#123; X mem; //X有合成的移动操作&#125;;X x, x2 = std::move(x); //使用合成的移动构造函数hasX hx, hx2 = std::move(hx); //使用合成的移动构造函数 与拷贝操作不同，移动操作永远不会被隐式定义为删除的函数。但如果显式地要求编译器生成=default的移动操作，且编译器不能移动全部成员，则移动操作会被定义为删除的函数。 定义了移动构造或移动赋值的类也必须定义自己的拷贝操作，否则拷贝操作默认被定义为删除的。 如果类既有移动构造，也有拷贝构造，那么编译器使用普通的函数匹配规则来确定使用哪个构造函数。赋值也类似。 1234StrVec v1, v2;v1 = v2; //v2是左值，使用拷贝赋值StrVec getVec(istream &amp;s); //getVec返回一个右值v2 = getVec(cin); //getVec(cin)是一个右值，使用移动赋值 如果类有拷贝构造，但没有移动构造，函数匹配规则会保证该类型的对象会被拷贝： 123456789class Foo&#123;public: Foo() = default; Foo(const Foo&amp;); ...&#125;;Foo x;Foo y(x); //拷贝构造函数，x是左值Foo z(std::move(x)); //拷贝构造函数，因为未定义移动构造函数 在未定义移动构造的情境下，Foo z(std::move(x)之所以可行，是因为我们可以把Foo&amp;&amp;转换为一个const Foo&amp;。 五个拷贝控制成员应该当成一个整体来对待。如果一个类需要任何一个拷贝操作，它就应该定义所有五个操作。 C++11标准库定义了移动迭代器（move iterator）适配器。一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。移动迭代器的解引用运算符返回一个右值引用。调用make_move_iterator函数能将一个普通迭代器转换成移动迭代器。原迭代器的所有其他操作在移动迭代器中都照常工作。 最好不要在移动构造函数和移动赋值运算符这些类实现代码之外的地方随意使用move操作。std::move是危险的。 右值引用和成员函数在非static成员函数的形参列表后面添加引用限定符（reference qualifier）可以指定this的左值/右值属性。引用限定符可以是&amp;或者&amp;&amp;，分别表示this可以指向一个左值或右值对象。引用限定符必须同时出现在函数的声明和定义中。 123456789101112class Foo&#123;public: Foo &amp;operator=(const Foo&amp;) &amp;; // 只能向可修改的左值赋值 // 其他成员&#125;;Foo &amp;Foo::operator=(const Foo &amp;rhs) &amp;&#123; // 执行将rhs赋予本对象所需的工作 return *this;&#125; 一个非static成员函数可以同时使用const和引用限定符，此时引用限定符跟在const限定符之后。 123456class Foo&#123;public: Foo someMem() &amp; const; // error Foo anotherMem() const &amp;; // ok&#125;; 引用限定符也可以区分成员函数的重载版本。 12345678910111213141516171819202122232425class Foo&#123;public: Foo sorted() &amp;&amp;; // 可用于可改变的右值 Foo sorted() const &amp;; // 可用于任何类型的Foo //Foo其他成员private: vector&lt;int&gt; data;&#125;;//本对象为右值，因此可以原址排序Foo Foo::sorted() &amp;&amp;&#123; sort(data.begin(), data.end()); return *this;&#125; //本对象是const或是一个左值，哪种情况我们都不能对其进行原址排序Foo Foo::sorted() const &amp;&#123; Foo ret(*this); sort(ret.data.begin(), ret.data.end()); return ret;&#125;retVal().sorted(); //retVal()是右值，调用Foo::sorted() &amp;&amp;retFoo().sorted(); //retFoo()是左值，调用Foo::sorted() const &amp; 如果定了两个或两个以上具有相同名字和相同参数列表的成员函数，要么都加引用限定符，要么都不加，这一点不受const this的影响。 1234567891011class Foo&#123;public: Foo sorted() &amp;&amp;; Foo sorted() const; // 错误：必须加上引用限定符 // Comp是函数类型的类型别名 // 此函数类型可以用来比较int值 using Comp = bool(const int&amp;, const int&amp;); Foo sorted(Comp*); // 正确：不同的参数列表 Foo sorted(Comp*) const; //正确：两个版本都没有引用限定符&#125;;","categories":[{"name":"c++","slug":"c","permalink":"https://wuyifff.github.io/categories/c/"}],"tags":[]},{"title":"C++ primer 读书笔记 chapter 15 面向对象程序设计","slug":"c++/15.面向对象程序设计","date":"2021-10-24T07:38:00.000Z","updated":"2021-11-06T08:46:24.921Z","comments":true,"path":"2021/10/24/c++/15.面向对象程序设计/","link":"","permalink":"https://wuyifff.github.io/2021/10/24/c++/15.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","excerpt":"OOP三大核心思想：抽象、继承和多态（动态绑定）","text":"C++ Primer chapter 15面向对象程序设计OOP概述OOP三大核心思想：抽象、继承和多态（动态绑定）。 数据抽象将类的接口与实现分离 继承可以定义相似的类型并对其相似关系建模 多态则在一定程度上忽略相似类型的区别，实现统一方式来使用一组对象 对继承来说，层次关系的根部类叫基类，其他类可以直接或间接从基类继承而来，它们叫派生类。基类负责定义在层次关系中所有类共同拥有的成员，派生类定义各自特有的成员。 而一旦有了继承，也就可以应用多态。想要解释继承和多态，再多的语言也是苍白无力。不如从一个例子说起： 123456789class Quote&#123;public: std::string isbn() const; virtual double net_price(std::size_t n) const;//定义为虚函数，实现多态&#125;;class Bulk_quote : public Quote&#123; // Bulk_quote继承了Quotepublic: double net_price(std::size_t) const override;&#125;; Quote为基类，Bulk_quote为Quote的派生类（子类）。派生类通过类派生列表(class derivation list)明确指出从哪个(哪些)基类继承而来。其中关键字public表示公有继承，先不解释其作用。 基类的函数net_price前面加上virtual表示其是一个虚函数，虚函数的作用是为了实现多态。一旦基类定义了虚函数，那么派生的子类就可以通过重新定义来覆盖基类的虚函数实现。派生类可以省略virtual关键字，尽管子类中不声明virtual，覆盖函数定义仍然还是虚函数。(但是还是应该带上virtual,这样间接继承就免得去看基类的实现) C++11标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，这就是上例中override关键字的作用。==（好处是万一同名参数形参列表不同将会overrid失败，编译器将会报错帮助你发现）== virtual实现的动态绑定怎么用呢？（翁恺c++ p23-24） 123456789101112double print_total(ostream &amp;os, const Quote &amp;item, size_t n)&#123; //如果item是Quote对象，调用Quote::net_price //如果item是Bulk_quote对象，调用Bulk_quote::net_price double ret = item.net_price(n); os &lt;&lt; &quot;ISBN: &quot; &lt;&lt; item.isbn() //调用Quote::isbn &lt;&lt; &quot; # sold: &quot; &lt;&lt; n &lt;&lt; &quot; total due: &quot; &lt;&lt; ret &lt;&lt; endl; return ret;&#125;print_total(cout, basic, 20); //basic是Quote对象print_total(cout, bulk, 20); //bulk是Bulk_quote对象 可以看到尽管形参是一个const Quote对象的引用，但可以传入一个派生类对象作为实参，而一旦如此，对形参调用类成员函数时，就会进行动态绑定，即派生类调用派生类重新定义的虚函数体，基类调用基类定义的虚函数体。 如果net_price不是虚函数，即使子类中重新定义了一模一样的net_price，对该例来说，无论传给item的对象是子类还是派生类，最终调用的都是父类的net_price。所以说虚函数才支持动态绑定。深入一点说，拥有虚函数的类对象都有虚表，忽略基类型别动态绑定到子类成员函数的过程实际上是依赖于类对象的虚表指针，因为无论对象被看成基类还是子类，它的虚表指针始终是指向正确的解绑函数的。 所以，多态的存在可以让我们在程序设计上使用父类指针（或引用）指向子类对象，也就是所谓的“一定程度上忽略相似类型的区别，实现统一方式来使用一组对象”。 定义基类和派生类123456789101112131415class Quote&#123;public: Quote() = default; //合成默认构造函数 Quote(const std::string &amp;book, double sales_price):bookNo(book), price(sales_price)&#123;&#125; std::string isbn() const &#123;return bookNo;&#125; //返回给定数量的书籍的销售总额 //派生类负责改写并使用不同的折扣计算算法 virtual double net_price(std::size_t n) const &#123;return n * price;&#125; virtual ~Quote() = default; //对析构函数进行动态绑定private: std::string bookNo; //书籍的ISBN编号protected: double price = 0.0; //代表普通状态下不打折的价格&#125;; 为什么析构函数要定义成虚函数呢？因为我们往往使用多态时，会使用父类指针指向子类对象，而后续可能会delete父类指针，如果析构函数不是虚函数，那么delete一个子类对象不会调用子类对象的析构，而是直接调用父类的析构了，这与预期不符。 所以，==拥有虚函数的父类的析构函数往往也是虚函数==（因为多态需要虚函数来实现）。 成员函数与继承派生类可以继承基类的成员，基类的成员函数有两种：希望派生类进行覆盖而被声明为virtual的虚函数、希望派生类直接使用的函数。 任何构造函数之外的非静态函数都可以是虚函数。==构造函数不能virtual！== 构造函数为什么不能virtual呢？很简单，因为构造子类理应递归的调用父类的构造器，如果父类构造器被virtual化了，那么子类就无法调用到父类的构造器了。 普通的成员函数的解析过程发生在编译阶段，虚函数的解析过程发生在运行时(从虚表(virtual table)取函数地址)。 所以有虚函数的类会大一点，在类的开头有一个指针指向virtual table。 访问控制与继承派生类可以继承基类的成员，但这并不意味着派生类内部可以随意使用基类的成员。在public继承条件下，如果父类的成员是private权限，那么派生类内部无法访问，如果父类的成员是public权限，那么派生类内部可以访问。 那么，有的时候我们希望父类的一些成员也可以被子类访问，但不希望被其他外部非亲非戚的访问，private和public就都不好用了，于是，就有了protected权限。protected修饰的成员意味着派生类可以访问，外部不行。 继续定义派生类： 12345678910class Bulk_quote : public Quote&#123;public: Bulk_quote() = default; Bulk_quote(const std::string &amp;, double, std::size_t, double); //覆盖基类的虚函数，隐式virtual double net_price(std::size_t) const override;private: std::size_t min_qty = 0; //自己的成员，折扣政策下最低购买量 double discount = 0.0; //折扣额&#125; 派生类对象包含多个组成部分：含有派生类自己定义的(非静态)成员的子对象，以及一个与该类继承的基类对应的子对象，如果有多个基类，那么也就有对应多个子对象。 Bulk_quote对象 变量名 来源 bookNo 从Quote继承 price 从Quote继承 min_qty Bulk_quote自定义的成员 discount Bulk_quote自定义的成员 之所以能完成继承，本质上是因为派生类对象中拥有基类对象。 因为派生类对象中含有与其基类对应的组成部分，所以可以把派生类对象当成基类对象使用，也能将基类指针或引用绑定到派生类对象的基类部分上。 12345Quote item; //基类对象Bulk_quote bulk; //派生类对象Quote *p = &amp;item; //p指向Quote对象p = &amp;bulk; //p指向bulk的Quote部分Quote &amp;r = bulk; //r绑定到bulk的Quote部分 这种称为派生类到基类的类型转换（upcasting，向上造型），编译器会隐式执行派生类到基类的转换。 派生类构造函数1Bulk_quote(const std::string &amp;book, double p, std::size_t qty, double disc) : Quote(book, p), min_qty(qty), discount(disc)&#123;&#125; 初始化列表中调用了Quote的构造函数，用来负责初始化基类部分。 除非特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。如果想使用其他的基类构造函数，我们需要以类名加圆括号内的实参列表的形式为构造函数提供初始值。 派生类的构造器总是先初始化基类部分，再按声明顺序依次初始化派生类成员。 派生类使用基类的成员1234567double Bulk_quote::net_price(size_t cnt) const&#123; if(cnt &gt;= min_qty) return cnt * (1 - discount) * price; else return cnt * price;&#125; 继承与静态成员如果基类定义了静态成员，则整个继承体系中只存在该成员的唯一定义。不论基类中派生出多少个派生类，对每个静态成员来说都只存在唯一的一个实例。 因为静态成员实际上是全局的，当然是单例。只是语法上为了关系结构，把它放在类中定义。 另外，静态成员也遵循访问控制权限。 派生类的声明不能包含派生列表，直接class Bulk_quote;就行了。 C++11可以定义一种不允许其他类继承的类。 1class NoDerived final&#123;/* */&#125;; //NoDerived不能做基类 类型转换与继承通常当把引用或指针绑定到一个对象时，引用或指针的类型得和对象的类型一致，或者对象类型含有一个可接受的const类型转换规则。但对于继承类来说还有一个特例，那就是可以把基类的指针或引用绑定到派生类对象上，为了实现多态。 智能指针也支持这一类型转换，所以可以将派生类对象指针存在基类智能指针之内。 从派生类向基类的类型转换只对指针或引用类型有效。 基类向派生类不存在隐式类型转换。 派生类向基类的类型转换也可能会由于访问受限而变得不可行。 虚函数对虚函数的调用在运行时被解析。派生类覆盖虚函数定义需要保证型别完全一致。 有一个例外就是虚函数在基类中如果返回基类指针或引用时，派生类中是可以返回派生类的指针或引用的，这是唯一的一个可行的型别不一致的地方，但这种不一致也有前提条件，即派生类到基类的类型转换是可访问的（不能访问受限）。 1234567891011121314151617181920212223struct B&#123; virtual void f1(int) const; virtual void f(); void f3();&#125;;//这个例子可以看出override的用处，可以直观的找出错误，没有override编译器会曲解原本的意图struct D1 : B&#123; void f1(int) const override; //正确，f1与基类型别一致 void f2(int) override; //错误，B没有该函数 void f3() override; //错误，f3不是虚函数 void f4() override; //错误，B没有f4&#125;;struct D2 : B&#123; //继承B的f2(),f3(),覆盖f1(int) void f1(int) const final; //不允许后续的其他类覆盖f1(int)&#125;;struct D3 : D2&#123; void f2(); //正确：覆盖从间接基类B继承而来的f2() void f1(int) const; //错误，D2已经声明f1为final了&#125;; 虚函数也可以声明final来阻止派生类覆盖。 回避虚函数的机制有时候不希望动态绑定，而是调用某个虚函数的特定版本，可以通过作用域运算符来实现： 1double undiscounted = baseP-&gt;Quote::net_price(42); 无论baseP实际上是啥类型，最后调用的都是Quote的net_price，这是编译时期确定的。 通常只有成员函数(或友元)的代码才需要这种hack技巧。比如派生类虚函数想要调用父类的虚函数版本。 抽象基类有时候父类指向声明一个函数接口，不想实际定义，希望由派生类来定义。C++允许这种设计，可以在virtual的基础上定义纯虚函数： 123456789class Disc_quote : public Quote&#123;public: Disc_quote() = default; Disc_quote(const std::string &amp;book, double price, std:size_t qty, double disc):Quote(book, price), quantity(qty), discount(disc) &#123;&#125; double net_price(std::size_t) const = 0;//=0表示纯虚函数protected: std::size_t quantity = 0; double discount = 0.0;&#125; 纯虚函数无需定义，=0只能出现在类内部的虚函数声明语句处。 纯虚函数也可以定义，但必须在类外部定义，大部分情况不会定义，因为这与我们的使用意图相悖。 ==类只要含有纯虚函数，就是一个抽象基类==，抽象基类负责定义接口，后续的其他类来覆盖接口。不能创建抽象基类的对象，抽象基类需要派生类去继承。 123456class Bulk_quote : public Disc_quote&#123;public: Bulk_quote() = default; Bulk_quote(const std::string &amp;book, double price, std::size_t qty, double disc):Disc_quote(book, price, qty, disc)&#123;&#125; double net_price(std::size_t) const override;&#125;; 直接基类是Disc_quote，间接基类是Quote。各个类控制自己的构造器，构造器会递归下去，先执行根基类构造器，最后执行自身的构造。继承链的构造器形成了层的概念。 访问控制与继承protected的一个坑： 123456789101112class Base&#123;protected: int prot_mem;&#125;;class Sneaky : public Base&#123; friend void clobber(Sneaky&amp;); //可以访问Sneaky::prot_mem friend void clobber(Base&amp;); //不能访问Base::prot_mem int j; //j默认是private&#125;;void clobber(Sneaky &amp;s)&#123;s.j = s.prot_mem = 0;&#125;//clobber可以访问Sneaky的private和protected成员void clobber(Base &amp;b)&#123;b.prot_mem = 0;&#125;//clobber不能访问Base的protected成员 之所以有这种限制，是因为如果第二个用法合法的话，那么就可以通过定义一个形如Sneaky的新类来规避掉protected提供的访问保护了。 所以，派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员，而不能访问普通的基类对象中的任何成员。 public、private和protected1234567891011121314151617181920212223242526class Base&#123;public: void pub_mem()protected: int prot_mem;private: char priv_mem;&#125;;struct Pub_Derv : public Base&#123; int f()&#123;return prot_mem;&#125;//正确：派生类能访问protected成员 char g()&#123;return priv_mem;&#125;//错误：private成员对于派生类来说是不可访问的&#125;;struct Priv_Derv : private Base&#123; //private不影响派生类的访问权限 int f1() const&#123;return prot_mem;&#125;&#125;;struct Prot_Derv : protected Base&#123; int f1() const&#123;return prot_mem;&#125; //依然是protected&#125;Pub_Derv d1; //继承自Base的成员遵循原有的访问说明符Priv_Derv d2; //继承自Base的成员无论此前是什么权限，都变成privated1.pub_mem(); //正确：pub_mem在派生类中是public的d2.pub_mem(); //错误：pub_mem在派生类中是private的Prot_Derv d3; //继承自Base的成员如果是public，会变成protected，其他不变d3.pub_mem(); //错误，pub_mem是protected，只能成员和友元访问，外部不行 派生类向基类转换的可访问性 只有当D公有继承B时，用户代码才能使用派生类向基类的转换，如果D继承B的方式是受保护或私有继承，则用户代码不能使用该转换。 无论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换，派生类向直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。 如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的类型转换；反之，如果D继承B的方式是私有的，则不能使用。 说白了就一个规则： 对代码中某个给定节点，如果基类的公有成员是可访问的，则派生类向基类的转换就是可访问的，反之则不行。 友元关系不能继承。 class默认继承权限是private，struct是public。这一点和类成员权限很相似。 继承中的类作用域派生类的作用域位于基类作用域之内，因此才可以实现派生类访问基类成员。 如果派生类重用了基类的成员名字，那么基类的对应成员就会被隐藏。此时想要访问隐藏的成员，就要通过域运算符，这一手法类似调用特定虚函数版本。 123456789101112131415161718192021222324252627282930313233343536class Base&#123;public: virtual int fcn();&#125;;class D1 : public Base&#123;public: //隐藏基类的fcn，这个fcn不是虚函数 //D1继承了Base::fcn()的定义 int fcn(int); //形参列表与Base中的fcn不一致 virtual void f2(); //新的虚函数，在Base中不存在&#125;;class D2 : public D1&#123;public: int fcn(int); //非虚函数，隐藏了D1::fcn(int) int fcn(); //覆盖了Base的虚函数fcn void f2(); //覆盖了D1的虚函数f2&#125;;Base bobj;D1 d1obj;D2 d2obj;Base *bp1 = &amp;bobj, *bp2 = &amp;d1obj, *bp3 = &amp;d2obj;bp1-&gt;fcn(); //虚调用，运行时调用Base::fcnbp2-&gt;fcn(); //虚调用，运行时调用Base::fcnbp3-&gt;fcn(); //虚调用，运行时调用D2::fcnD1 *d1p = &amp;d1obj; D2 *d2p = &amp;d2obj;bp2-&gt;f2(); //错误，Base没有f2成员d1p-&gt;f2(); //虚调用，运行时调用D1::f2()d2p-&gt;f2(); //虚调用，运行时调用D2::f2()Base *p1 = &amp;d2obj; D1 *p2 = &amp;d2obj; D2 *p3 = &amp;d2obj;p1-&gt;fcn(42); //错误：Base中没有接受一个int的fcnp2-&gt;fcn(42); //静态绑定，调用D1::fcn(int)p3-&gt;fcn(42); //静态绑定，调用D2::fcn(int) 构造函数与拷贝控制虚析构函数这一点已经说过了，如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义行为。 1234Quote *itemP = new Quote;delete itemP; //调用Quote的析构itemP = new Bulk_quote; //静态类型与动态类型不一致delete itemP; //如果Quote析构是虚函数，则调用Bulk_quote，否则调用Quote析构 三五准则中曾言，如果类需要析构函数，往往也需要拷贝构造和赋值操作，但对虚析构函数来说不遵守该准侧。 虚析构函数将阻止合成移动操作。 合成拷贝控制与继承构造器的调用链： 合成的Bulk_quote默认构造函数运行Disc_quote的默认构造函数，后者又运行Quote的默认构造函数。 Quote的默认构造函数将bookNo成员默认初始化为空串，同时使用类内初始化值将price初始化为0。 Quote的构造函数完成后，继续执行Disc_quote的构造函数，它使用类内初始化qty和discount。 Disc_quote的构造函数完成后，继续执行Bulk_quote的构造函数，但什么具体工作也没做。 类似的，合成的Bulk_quote的拷贝构造也一样，调用Disc_quote的拷贝构造，后者又调用了Quote的拷贝构造。 如果基类的默认构造、拷贝构造、拷贝赋值运算符或析构函数是被删除的函数或不可访问，则派生类中对应的成员也将是删除的。 如果基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数是删除的，因为编译器无法销毁派生类对象的基类部分。 编译器不会合成一个删除掉的移动操作。使用=default请求一个移动操作时，如果基类中对应的操作是删除的或不可访问的，那么派生类中该函数将是被删除的，因为派生类对象的基类部分不可移动。同理，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。 如果确实需要移动操作，那就应该在基类中自己去定义，否则会因为虚析构的存在而默认被delete。 12345678910class Base&#123;&#125;;class D : public Base&#123;public: D(const D&amp; d) : Base(d) D(D&amp;&amp; d) : Base(std::move(d)) D &amp;D::operator=(const D &amp;rhs)&#123; Base::operator=(rhs); return *this; &#125;&#125;; 继承的构造函数C++11可以让派生类重用基类定义的构造函数。 12345class Bulk_quote : public Disc_quote&#123;public: using Disc_quote::Disc_quote; //继承了Disc_quote的构造函数 double net_price(std::size_t) const;&#125;; 编译器会生成形如:derived(params) : base(args)&#123;&#125;的构造函数。这里的using作用给编译器，而不是当前作用域。 using声明语句不能指定constexpr或explicit，所以它继承基类的修饰。 基类构造函数含有默认实参时，默认实参不会被继承。相反，派生类或获得多个继承的构造函数，每个构造函数分别省略掉一个含有默认实参的形参。 如果基类有好几个构造函数，则大多数情况下派生类继承所有构造函数。除了两个例外，其一是派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本。如果派生类定义的构造函数与基类构造函数具有相同的参数列表，则这些构造函数不会被继承。其二是默认、拷贝和移动构造不会被继承。它们按照正常规则来合成，游离于三界之外。 容器与继承123456vector&lt;Quote&gt; basket;basket.push_back(Quote(&quot;0-201-82470-1&quot;, 50));//正确，但是只能把对象的Quote部分拷贝给basketbasket.push_back(Bulk_quote(&quot;0-201-54858-8&quot;, 50, 10, .25));//调用Quote定义的版本cout &lt;&lt; basket.back().net_price(15) &lt;&lt; endl; 因为存放的是对象，所以类型转换上会阉割。 想要多态必须要间接访问，对容器来说也一样，我们要存放指针而不是对象。 1234vector&lt;shared_ptr&lt;Quote&gt;&gt; basket;basket.push_back(make_shared&lt;Quote&gt;(&quot;0-201-82470-1&quot;, 50));basket.push_back(make_shared&lt;Bulk_quote&gt;(&quot;0-201-54848-8&quot;, 50, 10, .25));cout &lt;&lt; basket.back()-&gt;net_price(15) &lt;&lt; endl;","categories":[{"name":"c++","slug":"c","permalink":"https://wuyifff.github.io/categories/c/"}],"tags":[]},{"title":"C++ primer 读书笔记 chapter 12 动态内存与智能指针","slug":"c++/12.动态内存","date":"2021-10-20T12:32:00.000Z","updated":"2021-10-25T08:57:30.835Z","comments":true,"path":"2021/10/20/c++/12.动态内存/","link":"","permalink":"https://wuyifff.github.io/2021/10/20/c++/12.%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/","excerpt":"智能指针和普通指针的区别在于智能指针实际上是对普通指针加了一层封装机制，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。","text":"C++ primer chapter 12动态内存动态内存与智能指针C++中的动态内存管理通过一对运算符完成：new在动态内存中为对象分配空间并返回指向该对象的指针，可以选择对对象进行初始化；delete接受一个动态对象的指针，销毁该对象并释放与之关联的内存。 如果忘记释放内存，就会产生内存泄露。而如果在尚有指针引用内存的情况下释放内存，可能产生野指针的使用。 为了安全，标准库提供了两种智能指针(smart pointer)类型来管理动态对象。智能指针的行为类似常规指针，区别在于它负责自动释放所指向的对象。新标准库提供的这两种智能指针的区别在于管理底层指针的方式：shared_ptr 允许多个指针指向同一个对象；unique_ptr则独占所指向的对象。标准库还定义了名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。三者均在memory头文件中定义。 shared_ptr智能指针也是类模板（具有析构函数，在离开作用域析构阶段自动销毁）。 默认初始化： 12shared_ptr&lt;string&gt; p1; //shared_ptr，可以指向stringshared_ptr&lt;list&lt;int&gt;&gt; p2; //shared_ptr, 可以指向int的list 默认初始化的智能指针保存空指针。 使用方式类似普通指针，通过解引用返回对象。 shared_ptr与unique_ptr都支持的操作 shared_ptr&lt;T&gt; sp / unique_ptr&lt;T&gt; up 空智能指针，可以指向类型为T的对象 p 将p用作一个条件判断，若p指向一个对象，则为true *p 解引用p，获得它指向的对象 p-&gt;mem 等价于(*p).mem p.get() 返回p中保存的指针。要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了 swap(p, q) /p.swap(q) 交换p和q中的指针 shared_ptr独有的操作 make_shared&lt;T&gt;(args) 返回一个shared_ptr，指向一个动态分配的类型为T的对象。使用args初始化此对象 shared_ptr&lt;T&gt; p(q) p是shared_ptr q的拷贝；此操作会递增q中的计数器。q中的指针必须能转换为T* p = q p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0，则将其管理的原内存释放 p.unique() 若p.use_count()为1，返回true；否则返回false p.use_count() 返回与p共享对象的智能指针数量；可能很慢，主要用于调试 make_shared标准库函数是分配使用动态内存最安全的方式，在内存中创建一个对象并初始化它。定义在memory头文件中。 make_shared用其参数来构造给定类型的对象。 1234shared_ptr&lt;int&gt; p3 = make_shared&lt;int&gt;(42);//42shared_ptr&lt;string&gt; p4 = make_shared&lt;string&gt;(10, &#x27;9&#x27;);//&quot;9999999999&quot;，体现argsshared_ptr&lt;int&gt; p5 = make_shared&lt;int&gt;();//值初始化，即为0auto p6 = make_shared&lt;vector&lt;string&gt;&gt;();//更通用的定义 shared_ptr的拷贝和赋值拷贝或赋值时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象： 12auto p = make_shared&lt;int&gt;(42); //p指向的对象只有p一个引用者auto q(p); //p和q指向相同对象，此对象有两个引用者 每个shared_ptr都有一个引用计数。拷贝shared_ptr会递增计数器。用一个shared_ptr初始化另一个shared_ptr，或作为参数传递给一个函数或作为函数的返回值时，引用计数都会递增。而shared_ptr赋予其他值时或是shared_ptr被销毁时（比如局部的shared_ptr离开其作用域），计数器会递减。 一旦shared_ptr计数器变为0，它会自动释放自己管理的对象。 12345auto r = make_shared&lt;int&gt;(42); //r指向的int只有一个引用者r = q; //给r赋值，令它指向另一个地址 //递增q指向的对象的引用计数 //递减r原本指向对象的引用计数 //r原本指向对象的引用计数变为0，自动释放 shared_ptr类的自动销毁对象是通过其析构函数完成的。析构函数会递减它所指向对象的引用计数，如果引用计数变为0，shared_ptr的析构函数会销毁对象并释放空间。 如果将shared_ptr存放于容器中，一段时间过后不需要全部元素，而只使用其中一部分，应该用erase删除不再需要的元素，如此才能得以释放内存（如果没有其他的引用的话）。 程序使用动态内存通常出于以下三种原因之一： 不确定需要使用多少对象。 不确定所需对象的准确类型。 需要在多个对象间共享数据。 直接管理内存直接使用new和delete是C++的一把双刃剑。 默认情况下，动态分配的对象是默认初始化的。所以内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化。 12string *ps = new string; //初始化为空字符串int *pi = new int; //pi指向未初始化int 可以使用值初始化方式、直接初始化方式、传统构造方式（圆括号()）或新标准下的列表初始化方式（花括号&#123;&#125;）初始化动态分配的对象。 1234567int *pi = new int(1024); string *ps = new string(10, &#x27;9&#x27;);vector&lt;int&gt; *pv = new vector&lt;int&gt;&#123;0,1,2,3,4,5,6,7,8,9&#125;;string *ps1 = new string; //默认初始化，空串string *ps = new string(); //值初始化，空串int *pi1 = new int; //默认初始化，值未定义int *pi2 = new int(); //值初始化为0 对定义了构造函数的类类型来说，无论是值初始化还是默认初始化，都会调用默认构造函数。而内置类型则不同，值初始化有着良好定义的值，默认初始化则未定义。 可以用new分配const对象，返回指向const类型的指针。动态分配的const对象必须初始化。 如果动态内存被耗尽，new表达式就会失败，默认情况下new失败时会抛出类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛异常： 123//如果分配失败，new返回一个空指针int *p1 = new int; //分配失败，则new抛出std::bad_allocint *p2 = new (nothrow) int; //如果分配失败，则new返回一个空指针 后者的new形式称为定位new。定位new表达式可以传递额外的参数，这里传递了一个标准库定义的名为nothrow的对象，意为不要抛出异常。 nothrow和bad_alloc定义在new头文件中。 释放内存通过delete表达式。 1delete p; //p必须指向一个动态分配的对象或是一个空指针 释放并非new分配的内存，或者将相同的指针值释放多次，行为是未定义的： 1234567int i, *pi1 = &amp;i, *pi2 = nullptr;double *pd = new double(33), *pd2 = pd;delete i; //错误：i不是指针delete pi1; //未定义：pi1指向一个局部变量delete pd; //正确delete pd2; //未定义：pd2指向的内存已经被释放了delete pi2; //正确：释放空指针总是没有错误的 new出来的const对象也可以delete，尽管对象本身不能改变。 shared_ptr和new的联用new返回的指针可以初始化智能指针，智能指针的构造函数是explicit的，因此必须使用直接初始化形式： 12shared_ptr&lt;int&gt; p1 = new int(1024); //错误：必须使用直接初始化shared_ptr&lt;int&gt; p2(new int(1024)); //正确：使用了直接初始化 默认情况下，用来初始化智能指针的内置指针必须指向动态内存，因为智能指针默认使用delete释放它所管理的对象。如果要将智能指针绑定到一个指向其他类型资源的指针上，就必须提供自定义操作来代替delete。 定义和改变shared_ptr的其他方法 shared_ptr&lt;T&gt; p(q) p管理内置指针q所指向的对象；q必须指向new分配的内存，且能够转换为T*类型 shared_ptr&lt;T&gt; p(u) p从unique_ptr u那里接管了对象的所有权；将u置为空 shared_ptr&lt;T&gt; p(q, d) p接管了内置指针q所指向的对象的所有权。q必须能转为T*类型。p将使用可调用对象d来代替delete shared_ptr&lt;T&gt; p(p2, d) p是shared_ptr p2的拷贝，唯一的区别是p将用可调用对象d来代替delete p.reset() 置p为空，若p是唯一指向其对象的shared_ptr，reset会释放此对象。 p.reset(q) 若传递了可选的参数内置指针q，会令p指向q，否则会将p置空。 p.reset(q, d) 若还传递了参数d，将会调用d而不是delete来释放q 区分shared_ptr&lt;T&gt; p(q, d) 和 p.reset(q, d) 中参数 d 的语义 不要混合使用内置指针和智能指针。当将shared_ptr绑定到内置指针后，资源管理就应该交由shared_ptr负责。不应该再使用内置指针访问shared_ptr指向的内存。 1234567891011121314// 函数被调用时ptr被创建并初始化void process(shared_ptr&lt;int&gt; ptr)&#123; // 使用ptr&#125; // ptr离开作用域，被销毁int *x(new int(1024)); // 危险：x是一个普通指针，不是智能指针process(x); // 错误：无法转换 int* 到 shared_ptr&lt;int&gt;process(shared_ptr&lt;int&gt;(x)); // 合法，但是内存会被释放int j = *x; // 未定义的：x是悬垂指针shared_ptr&lt;int&gt; p(new int(42)); // 引用计数为1process(p); // 拷贝p会增加它的引用计数，process中引用计数为2int i = *p; // 正确：引用计数为1 智能指针的get函数返回一个内置指针，指向智能指针管理的对象。主要用于向不能使用智能指针的代码传递内置指针。使用get返回指针的代码不能delete此指针。 1234567shared_ptr&lt;int&gt; p(new int(42)); //引用计数为1int *q = p.get(); //正确：但使用q要注意，不要让它管理的指针被释放&#123; //新程序块 //未定义：两个独立的shared_ptr指向相同的内存 shared_ptr&lt;int&gt;(q);&#125; //程序块结束，q被销毁，它指向的内存被释放int foo = *p; //未定义：p指向的内存已经被释放了 花式作死的另一种用法。 永远不要用get初始化另一个智能指针或为另一个智能指针赋值。 reset可以将新指针赋予shared_ptr： 12p = new int(1024); //错误：不能将一个指针赋予shared_ptrp.reset(new int(1024)); //正确：p指向一个新对象 与赋值类似，reset会更新引用计数，如果需要的话，会释放p指向的对象。reset成员经常与unique一起用，来控制多个shared_ptr共享的对象。 123if(!p.unique()) p.reset(new string(*p)); //不是唯一用户；分配新的拷贝*p += newVal; //现在我们知道自己是唯一的用户，可以改变对象的值 智能指针和异常如果使用智能指针，即使程序块过早结束，智能指针类也能确保在内存不再需要时将其释放。 123456void f()&#123; int *ip = new int(42); //这段代码抛出异常，且在f中未被捕获 delete ip; //退出之前释放内存&#125; 标准的内存泄露。 而如果: 12345void f()&#123; shared_ptr&lt;int&gt; sp(new int(42)); //这段代码抛出异常，且在f中未捕获&#125;//函数结束时shared_ptr自动释放内存 默认情况下shared_ptr假定其指向动态内存，使用delete释放对象。创建shared_ptr时可以传递一个（可选）指向删除函数的指针参数，用来代替delete。这个删除器(deleter)函数必须能够完成对shared_ptr中保存的指针进行释放的操作。 12345678910111213141516struct destination; struct connection; connection connect(destination*); void disconnect(connection); void end_connection(connection *p)&#123; disconnect(*p);&#125;void f(destination &amp;d /* 其他参数 */)&#123; connection c = connect(&amp;d); shared_ptr&lt;connection&gt; p(&amp;c, end_connection); // 使用连接 // f退出时（即使是异常退出），connection会被正确关闭&#125; ==智能指针规范：== 不使用相同的内置指针值初始化或reset多个智能指针。 不释放get返回的指针。 ==不使用get初始化或reset另一个智能指针。== 使用get返回的指针时，如果最后一个对应的智能指针被销毁，指针就无效了。 使用shared_ptr管理并非new分配的资源时，应该传递删除函数。 unique_ptr与shared_ptr不同，同一时刻只能有一个unique_ptr指向给定的对象。当unique_ptr被销毁时，它指向的对象也会被销毁。 make_unique函数（C++14新增，定义在头文件memory中）在动态内存中分配一个对象并初始化它，返回指向此对象的unique_ptr。 123unique_ptr&lt;int&gt; p1(new int(42));// C++14 C11没有make_uniqueunique_ptr&lt;int&gt; p2 = make_unique&lt;int&gt;(42); 由于unique_ptr独占其指向的对象，因此unique_ptr不支持普通的拷贝或赋值操作。 unique_ptr操作 unique_ptr&lt;T&gt; u1 空unique_ptr，可以指向类型为T的对象。u1会使用delete来释放它的指针；u2会使用一个类型为D的可调用对象来释放它的指针 unique_ptr&lt;T, D&gt; u2 unique_ptr&lt;T, D&gt; u(d) 空unique_ptr，指向类型为T的对象，用类型为D的对象d代替delete u = nullptr 释放u指向的对象，将u置空 u.release() u放弃对指针的控制权，返回指针，并将u置空 u.reset() 释放u指向的对象 u.reset(q) 如果提供了内置指针q，令u指向这个对象，否则u置空 u.reset(nullptr) unique_ptr不能拷贝或赋值，但可以转移：(release 和 reset) 12345678//将所有权从p1转移给p2unique_ptr&lt;string&gt; p2(p1.release()); //release将p1置空unique_ptr&lt;string&gt; p3(new string(&quot;Trex&quot;)); //将所有权从p3转移给p2p2.reset(p3.release()); //reset释放了p2原来指向的内存p2.release(); //错误：p2不会释放内存，而且我们弄丢了指针auto p = p2.release(); //正确，但我们必须记得delete(p) 不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr。 1234unique_ptr&lt;int&gt; clone(int p)&#123; //正确：从int*创建一个unique_ptr&lt;int&gt; return unique_ptr&lt;int&gt;(new int(p));&#125; 还可以返回一个局部对象的拷贝： 12345unique_ptr&lt;int&gt; clone(int p)&#123; unique_ptr&lt;int&gt; ret(new int(p)); //... return ret;&#125; 类似shared_ptr，默认情况下unique_ptr用delete释放其指向的对象。unique_ptr的删除器同样可以重载，但unique_ptr管理删除器的方式与shared_ptr不同。定义unique_ptr时必须在尖括号中提供删除器类型。创建或reset这种unique_ptr类型的对象时，必须提供一个指定类型的可调用对象（删除器）。 123456789//p指向一个类型为objT的对象，并使用一个类型为delT的对象释放objT对象//它会调用一个名为fcn的delT类型对象unique_ptr&lt;objT, delT&gt; p(new objT, fcn);void f(destination &amp;d/* 其他参数 */)&#123; connection c = connect(&amp;d); unique_ptr&lt;connection, decltype(end_connection)*&gt; p(&amp;c, end_connection);&#125; weak_ptrweak_ptr是一种不控制所指向对象生存期的智能指针，它指向一个由shared_ptr管理的对象。将weak_ptr绑定到shared_ptr不会改变shared_ptr的引用计数。如果shared_ptr被销毁，即使有weak_ptr指向对象，对象仍然有可能被释放。 weak_ptr weak_ptr&lt;T&gt; w 空weak_ptr可以指向类型为T的对象 weak_ptr&lt;T&gt; w(sp) 与shared_ptr sp指向相同对象的weak_ptr。T必须能转换为sp指向的类型 w = p p可以是一个shared_ptr或一个weak_ptr。赋值后w与p共享对象 w.reset() w置空 w.use_count() 与w共享对象的shared_ptr的数量 w.expired() 若w.use_count()为0，返回true，否则返回false w.lock() 如果expired为true，返回空shared_ptr；否则返回一个指向w的对象的shared_ptr 创建一个weak_ptr时，需要使用shared_ptr来初始化它。 12auto p = make_shared&lt;int&gt;(42);weak_ptr&lt;int&gt; wp(p); // wp弱共享p，p引用计数不变 由于对象可能不存在，所以weak_ptr访问对象前，要先lock： 123if(shared_ptr&lt;int&gt; np = wp.lock())&#123;//np不为空则条件成立 ...&#125; 动态数组new和数组数组是个很特别的存在，对于数组的动态分配和释放C++定义了相应的手法。 new []1int *pia = new int[get_size()]; // pia指向第一个int，调用get_size确定分配多少个int 方括号中的大小必须是整型，但不一定非要常量。 12typedef int arrT[42];int *p = new arrT; //实际上还是用的new[]而非new new返回的是一个元素类型的指针，指向第一个分配的成员。 C++中，动态数组不是数组类型，所以begin或end是不可以使用的，也不能用范围for语句来处理动态数组。 默认情况下，new分配的对象是默认初始化的。可以对数组中的元素进行值初始化，方法是在大小**后面跟一对空括号()**。在新标准中，还可以提供一个元素初始化器的花括号列表。如果初始化器数量大于元素数量，则new表达式失败，不会分配任何内存，并抛出bad_array_new_length异常。 12345678int *pia = new int[10]; // 10个未初始化的intint *pia2 = new int[10](); // 10个值初始化为的intstring *psa = new string[10]; // 10个空stringstring *psa2 = new string[10](); // 10个空string//10个int分别用列表中对应的初始化器初始化int *pia3 = new int[10] &#123; 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;;//10个string，前4个用给定的初始化器初始化，剩余的进行值初始化string *psa3 = new string[10] &#123; &quot;a&quot;, &quot;an&quot;, &quot;the&quot;, string(3,&#x27;x&#x27;) &#125;; 虽然可以使用空括号对new分配的数组元素进行值初始化，但不能在括号中指定初始化器。这意味着不能用auto分配数组。 动态分配一个空数组是合法的，此时new会返回一个合法的非空指针。对于零长度的数组来说，该指针类似尾后指针，不能解引用。 delete []对应new[]，使用==delete[]==释放动态数组。 12delete p; //p必须指向一个动态分配的对象或空delete [] pa; //pa必须指向动态分配的数组或空 数组中元素按逆序销毁。如果忽略了方括号，那么行为未定义。 123typedef int arrT[42];int *p = new arrT;delete [] p; //这个方括号是必须的。 智能指针和动态数组unique_ptr可以直接管理动态数组，**定义时需要在对象类型后添加一对空方括号[]**。 12unique_ptr&lt;int[]&gt; up(new int[10]);up.release(); //自动使用delete []来销毁指针 指向数组的unique_ptr的操作有些不同： 指向数组的unique_ptr unique_ptr&lt;T[]&gt; u u可以指向一个动态分配的数组，数组元素类型为T unique_ptr&lt;T[]&gt; u(p) u指向内置指针p所指向的动态分配的数组。p必须能转换为类型T* u[i] 返回u拥有的数组中i处的对象，u必须指向一个数组 指向数组的unique_ptr不支持成员访问运算符(.和-&gt;)。 shared_ptr不直接支持管理动态数组，如果希望使用shared_ptr管理动态数组，必须提供自定义的删除器： 12shared_ptr&lt;int&gt; sp(new int[10], [](int *p)&#123;delete[] p;&#125;);sp.reset(); //使用我们提供的lambda释放数组，它使用delete [] 如果未提供删除器，则代码是未定义的。 shared_ptr不支持下标运算符，且不支持指针的算数运算，所以需要借助get。 123for(size_t i=0;i!=10;++i)&#123; *(sp.get() + i) = i; //使用get获取一个内置指针&#125; allocator类allocator类也是一个类模板，定义时必须指定其分配的对象类型。 12allocator&lt;string&gt; alloc; // 可以分配string的allocator对象auto const p = alloc.allocate(n); // 分配n个未初始化的string 标准库allocator类及其算法 allocator&lt;T&gt; a 定义了一个名为a的allocator对象，它可以为类型为T的对象分配内存 a.allocate(n) 分配一段原始的、未构造的内存，保存n个类型为T的对象 a.deallocate(p, n) 释放从T*指针p中地址开始的内存，这块内存保存了n个类型为T的对象；p必须是一个先前由allocate返回的指针，且n必须是p创建时所要求的大小。调用deallocate前，用户必须对每个在这块内存中创建的对象调用destroy a.construct(p, args) p必须是一个类型为T的指针，指向一块原始内存；*arg被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象 a.destroy(p) p为T*类型的指针，此算法对p指向的对象执行析构函数 allocator分配的内存是未构造的，程序需要在此内存中构造对象。新标准库的construct函数接受一个指针和零或多个额外参数，在给定位置构造一个元素。额外参数用来初始化构造的对象，必须与对象类型相匹配。 1234auto q = p; // q指向最后构造的元素之后的位置alloc.construct(q++); // *q为空字符串alloc.construct(q++, 10, &#x27;c&#x27;); // *q为ccccccccccalloc.construct(q++, &quot;hi&quot;); // *q为hi 在未构造对象前使用原始内存是错误的： 12cout &lt;&lt; *p &lt;&lt; endl; //正确：使用string的输出运算符cout &lt;&lt; *q &lt;&lt; endl; //灾难：q指向未构造的内存！ 用完对象后，需要对每个构造的元素调用destroy来销毁它们。函数destroy接受一个指针，对指向的对象执行析构函数： 12while(q != p) alloc.destroy(--q); //释放我们真正构造的string 注意只能对已构造的对象进行destroy。 destroy后的内存可以重用。 全部destroy后，可以调用deallocate来归还内存给系统。 1alloc.deallocate(p, n); 标准库还为allocator类定义了两个伴随算法，可以在未初始化内存中创建对象。 allocator算法 uninitialized_copy(b,e,b2) 从迭代器b和e指定的输入范围中拷贝元素到迭代器b2指定的未构造的原始内存中。b2指向的内存必须足够大。 uninitialized_copy_n(b,n,b2) 从迭代器b指向的元素开始，拷贝n个元素到b2开始的内存中 uninitialized_fill(b,e,t) 在迭代器b和e指定的原始内存范围中创建对象，对象的值均为t的拷贝 uninitialized_fill_n(b,n,t) 从迭代器b指向的内存地址开始创建n个对象。b必须指向足够大的未构造的原始内存 这些函数在给定目的位置创建元素，而不是由系统分配内存给它们。它们在memory头文件中。 123auto p = alloc.allocate(vi.size() * 2);auto q = uninitialized_copy(vi.begin(), vi.end(), p);//返回递增后的目的位置迭代器。uninitialized_fill_n(q, vi.size(), 42);","categories":[{"name":"c++","slug":"c","permalink":"https://wuyifff.github.io/categories/c/"}],"tags":[]},{"title":"C++ primer 读书笔记 chapter 7 类","slug":"c++/7.类","date":"2021-10-19T11:02:00.000Z","updated":"2021-10-25T08:55:12.360Z","comments":true,"path":"2021/10/19/c++/7.类/","link":"","permalink":"https://wuyifff.github.io/2021/10/19/c++/7.%E7%B1%BB/","excerpt":"类的基本思想是数据抽象（data abstraction）和封装（encapsulation）。数据抽象是一种依赖于接口（interface）和实现（implementation）分离的编程及设计技术。","text":"C++ primer chapter 7类类的基本思想是数据抽象（data abstraction）和封装（encapsulation）。数据抽象是一种依赖于接口（interface）和实现（implementation）分离的编程及设计技术。类的接口包括用户所能执行的操作；类的实现包括类的数据成员、负责接口实现的函数体以及其他私有函数。 定义抽象数据类型使用class或是struct关键字可以定义类类型，struct是为了兼容旧式C风格结构体，对于定义类类型来说，struct和class的唯一区别在于默认访问权限不同。 this指针成员函数通过一个名为this的隐式参数来访问调用它的对象。this是一个常量指针，无法改变this中保存的地址。 const成员函数isbn函数的参数列表后跟随了一个const关键字，这里的const是用来修改隐式this指针的类型。 默认情况下，this类型是指向类类型非常量版本的常量指针。比如Sales_data类成员函数中，this的类型是Sales_data *const。尽管this是隐式的，但它仍然需要遵守初始化规则，这就意味着我们不能把this绑定到一个常量对象上。因此，受这一限制，我们无法在一个常量对象上调用普通的成员函数。 因为this是隐式的，我们没有办法像修饰其他参数一样，去声明其为指向常量的指针，所以C++的语法只好提供实现途径——把const关键字放在成员函数的参数列表之后，此时，this就是一个指向常量的指针，这种const成员函数被叫做常量成员函数。 12345//伪代码，说明隐式this指针是如何使用的//下面的代码非法：我们不能显式地定义自己的this指针//此处的this是一个指向常量的指针，因为isbn是一个常量成员std::string Sales_data::isbn(const Sales_data *const this)&#123;return this-&gt;isbn;&#125; 因为this指向常量，所以常量成员函数不能改变调用它的对象的内容。只读不可写。 外部定义成员函数注意需要加作用域运算符，否则谁知道你定义的是谁的成员。 为了实现连续调用链，可以令成员函数返回this对象本身： 123456Sales_data &amp;Sales_data::combine(const Sales_data &amp;rhs)&#123; units_sold += rhs.units_sold; revenue += rhs.revenue; return *this; // 返回调用该函数的对象&#125; 辅助函数类的作者往往还需要定义一些辅助函数，这些函数不作为类的成员函数，但也作为类的接口的一部分。 12345678910111213istream &amp;read(istream &amp;is, Sales_data &amp;item)&#123; double price = 0; is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price; item.revenue = price * item.units_sold; return is;&#125;ostream &amp;print(ostream &amp;os, const Sales_data &amp;item)&#123; os &lt;&lt; item.isbn() &lt;&lt; &quot; &quot; &lt;&lt; item.units_sold &lt;&lt; &quot; &quot; &lt;&lt; item.revenue &lt;&lt; &quot; &quot; &lt; item.avg_price(); return os;&#125; 构造函数每个类都定义了对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫构造函数。构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。 ==构造函数的名字和类名一致，没有返回类型==，构造函数可以重载，不能被声明成const（因为创建一个const对象时，会先调用构造函数，再得到const属性）。 合成的默认构造函数如果类不定义任何构造函数，编译器会提供一个没有任何实参的默认构造函数。编译器创建的构造函数也叫合成的默认构造函数。 合成的默认构造函数完成以下任务： 如果存在类内的初始值，用它来初始化成员。 否则，默认初始化该成员。 一旦定义了一个构造函数，那么编译器不再合成默认构造函数，即使我们定义的构造函数并不是没有参数的默认构造函数。 123456789struct Sales_data&#123; Sales_data() = default; Sales_data(const std::string &amp;s):bookNo(s)&#123;&#125; Sales_data(const std::string &amp;s, unsigned n, double p):bookNo(s), units_sold(n), revenue(p*n)&#123;&#125; Sales_data(std::istream &amp;); std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;&#125;; =default是C11引入的， 用于显式要求编译器合成默认构造函数（因为定义了其他构造函数，编译器不会自动合成默认构造函数，但我们又想要编译器提供的默认构造函数，所以这是一种偷懒的语法糖）。 =default可以出现在类的内部，也可以出现在外部，内部意味着inline。 紧跟在构造函数参数列表之后在花括号之前的部分是初始值列表。它负责为新创建的对象的一个或几个数据成员赋初值。被忽略的成员则将以合成默认构造函数相同的方式隐式初始化。 C++的编译器并不都支持类内初始值。为了可移植性，最好用初始值列表。 拷贝、赋值和析构除了构造函数以外，类还有3个特殊的成员函数：拷贝构造、赋值操作和析构。 拷贝构造会在拷贝初始化变量和值传递方式传递或返回一个对象时被调用。 赋值操作则在对类对象使用赋值运算符时会被调用。 而析构函数则在对象被销毁时被调用。 与构造函数类似，如果不去定义这3个成员，编译器也会默认合成。关于这一议题，后面第13章会单独讲解。 访问控制与封装C++用访问说明符加强了类的封装性： 定义在public说明符之后的成员在整个程序内都可以被访问，public成员定义类的接口。 定义在private说明符之后的成员仅可以被类的内部成员函数访问，外部代码无法访问，private封装了类的实现细节。 struct的默认访问权限是public，class的默认访问权限是private。 友元加上了权限之后，一些外部接口函数就无法访问类的private成员，这种情况要么提供public接口，要么就使用友元。 123456class Sales_data&#123; friend Sales_data add(const Sales_data&amp;, const Sales_data&amp;); friend std::istream &amp;read(std::istream&amp;, Sales_data&amp;); friend std::ostream &amp;print(std::ostream&amp;, const Sales_data&amp;); ...&#125; friend关键字用于表示这三个函数是类Sales_data的友元函数，如此这三个函数可以访问类的private成员。friend相当于白名单，除了友元函数以外，还可以定义友元类。 12345class Screen&#123; // Window_mgr的成员可以访问Screen类的private成员 friend class Window_mgr; ...&#125; 每个类负责控制自己的友元类和友元函数。 有时候整个类作为友元比较冒险，可以只对类的几个成员函数声明为友元： 12345class Screen&#123; // Window_mgr::clear必须在Screen类之前被声明 friend void Window_mgr::clear(ScreenIndex); ...&#125; 但是要注意声明的前后关系 类的其他特性在外部定义的成员函数也可以通过inline关键字来显式内联。 成员函数也是可以重载的。 可变数据成员使用关键字mutable可以声明可变数据成员（mutable data member）。可变数据成员永远不会是const的，即使它在const对象内。因此const成员函数可以修改可变成员的值。 12345678910111213class Screen &#123;public: void some_member() const;private: mutable size_t access_ctr; // may change even in a const object // other members as before&#125;;void Screen::some_member() const&#123; ++access_ctr; // keep a count of the calls to any member function // whatever other work this member needs to do&#125; 类内初始值花括号初始化类内初始值除了=初始化形式以外，还可以用花括号形式（C++11）： （对screens对象列表初始化）（类内初始值的两种初始化方式） 12345class Window_mgr&#123;private: //默认情况下，一个Window_mgr包含一个标准尺寸的空白Screen std::vector&lt;Screen&gt; screens&#123;Screen(24, 80, &#x27; &#x27;)&#125;;&#125; 为什么要返回*this12345//返回引用成为左值myScreen.move(4,0).set(&#x27;#&#x27;);//返回的是拷贝,只能改变临时副本Screen temp = myScreen.move(4,0);temp.set(&#x27;#&#x27;) const成员函数以引用形式返回*this，则它的返回类型将是常量引用。 成员函数可以基于const重载12345678910class Screen&#123;public: Screen &amp;display(std::ostream &amp;os) &#123;do_display(os);return *this;&#125; //非常量版本调用do_display时，this指针将隐式的从指向非常量的指针转换成指向常量的指针 const Screen &amp;display(std::ostream &amp;os) const &#123;do_display(os);return *this;&#125;private: void do_display(std::ostream &amp;os) const &#123;os &lt;&lt; contents;&#125;&#125;; 因为非常量版本的函数对于常量对象是不可用的，所以只能在常量对象上调用const成员函数。尽管明面上参数列表相同，但实际上隐式的this指针类型是不同的，区别在于是否有底层const。 当我们在对象上调用display()时，该对象是否const决定了应该调用display的哪个版本。 友元 允许特定的非成员函数访问一个类的私有成员. 友元的声明以关键字 friend开始。 friend Sales_data add(const Sales_data&amp;, const Sales_data&amp;);表示非成员函数add可以访问类的非公有成员。 通常将友元声明成组地放在类定义的开始或者结尾。 类之间的友元： 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。 友元不具有传递性 声明重载函数为友元必须指明参数 可以把另一个类的公有成员函数声明为自己的友元函数。 必须按照三步走，很容易出错。（前向声明、不完全类型） 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;class B; //提前引用声明，因为友元A中要用到B，必须让编译器知道B为一个类class A&#123; public: void disp(B &amp;b); //只能声明不能定义，因为类B内部还没有定义&#125;;class B&#123; private: int val; public: friend void A::disp(B &amp;b); //声明友元函数&#125;;//这时候才可以去定义友元函数void A::disp(B &amp;b)&#123; cout&lt;&lt;&quot;B::val=&quot;&lt;&lt;b.val&lt;&lt;endl;&#125; 类的作用域 每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由引用、对象、指针使用成员访问运算符来访问。 函数的返回类型通常在函数名前面，因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。 如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字。 类中的类型名定义都要放在一开始。 构造函数再探构造函数和初始化列表初始值列表提供了成员初始化的机会，如果在构造函数体内对成员进行赋值，那执行的就是赋值操作了（**==区分初始化和赋值==*），对于类类型来说，初始化和赋值操作可能行为不一致。 如果成员是const、引用，或者是某种未定义默认构造函数的类类型，==必须==在初始值列表中将其初始化。（因为const不能用赋值来初始化） 1234567891011class ConstRef&#123;public: ConstRef(int ii);private: int i; const int ci; int &amp;ri;&#125;;ConstRef::ConstRef(int ii): i(ii), ci(ii), ri(i) &#123; &#125; 最好令构造函数初始值的顺序与成员声明的顺序一致，并且尽量避免使用某些成员初始化其他成员。因为类成员的初始化顺序与它们在类定义中出现的顺序一致。 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。 委托构造函数C++11引入了委托构造函数： 123456789101112class Sales_data&#123;public: //非委托构造函数使用对应实参初始化成员 Sales_data(std:string s, unsigned cnt, double price):bookNo(s), units_sold(cnt), revenue(cnt*price)&#123;&#125; //该构造函数函数体为空 //其余构造函数全都委托给另一个构造函数 Sales_data():Sales_data(&quot;&quot;, 0, 0)&#123;&#125; //默认构造函数委托给第一个constructor Sales_data(std::string s):Sales_data(s, 0, 0)&#123;&#125; Sales_data(std::istream &amp;is):Sales_data()&#123;read(is, *this);&#125; //委托给默认构造函数，默认构造函数委托给第一个constructor ...&#125;; 当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数值被依次执行，然后控制权才会交还给委托者的函数体（例子中恰好函数体为空）。 默认构造函数的作用默认初始化的发生情况： 在块作用域内不使用初始值定义非静态变量或数组。 类本身含有类类型的成员且使用合成默认构造函数。 类类型的成员没有在构造函数初始值列表中显式初始化。 值初始化的发生情况： 数组初始化时提供的初始值数量少于数组大小。 不使用初始值定义局部静态变量。 通过T()形式（T为类型）的表达式显式地请求值初始化。 类必须包含一个默认构造函数以便在上述情况下使用。 隐式的类类型转换如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制（从构造函数的参数类型向类类型隐式转换）。这种构造函数被称为转换构造函数（converting constructor）。 1234string null_book = &quot;9-999-99999-9&quot;;// 构造一个临时的Sales_data对象// 该对象的units_sold和revenue等于0，bookNo等于null_bookitem.combine(null_book); 类类型转换只允许一步，这意味着： 1234//错误，需要两次转换item.combine(&quot;9-999-99999-9&quot;);//正确，显式转换为string，隐式转为Sales_dataitem.combine(string(&quot;9-999-99999-9&quot;)); 只有一个参数的构造函数，或者构造函数有n个参数，但有n-1个参数提供了默认值，这样的情况才能进行类型转换。 如果构造函数声明为explicit，就可以抑制隐式的类类型转换。同样的，需要多个实参的构造函数不能执行隐式转换，所以无须将这些构造函数指定为explicit的。 explicit关键字只允许出现在类内的构造函数声明处，不允许在类外部定义函数时重复。 c++的初始化类型 初始化类型 举例 默认初始化 例如T t; 直接（非列表）初始化 例如T t(args...); 复制（非列表）初始化 例如T t = init;） 直接列表初始化 例如T t&#123; args... &#125;; 复制列表初始化 例如T t = &#123; args... &#125;; 为什么C++的初始化规则这么复杂？ - d41d8c的回答 - 知乎 类的静态成员使用关键字static可以声明类的静态成员。静态成员可以是public的或是private的，类型可以是常量、引用、指针类类型等。静态成员存在于任何对象之外，对象中不包含与静态成员相关的数据。 12345678910111213class Account&#123;public: void calculate() &#123; amount += amount * interestRate; &#125; static double rate() &#123; return interestRate; &#125; static void rate(double); private: std::string owner; double amount; static double interestRate; static double initRate();&#125;; 静态成员实际上是全局变量，只不过通过语法的封装，让他和所属类建立了耦合的关系。 每个static数据成员是与类关联的对象，并不与该类的对象相关联。 由于静态成员不与任何对象绑定，因此静态成员函数不能声明为const，也不能在静态成员函数内使用this指针。 用户代码可以使用作用域运算符访问静态成员，也可以通过类对象、引用或指针访问。类的成员函数可以直接访问静态成员。 1234567891011121314151617181920class Account&#123;public: //成员函数无需作用域运算符即可使用静态成员 void calculate()&#123;amount += amount * interestRate;&#125; static double rate()&#123;return interestRate;&#125; static void rate(double);private: std::string owner; double amount; static double interestRate; static double initRate();&#125;;double r;r = Account::rate(); //用户代码可以使用作用域运算符访问静态成员//可以通过类对象、引用或指针访问Account ac1;Account *ac2 = &amp;ac1;r = ac1.rate();r = ac2-&gt;rate(); 在类外部定义静态成员时，不能重复static关键字，其只能用于类内部的声明语句。（在类外部定义时不用加static） 由于静态数据成员不属于类的任何一个对象，因此它们并不是在创建类对象时被定义的。通常情况下，不应该在类内部初始化静态成员。而必须在类外部定义并初始化每个静态成员。一个静态成员只能被定义一次。一旦它被定义，就会一直存在于程序的整个生命周期中。 想要保证对象只被定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一个文件中 如果一定要在类内部定义，则要求必须是字面值常量类型的constexpr","categories":[{"name":"c++","slug":"c","permalink":"https://wuyifff.github.io/categories/c/"}],"tags":[]},{"title":"侯捷C++系列(1)","slug":"c++/侯捷c++ (1)","date":"2021-09-12T11:38:00.000Z","updated":"2021-10-25T09:07:17.081Z","comments":true,"path":"2021/09/12/c++/侯捷c++ (1)/","link":"","permalink":"https://wuyifff.github.io/2021/09/12/c++/%E4%BE%AF%E6%8D%B7c++%20(1)/","excerpt":"","text":"1.inline内联函数 1.inline关键字用来定义一个类的内联函数，引入它的主要原因是用它替代C中表达式形式的宏定义,解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题。 2.inline的使用是有所限制的，inline只适合涵数体内代码简单的涵数使用，不能包含复杂的结构控制语句例如while、switch，并且不能内联函数本身不能是直接递归函数（即，自己内部还调用自己的函数）。 3.inline函数仅仅是一个对编译器的建议，所以最后能否真正内联，得看编译器，它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已。 4.定义在类中的成员函数缺省都是内联的，如果在类定义时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上inline，否则就认为不是内联的。 2.构造函数初始化 成员变量再构造函数中初始化中使用”:”函数方式性能比直接在构造函数中赋值要快，建议使用这种方式。 why？ 初始化一个类时，调用构造函数首先执行初始化列表，再执行构造函数函数体内的语句。 在执行到构造函数函数体内的语句时，变量已经初始化（可能值未定义），产生了消耗。而且const类型的变量只有初始化时可以赋值，在函数体内无法赋值。 3.构造函数重载注意事项 黄色标注的构造函数定义将出现问题，如果该函数与上面构造函数同时出现，在无参初始化该类对象时将产生冲突，因为第一个构造函数已经有参数默认初始化列表了，定义该类对象时可以不加入参数，这就产生了冲突。 4.常量成员函数 在一个类中，如果成员函数中没有改变成员函数操作（例如get操作），那么建议在该方法声明处加入const关键字，如果不加入const关键字，那么c++编译器将认为该函数可能会修改类的成员变量。这样做有个好处，如果使用者利用了const关键字定义并通过构造函数初始化了一个complex类，这个类将不能被修改，只能读取属性。当使用者调用complex的real()或者imag()方法时，如果这两个方法在定义处没有加入const关键字，那么将报错。 总结来说，成员函数用const修饰this指针，const关键字显式的告诉编译器无法改变修饰的对象，帮助检查出错。 5.参数传递和返回值使用const引用函数参数传递，如果不需要改变参数值，建议使用const reference减小开销。 下图之中ostream会改变，不能用const传参，返回值也不能加上const。 返回值建议使用引用，但如果返回引用的是该函数的一个指向堆局部变量指针，例如*ptr，那么不能使用引用，因为该局部变量在函数调用后就以及销毁了，引用可以认为是给当前对象换了个别名，如果当前对象已经被销毁，那么该“别名”也就失去了意义，不存在了。 当然，如下图所示，对于临时变量也不能返回引用： 6.友元 相同类的各个实例对象互为友元，可以通过彼此的内部方法调用传入参数的内部私有成员变量。 7.运算符重载this指针 如上图所所示，在运算符重载过程中隐藏了this指针，该指针编译器会处理，使用者不能显式声明。 所有双目运算符都是这样。 8.拷贝赋值函数 如上图所示，在重载“=”赋值运算符时需要检查自我赋值，原因如下： 如果没有自我赋值检测，那么自身对象的m_data将被释放，m_data指向的内容将不存在，所以该拷贝会出问题。","categories":[{"name":"c++","slug":"c","permalink":"https://wuyifff.github.io/categories/c/"}],"tags":[]},{"title":"APUE","slug":"linux & unix/apue","date":"2021-09-05T09:38:00.000Z","updated":"2021-10-25T08:57:28.914Z","comments":true,"path":"2021/09/05/linux & unix/apue/","link":"","permalink":"https://wuyifff.github.io/2021/09/05/linux%20&%20unix/apue/","excerpt":"UNIX环境高级编程 1-14章内容读书笔记","text":"0.tips输入输出问题 在linux系统下使用printf发现有时没有立即输出，有时又能立即输出 原因是printf使用行缓冲，没有刷新缓冲区，故没有输出。 缓冲区刷新的条件：1.进程结束。2.遇到\\n。3.缓冲区满。4.手动刷新缓冲区fflush(stdout)。 一些有用的函数&lt;stdlib.h&gt; atoi(str) 用法：将字符串里的数字字符转化为整形数。返回整形值。 注意：转化时跳过前面的空格字符，直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(’/0’)才结束转换，并将结果返回。 用于转化argv[]的参数 小知识 C/C++规定，一个数如果要指明它采用八进制，必须在它前面加上一个0（数字0），如：123是十进制，但0123则表示采用八进制。这就是八进制数在C、C++中的表达方法。（很多宏的掩码就是八进制与） 1.基础1.1what is os1.1.1内核 进程线程管理 进程管理主要为linux，windows只是壳子 内存管理 设备驱动 windows .sys文件 linux .ko文件 文件系统 中断子系统 1.1.2内核/用户态 ring0/ring3 环0内核态，环3用户态 ring1/ring2暂时没用到 系统调用 内核为应用程序提供的接口 用户态-&gt;内核态 体系结构 shell sh/bash/csh/ksh 库函数 库函数到系统调用 1.2登录1.2.1 tty/psedo-ttyTTY是电传打字机Teletypewriter的缩写，在带显示屏的视频终端出现之前，TTY是最流行的终端设备 1.2.2 /etc/password 密码可以在etc/password看到 shadow文件 起始目录 用户id 组id shell 1.3 文件1.3.1 一切皆为文件 目录 文本文件/二进制文件一视同仁 设备文件：字符设备、块设备、网络设备（在/dev下ll看第一位） socket linux与windows不同 管道、消息队列等 1.3.2 相对路径/绝对路径 / .. . 1.4 I/O 文件描述符fd stdin/stdout/stderr 对应0/1/2 1.5 进程 进程与程序的关系 进程id windows下为4的倍数（复用原因） linux下用ps命令查看 进程控制 fork 子进程都是由父进程fork出来的（写时复制） exec fork之后调用，类似windows的winexecute api waitpid 1.6 出错处理 errno windows下有geterrornumber strerror 1.7信号可以理解为用户层的中断，异步打断执行流 信号的处理 系统默认处理： 忽略/中止进程 为指定信号注册处理函数 是Linux编程重点，也容易踩坑 1.8 时间日历时间UTC time-t 进程时间clock_t 用户CPU时间 系统CPU时间 2.UNIX标准2.1 标准ISO C组成 语法、语义 标准库 ISO C历史 ANSI C89 C99 restrict long long 单行注释 分散代码与声明 C11 POSIX标准 提升各种应用程序在各种UNIX系统环境间的可移植性 只定义接口而非实现 SUS(single UNIX specification) POSIX的超集 扩展了功能 2.2 实现 FreeBSD Linux Mac OS X Solaris 2.3限制编译时限制 ISO C limits.h 各种最大最小值(宏内定义了，include直接用) float.h 浮点数相关 stdio.h POSIX 限制 运行时限制只有运行时才能拿到，例如系统调用给出 sysconf pathconf/fpathconf 3. 无缓冲I/O（文件IO）3.1 文件描述符fd 所有打开文件都由fd引用，fd为非负int（出错时为负） 类似windows的HANDLE STDIN_FILENO STDOUT_FILENO STDERR_FILENO OPEN_MAX（文件打开的极限值） 进程各自维护自己的文件描述符表，文件描述符表记录文件描述符标志，和一个指向文件表项的指针 文件表项由内核为每一个打开的文件维护，包括文件状态标志、当前文件偏移、以及指向v结点的指针 ==不同进程打开同一个文件、同一进程调用多次open同一个文件==并不共享file table entry（文件表项） 因为各自的偏移可能不同，也可以理解为调用一次open打开一个文件表项，而复制fd与之无关 但是fork出来的子进程的fd指向同一个文件表项（因为文件描述符表也copy，p397） /dev/fd /prof/self/fd 3.2 APIopen/openat/create oflag 文件状态标志 O_RDONLY O_WRONLY O_RDWR 必须指定且互斥 O_APPEND O_CLOEXEC O_CREAT O_DIRECTORY O_EXCL O_SYNC O_DSYNC O_TRUNC O_CREAT | O_EXCL 配合测试创建文件的原子性 openat的path可以为相对路径 creat只写创建，想要创建写之后再读必须close之后再open，用open实现： open(path, O_RDWR | O_CREAT | O_TRUNC, mode) close 会关闭记录锁 进程终止，内核会自动关闭文件对象 RAII的思想 lseek 当前文件偏移量 文件空洞 read 返回值 &lt; 待读字节数的情景 eof 终端设备/行缓冲 管道/FIFO 中断 write 返回值 &lt; 待写字节数的情景 磁盘满 超过了给定进程的文件长度限制 pread/pwrite原子lseek + read/write dup/dup2 新描述符的FD_CLOEXEC总是被清除 （即fd flag） dup(fd) = fcntl(fd, F_DUPFD, 0); dup2(fd) = close(fd2); fcntl(fd, F_DUPFD, fd2); //且为原子操作 dup 和 fcntl 的 errno 不同 sync/fsync/fdatasync 内核维护高速缓存 延迟写 update守护进程周期性调用sync fcntl（重点）#include&lt;fcntl.h&gt; int fcntl(int fd, int cmd, … ); 复制一个已有的描述符 F_DUPFD/F_DUPFD_CLOEXEC 获取/设置文件描述符标志**(fd flag)** F_GETFD/F_SETFD 仅有的就是FD_CLOEXEC标志 fcntl(fd, F_SETFD, 1); 默认为0，即不关闭 获取/设置文件状态标志 F_GETFL/F_SETFL ==注意GETFL与GETFD的区别== 获取/设置异步I/O所有权 F_GETOWN/F_SETOWN 获取/设置记录锁 F_GETLK/F_SETLK/F_SETLKW ioctl 设备驱动 某个特定操作的接口 类比于windows的 DeviceControl 应用程序到设备驱动的万用接口 4. 文件和目录4.1 struct statPOSIX标准 + XSI扩展定义的字段 描述一个特定文件相关的信息 linux下的struct stat st_mode 文件类型 文件类型 宏 普通文件 regular file S_ISREG() 目录文件 directory file S_ISDIR() 符号链接 symbolic link S_ISLINK() 块特殊文件 block special file S_ISCHR() 字符特殊文件 character special file S_ISBLK() FIFO 命名管道 S_ISFIFO() socket S_ISSOCK() 消息队列 S_TYPEISMQ() 信号量 S_TYPEISEM() 共享内存 S_TYPEISSHM() mode set-user-id bit S_ISUID set-group-id bit S_ISGID 进程关联ID： 实际用户/组ID 有效用户/组ID 附属组ID 文件和目录的权限位 S_ISUID：执行时设置用户ID S_ISGID：执行时设置组ID S_ISVTX：粘着位 S_IRWXU：用户读、写和执行 S_IRUSR：用户读 S_IWUSR：用户写 S_IXUSR：用户执行 S_IRWXG：组读、写和执行 S_IRGRP：用户读 S_IWGRP：用户写 S_IXGRP：用户执行 S_IRWXO：其他读、写和执行 S_IROTH：用户读 S_IWOTH：用户写 S_IXOTH：用户执行 鉴权流程 4.2 文件系统VFS superblock incode 与文件一一对应，相当于身份证号 包含文件的元数据，不包含名称 内存中的inode和磁盘中的inode 名称-&gt;inode-&gt;disk block dentry 文件的逻辑属性 一个dentry对应一个inode 多个dentry可能对应一个inode(硬链接/软链接) file object 4.3 API状态相关 stat / fstat / statat / lstat ls - l命令 注意是否跟踪符号链接 权限相关 access / faccessat 探测文件是否存在 以实际用户ID和实际组ID测试访问能力 faccessat提供了 AT_EACCESS 和 AT_SYMLINK_NOFOLLOW umask 创建新目录或文件时，屏蔽字中置1的权限都会被关闭 区分umask命令 chmod / fchmod / fchmodat S_ISUID / S_ISGID S_IRWXU / S_IRWXG / S_IRWXO S_ISVTX(粘着位在linux无效) chown / fchown / fchownat / lchown chown命令 注意符号链接的处理 变更相关 truncate / ftruncate 截断/扩充 link / linkat unlink / unlinkat 用于确保临时文件被删除 标准库的remove rename / renameat oldname 非目录 newname存在 newname不存在 oldname 为目录 newname 存在 newname 不存在 符号链接 . 和 .. 不允许 symlink / symlinkat readlink / readlinkat open的局限：不能打开link本身 mkdir / mkdirat rmdir 控制相关 opendir / fopendir readdir / rewinddir / closedir / telldir / seekdir 类比文件/标准I/O的接口 chdir / fchdir getcwd 时间相关 futimens utimensat utimes 5.标准I/O即ISO C标准I/O 5.1 流 (stream) 无缓冲I/O围绕fd展开 有缓冲I/O围绕stream展开 流的定向(stream’s orientation) 单字节 字节定向 byte flow ASCII 多字节 宽定向 wide bytes flow 国际字符集 进程预定义流 stdin / stdout /stderr 流缓冲 意义 类型 全缓冲：填满I/O缓冲区后才进行实际I/O操作 行缓冲： 输入输出遇到换行符时执行I/O操作 2. 由于每行缓冲区固定，缓冲区满没有遇到换行符也要执行I/O 3. 任何时候只要通过标准lO库，要求从一个不带缓冲的流或者一个行缓冲的流(从内核请求数据的时机）得到输入数据，那么就会冲洗所有行缓冲输出流。(即要缓冲输入，先冲洗输出缓冲) 4. 指向终端的流通常使用行缓冲 不带缓冲：不进行缓冲 stdin 和 stdout 并不指向交互设备时，才能使全缓冲类型 (通过重定向) 如果指向终端设备，则是行缓冲的，否则是全缓冲的 stderr绝不能时全缓冲的，一般是不带缓冲 表现为buffersize = 1 5.2 FILE对象 不同平台的实现不同 linux fd 用于实际I/O buffer指针 buffer尺寸 buffer当前字符数 出错标志 文件结束标志 5.3 API fwide setbuf / setvbuf p118 fflush fopen / freopen / fdopen fclose 读写 getc / fgetc / getchar / ungetc putc / fputc / putchar fgets / (gets) fputs / (puts) fread / fwrite ferror / feof / clearerr ftell / ftello / fseek / fseeko / rewind fgetpos / fsetpos 格式化输入输出 printf / fprintf / dprintf / sprintf / snprintf scanf / fscanf / sscanf fileno 标准I/O到无缓冲I/O的adapter tmpnam / tmpfile 临时文件 fmemopen 内存流 6. 系统信息6.1 数据文件 /etc/passwd pwd.h中定义了struct passwd结构 可以任意由用户读取 是ASCII文件，可以用标准I/O读取，但是效率太低 因此系统提供API接口 /etc/group grp.h中定义了struct group结构 /etc/shadow 经单向加密算法处理过的用户口令副本 shadow.h中定义了struct spwd 阴影口令文件 /etc/shadow 不应该由一般用户读取 仅有少数几个程序需要访问加密口令,如login, passwd, 这些程序通常是设定 set-user-ID为root的程序 6.2 API6.2.1 数据文件 getpwuid / getpwnam getpwent / setpwent / endpwent getspnam / getspent / setspent / endspent getgrgid / getgenam getgrent / setgrent / endgrent getgroups / setgroups / initgroups 返回的结构都是一个静态变量，会覆盖前一次的结果，数据文件的API都提供了 get / set / end 组合技 6.2.2 系统信息 uname struct utsname gethostname time 日历时间 clock_gettime 获取指定的时钟类型的时间 实时系统时间 不带负跳数的实时系统时间 调用进程的CPU时间 调用线程的CPU时间 clock_getres 时间精度调整 clock_settime 对特定的时钟设置时间（某些需要权限） gettimeofday (deprecate) gmtime / localtime 日历时间转换为struct tm 结构 mktime strftime / strftime_l 格式化时间，打印字符串 strptime 7. 进程环境7.1概念1进程终止 从main返回 exit(main(argc, argv)) return 和 exit(0) 并无区别 exit()库函数 _exit / _Exit 系统调用 这两者区别： 不同标准定义 、是否做了清理工作 2 终止处理程序 atexit函数 事先声明，反向调用，类似栈 3 命令行参数 argc argv envp 环境表 全局变量 environ 函数 getenv / putenv 一般调用函数获取环境，而非读取environ 进程地址空间 .text / .data / .bss / stack / heap / others (so , debug , systab ) 4 跨越函数跳转 setjmp / longjmp 靠返回值val与正常函数调用区分 5 进程资源限制 getrlimit / setrlimit 7.2 API exit / _Exit / _exit atexit getenv / putenv / setenv / unsetenv / clearenv setjmp / longjmp 8. 进程控制8.1 概念进程ID 循环复用 特殊的进程ID swapper：0 内核交换进程 init：1 普通用户进程 超级用户特权 所有孤儿进程的父进程 进程的创建一次调用两次返回 父进程中返回创建的子进程ID 子进程返回0 getppid ( get parent id) 获取父进程ID 父子进程谁先执行不确定 子进程是父进程的副本 拷贝数据空间、堆、栈 COW （copy on write）写时复制 试图修改时才真正拷贝 fork + exec 从中受益 代码段共享 （只读） 拷贝文件描述符表 继承父进程相关属性 实际用户ID、实际组ID、有效用户ID、有效组ID 附属组ID 进程组ID 会话ID 控制终端 设置用户ID标识和设置组ID标识 当前工作目录 根目录 文件模式创建屏蔽字 信号屏蔽和安排 对任一打开文件描述符的执行时关闭(close-on-exec)标识 环境变量 连接的共享存储段 存储映像 资源限制 父子进程的不同之处 ID / PID 子进程tms_utime/tms_stime/tms_cutime/tms_ustime被清零 子进程不继承父进程文件锁 子进程未处理闹钟将被清除 子进程未处理信号集设置为空集 父子进程的生死交互子进程先于父进程终止 通过信号SIGCHILD发送退出状态给父进程 父进程可以通过wait / waitpid获取信息 子进程ID / 子进程终止状态 / CPU耗时 未善后的终止子进程为僵死进程（zombie） 父进程先于子进程终止 子进程父亲改为init 进程（pid 1） init进程会调用wait善后处理终止的子进程（防止全是zombie） wait / waitpid 如果所有子进程都还在运行，则阻塞 如果一个子进程终止，正等待父进程获取其终止状态，则取得终止状态立即返回（zombie状态也立即返回） 如果没有任何子进程则出错返回 waitpid功能补充 支持异步（需要设置options参数） 可选择性等待某个进程 ​ pid == -1 / 0 / &gt;0 / &lt;-1 更灵活的wait系列函数 exec族函数 更进一步的封装 popen system fork -&gt; exec -&gt; waitpid 权限 实际用户 / 组ID 有效用户 / 组ID setuid / setgid 进程拥有超级权限，二话不说直接改实际用户/组ID、有效用户/组ID为指定ID 如果没有超级权限，但是uid或gid设置为实际用户/组ID或保存的设置用户/组ID， 则只将有效用户/组ID改为指定ID 不满足前两条，通通返回错误(ret = -1, error = EPERM) 解释器文件 解释型语言源文件起始行标注 进程调度 优先级 nice 0~2*NZERO-1 sysconf获取 越大越低 getpriority setpriority 进程时间 时钟时间 用户CPU时间 系统CPU时间 times 8.2 API getpid getppid getuid geteuid getgid getegid fork vfork wait waitpid waitid wait3/wait4 execl execv execle execve execlp execvp fexecve setuid/setgid seteuid/setegid system nice getpriority/setpriority times 9. 进程关系9.1 概念终端 tty1-6 CTRL ALT F1-6 图形终端 ALT F7 pseudo tty（pty） 网络终端 进程组（作业job） 唯一标志ID getpgrp / getpgid setpgid 进程只能为自己和它的子进程设置进程组ID 唯一标志ID和组长的PID一致 多个进程的集合，每个进程都有所属的进程组 同一进程组的所有进程接受同一终端的各种信号 孤儿进程组 每个成员的父亲要么在本组，要么在其他会话中 会话 可以有0或一个控制终端（tty / pseudo tty) 建立与控制终端连接的会话首进程被称为控制进程 无控制终端可能为守护进程 一个到多个进程组的集合 一个前台进程 这意味着会话有一个控制终端 接受 ctrl c / ctrl \\ 产生的 SIGINT / SIGQUIT 信号 n个后台进程组 新建会话 setsid 该进程变成新会话的会话首进程 (session leader) 此时该 leader 是会话中的唯一进程 这意味这要新建会话 要先 fork 再 setsid 这就保证了进程不是进程组的组长 该进程成为一个新进程组的组长进程 新进程组ID是调用进程的进程ID 也是会话ID 该进程没有控制终端 如果调用 setsid 前有控制终端，则切断联系 作业控制 9.2 API getpgrp / getpgid / sepgid setsid / getsid tcgetpgrp / tcsetpgrp / tcgetsid 10. 信号10.1 概念异步事件 信号的产生是不定时的，随机的 可以简单理解为用户态的中断（软中断） 产生信号的方式 用户按键产生（ctrl C） 硬件异常产生 进程或者用户调用kill 但检测到某种软性条件已经发生，通知有关进程 SIGURG / SIGPIPE / SIGALARM / SIGABRT 进程处理信号的方式 忽略 ignore 大多数信号的默认处理方式 SIGKILL / SIGSTOP 不能被忽略 由硬件异常导致的信号最好不要被忽略 中断允许嵌套，但是一般终端过程中同一个中断会忽略 捕捉 catch 注册一个signal handler 信号到来时会打断当前执行流，转而去执行handler 不能捕捉SIGKILL / SIGSTOP 执行默认动作 函数 signal / sigaction 子进程继承了父进程处理信号的方式 被中断的系统调用 低速系统调用 可能会使进程永久阻塞的一类 出错返回 errno EINTR 自动重新启动的系统调用 ioctl read/readv write/writev wait/waitpid 可重入函数 异步信号安全 不可重入的情况 static静态变量 global全局变量 调用了不可重入函数 malloc是线程安全的（递归锁），但是维护共享内存，故是不可重入的 可靠信号 未决的 pending产生信号和送达之间 信号屏蔽字 signal mask （signal procmask） 进程可以阻塞某种信号递送sigpending 保持未决状态 直到进程接触阻塞或设置为忽略才送达 阻塞期间同一个信号触发多次（是否排队：sigqueue） sigsuspend 解除了 使用 sigprocmask 和 pause 组合 的原子性问题 信号集 sigset_t 相关api ： sigemptyset / sigfillset / sigaddset / sigdelset / sigismember 与 sigprocmask 相配合 递送信号 kill / raise 库函数 kill命令 定时器 alarm：SIGALARM 默认动作为终止进程 一个进程只能有一个定时器 睡眠 sleep / nanosleep / clock_nanosleep 进程控制的延申 信号做父子进程的同步 加入信号处理的system实现 非局部跳出（deprecated） sigsetjmp / siglongjmp 对比 setjmp / longjmp handler自动屏蔽某种信号 跳走后无法保存信号屏蔽字 10.2 API signal kill / raise alarm pause sigemptyset / sigfillset / sigaddset / sigdelset / sigismember sigprocmask / sigpending sigsetjmp / siglongjmp sigsuspend 信号屏蔽字被设置为sigmask指向的值然后挂起，在捕捉一个信号之后返回恢复原来的sigmask abort 11. 线程11.1 进程与线程的概念 进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位） 进程有自己的独立地址空间，线程是共享进程的地址空间 线程之间通信更方便，进程则要通过各种IPC机制 多进程更加健壮，一个进程异常挂掉不会导致其他进程挂掉 11.2 多线程与多核 单核也可以多线程 多核多线程可以达成同时run的效果 11.3 pthread标准 POSIX 线程 LinuxThreads的变化（NPTL） 11.4 线程信息以下不共享 线程ID pthread_t / pthread_equal / pthread_self 栈 信号屏蔽字 调度优先级 errno变量 线程私有数据 11.5 线程的生与死线程创建 pthread_create 线程创建不能保证哪个线程会先运行 线程继承调用线程的浮点环境和信号屏蔽字 但是 pending 信号集会被清除 线程终止 导致进程终止 任意线程调用 exit / _exit / _Exit 发送给线程的信号（默认终止进程） 单一线程终止 线程从启动历程返回 pthread_join / pthread_datch 线程被同一进程的其他线程取消 pthread_cancel 线程调用 pthread_exit 线程清理处理程序 pthread_cleanup_push / pthread_cleanup_pop 清理情况： 主动调用 pthread_exit 响应 pthread_cancel 调用 pthread_cleanup_pop 参数不为0的时候 直接 return 并不会执行清理 执行顺序与注册顺序相反 11.6 进程与线程原语 进程原语 线程原语 描述 fork pthread_create 创建新的控制流 exit pthread_exit 从现有的控制流中退出 waitpid pthread_join 从控制流中得到退出状态 atexit pthread_cancel_push 注册在退出控制流时调用的函数 getpid pthread_self 获取控制流的ID abort pthread_cancel 请求控制流的非正常退出 11.7 线程同步、一致性问题原子操作互斥锁 POSIX互斥量 struct pthread_mutex_t 初始化/销毁 pthread_mutex_init / pthread_mutex_destory 上锁 pthread_mutex_lock / pthread_mutex_timedlock / pthread_mutex_trylock / pthread_mutex_unlock 解锁 pthread_mutex_unlock 死锁 AB型死锁 解决方法： 按序获取锁（程序复杂） trylock / timedlock 读写锁(共享互斥锁) 状态 读锁：读请求 pass ，写请求阻塞直到读锁释放（共享锁） 引用计数实现 注意写请求的饥饿情况，通常写请求后的读请求被阻塞（FIFO) 写锁：阻塞任何的加锁请求（互斥锁） 无锁 一次只有一个线程可以占有写锁，可以有多个线程同时占有读锁 适用于读请求&gt;&gt;写请求的情况 POSIX读写锁 初始化 / 销毁 pthread_rwlock_init / pthread_rwlock_destroy 读锁 pthread_rwlock_rdlock / pthread_rwlock_tryrdlock / pthread_rwlock_timedrdlock 写锁 pthread_rwlock_wrlock / pthread_rwlock_trywrlock / pthread_rwlock_timedwrlock 解锁 pthread_rwlock_unlock 条件变量 配合互斥量使用，提供多线程会合的时间点 初始化 / 销毁 pthread_cond_init / pthread_cond_destroy 等待条件变量变为true pthread_cond_wait / pthread_cond_timedwait 条件变量置信 pthread_cond_signal 唤醒一个 / pthread_cond_broadcast 唤醒所有 自旋锁 spinlock 特征：忙等阻塞 锁持有时间段，线程不希望被调度 用户态基本不使用自旋锁 不要调用在持有自旋锁的情况下可能会进入休眠状态的函数 屏障 barrier 协调多个进程并行工作 每个线程等待，直到所有线程共同达到某一点 初始化 / 销毁 pthread_barrier_init / pthread_barrier_destory 等待 pthread_barrier_wait 未满足屏障计数时阻塞 、满足屏障计数时唤醒所有（最后一个线程） 12. 线程控制12.1 属性pthread遵循的对于属性的模式 每个对象都和自己类型的属性对象相关联（互斥量与互斥量属性相关联，线程与线程属性相关联），表现为 attr 指针，每个属性对象可以代表多个属性。属性对应用不透明，便于提高可移植性，因此需要函数来进行管理 每个属性对象有一个初始化函数，它把属性设置为默认值 还有一个销毁属性对象的函数，用于释放与属性对象的资源 获取各个属性值的函数，返回存储它的内存单元 设置属性值的函数，一般来说属性作为参数用指针传递 线程属性 初始化 / 销毁 pthread_attr_init / pthread_attr_destory 线程分离状态属性(分离线程的资源在线程终止时立即收回，无法用 join 等待其终止状态) pthread_attr_getdetachstate / pthread_attr_setdetachstate 以下不建议用 pthread_attr_getguardsize / pthread_attr_setguardsize pthread_attr_getstacksize / pthread_attr_setstacksize pthread_attr_getstack / pthread_attr_setstack 取消状态（取消点）不建议用 PTHREAD_CANCEL_ENABLE / PTHREAD_CANCEL_DISABLE pthread_setcancelstate 被取消线程在调用点会感知到取消 (pthread_cancel调用方不等待) 默认情况延迟取消 同步属性互斥量属性 pthread_mutexattr_t共享属性、健壮属性、类型属性 pthread_mutexattr_init / pthread_mutexattr_destroy 以下不建议使用 进程共享(内核开销大，不属于NPTL) pthread_mutexattr_getpshared / pthread_mutexattr_setpshared 健壮属性 类型属性 pthread_mutexattr_gettype / pthread_mutexattr_settype 互斥量类型 递归上锁 不占用时解锁 已解锁时解锁 PTHREAD_MUTEX_NORMAL 死锁 未定义 未定义 PTHREAD_MUTEX_ERRORCHECK 返回错误 返回错误 返回错误 PTHREAD_MUTEX_RECURSIVE 允许 返回错误 返回错误 PTHREAD_MUTEX_DEFAULT 未定义 未定义 未定义 递归锁的使用场景 读写锁属性 pthread_rwlockattr_t pthread_rwlockattr_init / pthread_rwlockattr_destroy pthread_rwlockattr_getpshared / pthread_rwlockattr_setpshared 条件变量属性 pthread_condattr_t pthread_condattr_init / pthread_condattr_destroy pthread_condattr_getpshared / pthread_condattr_setpshared 屏障属性 pthread_barrierattr_t pthread_barrierattr_init / pthread_barrierattr_destroy pthread_barrierattr_getpshared / pthread_barrierattr_setpshared 12.2 重入概念 如果一个函数对多个线程来说时可重入的，就说这个函数是线程安全的。但并不能说明对信号处理程序来说该函数也是可重入的。 如果函数对于异步信号处理程序的重入是安全的，那么可以说函数是异步信号安全的 重入的要求高于线程安全 可重入要求信号安全 一般来说： 如果一个函数的实现使用了全局或者静态变量，且访问未加锁，那么这个函数既不是可重入的，也不是线程安全的。 如果放宽条件，这个函数仍然用到了全局或者静态变量，但是在访问这些变量时，通过加锁来保证互斥访问，那么这个函数就可以变成线程安全的函数。但它此时仍然是不可重入的，因为通常加锁是针对不同线程的访问，对同一线程可能出现问题（发生信号软中断，signal handler中恰巧也执行了该函数）。 非线程安全函数 替代的线程安全函数 12.3 线程私有数据 由于线程共享地址空间，故线程无法阻止另一个线程访问其私有数据 因此需要管理线程特定数据的函数（设计上封装隔离） pthread_key_create / pthread_key_delete 让不同线程看到同一个键值 pthread_once pthread_once_t = PTHREAD_ONCE_INIT 1234567891011121314void destructor(void *);pthread_key_t key;pthread_once_t init_done = PTHREAD_ONCE_INIT;voidthread_init(Void)&#123; err = pthread_key_create(&amp;key, destructor);&#125;intthreadfunc(void *arg)&#123; pthread_once(&amp;init_done, thread_init); ...&#125; 关联键和私有数据 pthread_getspecific / pthread_setspecific 12.4 线程和信号 线程都有自己的信号屏蔽字 线程的处理是进程中所有线程共享的 信号是传递给单个线程的 信号与硬件相关，递送给引起时间的进程 其他信号发送给任意一个进程 pthread_sigmask sigprocmask在多线程环境中行为未定义 用法类似sigprocmask sigwait等待信号出现 先阻塞等待的信号（在外部） 原子取消信号集阻塞状态 信号递送后返回 返回前恢复阻塞信号集 类比条件变量和互斥量 多个线程等待同一信号，只有一个会被唤醒 pthread_kill 给指定进程发送信号 线程与I/O lseek read 多线程有问题 pread lseek read 的原子操作 12.5 API pthread_attr_init / pthread_attr_destroy pthread_attr_getdetachstate / pthread_attr_setdetachstate pthread_key_create pthread_mutexattr_init / pthread_mutexattr_destroy pthread_mutexattr_gettype / pthread_mutexattr_settype pthread_key_create / pthread_key_delete pthread_getspecific / pthread_setspecific pthread_sigmask pthread_sigkill 13. 守护进程13.1 概念守护进程的概念 内核态守护进程（内核线程） eg： 虚拟内存换页kswapd / 脏页面冲刷 flush 用户态守护进程 由 init 拉起 setsid 使其一般是会话首进程，同时也是进程组组长、唯一进程 编写守护进程的惯例 umask 设置文件模式创建屏蔽字 通常 umask(0) 父进程 fork 并 exit 为子进程 setsid 创建会话创造条件 setsid 会话首进程 / 进程组组长 / 没有控制终端 当前工作目录改为根目录或者其他位置 chdir(“/“) 防挂在umount 关闭不用的文件描述符 首先 getrlimit 判定最高文件描述符的值，然后用循环全部关闭 打开 /dev/null 使具有文件描述符0、1、2 因为守护进程并不与终端设备相关联，无从显示也无需输入 fd0 = open(“/dev/null”, O_RDWR); 一般还需要处理 SIGHUP 信号 原因：孤儿进程 出错记录 内核例程调用log函数 用户守护进程调用 syslog 函数 本地或其他主机可通过 UDP 514端口传递log rsyslog 单例守护进程 文件记录锁 记录锁 惯例 锁通常指定在 /var/run/%name%.pid 内容一般就是pid号 配置文件通常在 /etc/%name%.conf 守护进程一般通过初始化脚本之一启动 /etc/rc* /etc/init.d/* /etc/inittab启动自动重启 一般注册 SIGHUP 处理程序 一方面使为了防止默认动作终止 功能上设置为重新读取配置 13.2 API openlog / syslog / closelog / setlog / mask vsyslog 14 进阶I/O14.1 非阻塞I/O 低速系统调用 定义：会引起进程永久阻塞 某些文件类型数据不存在，读引起永久阻塞 数据不能被相同的文件类型接受，写操作会永久阻塞 对加了记录锁的文件读写 ioctl 进程通信函数 open 先天指定 O_NONBLOCK fcntl 后天设置 O_NONBLOCK 轮询 polling + 非阻塞I/O 类似用户态的自旋锁 浪费cpu时间 多线程 + 阻塞I/O 额外的线程开销、同步开销 14.2 记录锁 recording lock 确保进程单独写文件 进程读或写文件的某个部分时，使用记录锁组织其他进程修改同一文件区 byte range locking fcntl 记录锁 struct flock 1234567struct flock&#123; short l_type; short l_whence; off_t l_start; off_t l_len; pid_t l_pid;&#125; l_type : F_GETLK / F_SETLK / F_SETLKW F_GETLK 检测上锁后上锁不是原子操作 F_SETLKW 检测到死锁后杀死另一个进程获得资源 锁的隐含继承与释放 进程终止时，建立的所有锁全部释放 关联的fd何时关闭，锁都会释放 fork 子进程只能继承文件描述符，不能继承它的锁 文件尾端加锁 建议性锁和强制性锁 14.3 异步I/O不建议用 14.4 I/O多路转接(multiplexing)问题提出 阻塞模式下在多个fd上写，一个block会导致后面的pending polling + 无阻塞可以解决 异步I/O 用信号通知 缺点在于不知道哪个fd ready（不够映射） I/O多路复用 select select / pselect pselect 支持 timespec 结构，更精确的时间 最多支持fd 有上限 poll 通过数组表明关心的条件 解决了fd数量的瓶颈 epoll linux I/O多路转接的最优机制 性能高 规避了所有fd的用户态 copy 到内核态的开销 fd常驻内核 内核以红黑树组织 内核态只回传ready 部分的fd 边沿触发 14.5 其他readv / writev 散布读(scatter read) / 聚集写(gather write) iovec 结构数组 1234struct iovec&#123; void *iov_base; size_t iov_len&#125; 降低系统调用的次数，获取性能 readn / writen apue 对 read / write 的一些容错封装 原因： 管道、FIFO、网络、终端 可能读的字节数小于指定数量 写可能因为内核缓冲区满而失效 mmap / munmap 存储映射I/O 磁盘文件映射到内存空间 直接读写内存就是修改磁盘文件 mprotect 修改映射区权限 msync 立刻同步刷新","categories":[{"name":"linux / unix","slug":"linux-unix","permalink":"https://wuyifff.github.io/categories/linux-unix/"}],"tags":[]},{"title":"Linux Cammand Line 阅读笔记","slug":"linux & unix/linux命令行","date":"2021-05-24T07:38:00.000Z","updated":"2021-10-25T08:57:28.111Z","comments":true,"path":"2021/05/24/linux & unix/linux命令行/","link":"","permalink":"https://wuyifff.github.io/2021/05/24/linux%20&%20unix/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/","excerpt":"Linux 的基本操作以及原理介绍 中文翻译链接 https://github.com/billie66/TLCL","text":"1.引言 人们说，“图形用户界面让简单的任务更容易完成，而命令行界面使 完成复杂的任务成为可能”，到现在这句话仍然很正确。 2.什么是shell2.1终端仿真器shell 就是一个程序，它接受从键盘输入的命令，然后 把命令传递给操作系统去执行 当使用图形用户界面时，我们需要另一个和 shell 交互的叫做终端仿真器的程序。 2.2第一次按键用户名 @ 主机 名，紧接着当前工作目录和一个美元符号 如果提示符的最后一个字符是“#”, 而不是“$”, 那么这个终端会话就有超级用户权限。 这意味着，我们或者是以 root 用户的身份登录，或者是我们选择的终端仿真器提供超级用户 （管理员）权限。 2.3命令历史默认保存500 上箭头得到上一次命令 按下鼠标左键拖动快速复制，鼠标中键粘贴==不要用ctrl c== 设置聚焦跟随鼠标代替单机聚焦，可以使复制粘贴更方便 2.4简单命令12345datecal //显示月历df //显示磁盘剩余空间free //空闲内存exit //终止会话 2.5幕后控制台 按下 Ctrl-Alt-F1 到 Ctrl-Alt-F6 访问 当一个会话被访问的时候，它会显示登录提示框，我们需要输入用户名和密码。 要从一 个虚拟控制台转换到另一个，按下 Alt 和 F1-F6(中的一个)。返回图形桌面，按下 Alt-F7 3.文件系统中跳转3.1文件系统树 分层目录结构组织文件，所有文件组成一颗树型目录，倒置的树 总是只有一个单一的文件系统树，不管存储设备的连接（不像 Windows ，每个存储设备都有一个独自的文件系统） 3.2当前工作目录123pwd //print working directory显示当前目录ls //列出一个目录包含的文件以及子目录ls -a 当我们首次登录系统（或者启动终端仿真器会话）后，当前工作目录是我们的家目录。每个d用户都有他自己的家目录，当用户以普通用户的身份操控系统时，家目录是唯一允许用户写入文件的地方。 以 “.” 字符开头的文件名是隐藏文件，用ls -a命令 3.4更改当前工作目录123cd /usr/bin //绝对路径cd .. //相对路径回到usrcd ./bin //相对路径进入bin也可以直接cd bin 绝对路径从根目录开始，直到它的目的地，而相对路径开始于工作目录 符号 “.” 指的是工作目录，”..” 指的是工作目录的父目录 ==./是隐含的可以省略== 文件名和命令名是大小写敏感的 文件没有拓展名，文件名可能包含空格，标点符号，但标点符号仅限 使用“.”，“－”，下划线，但是不要使用空格 4.探究操作系统4.1ls123ls /usr //指定别的目录ls ~ /usr //指定多个目录（家目录和usr目录ls -l //以长模式输出 家目录用**~**代表 4.2选项和参数 大多数命令使用的选项，是由一个中划线加上一个字符组成，例如，“-l”，但是许多命令， 包括来自于 GNU 项目的命令，也支持长选项，长选项由两个中划线加上一个字组成。 4.3长格式输出 4.4确定文件类型1file filename //file命令打印文件内容的简单描述 4.5用less浏览文件内容 系统配置文件以文本格式储存 12less filenameless /etc/passwd 按下q键退出less程序 4.6浏览文件目录文件概览 5.操作文件和目录5.1通配符1ls /usr/bin/t* 5.2mkdir创建目录12mkdir directory... //三个点表示参数可重复mkdir dir1 dir2 dir3 5.3cp复制文件或目录12cp item1 item2 //复制单个文件或目录item1到item2cp item... directory //复制多个项目到一个目录下 5.4mv移动和重命名文件12mv item1 item2mv item... directory 5.5rm删除文件和目录1rm item... 5.6ln创建链接12ln file link //创建硬链接ln -s item link //创建符号链接 5.7硬链接 一个硬链接不能关联它所在文件系统之外的文件。 一个硬链接不能关联一个目录。 5.8符号链接（软链接/symlink） 类似于windows的快捷方式，其本身与其他符号链接几乎没有区别 向符号链接写入，写入相关联的文件，删除符号链接不会删除文件自身 坏链接为红色 5.9 playground练习（很重要） cp命令至少两个地址(本地用.) cp -v 看详细做了什么， -i 获得提示 mv要么两个地址（移动），要么改名字 ln创建链接 -s符号链接 跟文件和目录 ls -li 可以看到文件索引结点 创建符号链接可以绝对路径也可以相对路径 6.使用命令6.1命令四种形式 可执行程序，编程语言或脚本语言写成 内建于shell自身的命令,内建命令 shell函数，即小规模shell脚本，混合到环境变量中 命令别名，自定义命令建立在其他命令之上 6.2 type显示命令的类型12type typetype ls 6.3 显示一个可执行程序的位置1which ls 这个命令只对可执行程序有效，不包括内建命令和命令别名，别名是真正的可执行程序的替代物 6.4 help得到shell内建命令的帮助文档12help cdmkdir --help –help显示用法信息 6.5 man显示程序手册页1man ls man使用less显示参考手册，可以使用less命令进行浏览 man参考手册分成的章节： 1man 5 passwd 如果不成功显示No manual entry for passwd in section 5 则需要yum install man-pages 6.6 apropos显示适当的命令12apropos floppyman -k floppy //功能同上 输出结果每行的第一个字段是手册页的名字，第二个字段展示章节 6.7 whatis显示简洁的命令说明1whatis 命令/系统调用/库函数/特殊文件名 相当于man -f 6.8 info显示程序info条目1info ls info 文件是树型结构,包含超链接，可以从*号处跳转到另一个结点 6.9 README以及其他程序文档 许多安装在你系统中的软件，都有自己的文档文件，这些文件位于/usr/share/doc 目录下。大多数是以文本文件的形式存储的，可用 less 阅读器来浏览。 以 “.gz” 结尾的文件表示 gzip压缩程序已经压缩了这些文件。gzip软件包包括一个特殊的 less 版本，叫做 zless，zless 可以显示由 gzip 压缩 的文本文件的内容。 6.10用别名（alias）创建命令1234alias foo=&#x27;cd /usr; ls; cd -&#x27;alias name=&#x27;string&#x27; //格式type foounalias foo //删除别名 在命令 “alias” 之后，输入“name”，紧接着（**没有空格 **）是一个等号，等号之后是一串用引 号引起的字符串，字符串的内容要赋值给 name。 通常经常使用的命令带有普遍用到的选项，例如 ls is aliased to `ls –color=auto’，使用不带参数的alias查看默认定义的别名 ==在命令行中定义别名有点儿小问题。当你的 shell 会话结束时，它们会消失。== 7.I/O重定向7.1标准输入输出和错误 默认情况下，标准输出stdout和标准错误都连接屏幕而不是磁盘文件。 标准输入stdin默认情况下连接键盘 I/O重定向允许我们更改输出地点和输入来源 7.2标准输出重定向 用 &gt; 重定向符接文件名 12ls -l /usr/bin &gt; ls-output.txt //直接创建文件less le-output.txt 当我们使用 “&gt;” 重定向符来重定向输出结果时，目标文件总是 从开头被重写（如果错误了就清空文件） 12&gt; ls-output.txt //故意用重定向符来清空文件内容ls -l /usr/bin &gt;&gt; ls-output.txt 用 &gt;&gt; 操作符可以把输出结果加到文件内容之后，如果文件不存在则会被创建 7.3标准错误重定向 一一个程序可以在几个编号的文件流中的任一个上产生输出。前三个称作标准输入、输出和错误，shell 内部分别将其称为文件描述符 0、1 和 2 1ls -l /bin/usr 2&gt; ls-error.txt //测试错误输出 7.4 重定向标准输出和错误到同一个文件 方法一 1ls -l /bin/usr &gt; ls-output.txt 2&gt;&amp;1 完成两个重定向，首先重定向标准输出到文件，然后重定向标准错误到标准输出，用2&gt;&amp;1。 注意重定向的顺序安排非常重要。标准错误的重定向必须总是出现在标准输出重定向之后， 要不然它不起作用。 12&gt; ls-output.txt 2&gt;&amp;1 //重定向标准错误到文件 ls-output.txt2&gt;&amp;1 &gt; ls-output.txt //标准错误定向到屏幕 方法二 1ls -l /bin/usr &amp;&gt; ls-output.txt 用 &amp;&gt; 来重定向标准输出和错误到文件 ls-output.txt 7.5处理不需要的输出 不想要一个命令的输出结果，系统重定向输出结果到 /dev/null 的特殊文件 1ls -l /bin/usr 2&gt; /dev/null 7.6 cat连接文件 cat 命令读取一个或多个文件，然后复制它们到标准输出 123cat [file] //复制到标准输出cate ls-output.txt //显示简短的文本文件cat -n textfile1 &gt; textfile2 //把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里,换成&gt;&gt;为附加到文档中 1234cat &gt; lazy_dog.txt //等待输入wowowo. //ctrl d结束cat lazy_dog.txt //复制文件内容到标准输出cat &lt; lazy_dog.txt //重定向标准输入，输入源为lazy_dog.txt 7.7管道线 管道线使得标准输入读取数据并输送到标准输出，一个命令的标准输出可以通过管道传到另一个命令的标准输入 12command1 | command2ls -l /usr/bin | less //不加less则直接输出到最后一行等待下一步命令，有less变成浏览文本文件 可以很方便的检测会产生标准输出的命令的运行结果 7.8过滤器 用来对数据完成复杂操作，把几个命令放在一起组成一个管道线，过滤器接受输入，以某种方式改变它，然后输出它。 1ls /bin /usr/bin | sort | less //产生两个目录的有序列表 7.9 uniq 报道或忽略重复行 uniq 经常和 sort 命令结合起来一起使用，默认情况下在数据列表中删除任何重复行 12ls /bin /usr/bin | sort | uniq | lessls /bin /usr/bin | sort | uniq -d | less //只看重复数据列表 7.10 wc 打印行数字数和字节数 wc（字计数）命令是用来显示文件所包含的行数、字数和字节数。 如果 wc 不带命令行参数，它接受标准输入。“-l” 选项限制命令输出只能报道行数。添加 wc 到管道线来统计数据，是个很便利的方法。查看我们的有序列表中程序个数 12wc ls-output.txtls /bin /usr/bin | sort | uniq | wc -l 7.11 grep打印匹配行 grep用来找到文件中的匹配文本 12grep pattern [file...] //使用方法ls /bin /usr/bin | sort |uniq | grep zip //找到文件名中包含单词zip的所有文件 grep -i 忽略大小写 -v 只打印不匹配的行 7.12 head/tail打印文件开头部分/结尾部分1234head -n 5 ls-output.txttail -n 10 ls-output.txtls -l /usr/bin | tail -n 5 //用于管道线中tail -f /var/log/messages //循环读取，跟踪增长情况 7.13 tee从stdin读取数据，并同时输出到stdout和文件 tee 程序从标准输入读入数据，并且同时复制数据到标准输出（允许数据继续随着管道线流动和一个或多个文件。当在某个中间处理阶段来捕捉一个管道线的内容时，这很有帮助。 1ls /usr/bin | tee ls.txt | grep zip 在 grep 过滤 管道线的内容之前，来捕捉整个目录列表到文件 ls.txt 8.从shell眼中看世界8.1 （字符）展开 echo 命令显示一行文本 12echo this is a test //测试echoecho * //观察*的展开,打印了所有文件 shell 中 * 会被展开，当回车键被按下时，shell 在命令被执行前在命令行上自动展开任何符合条件的字符，所以 echo 命令的实际参数并不是 “*”，而 是它展开后的结果。 8.2 路径名展开 通配符所依赖的工作机制叫做路径名展开 1echo /usr/*/share 隐藏文件的路径名展开 12echo .* //隐藏文件均以原点开头，但是输出包含 &#x27;.&#x27; 和 &#x27;..&#x27;ls -d .* | less //-d表示只显示当前目录文件，展开正确 8.3波浪线展开 用在一个单词开头时，它会展开成指定用户的家目录名，如果没有指定用户名，则展开成当前用户的家目录 12echo ~echo ~root 8.4 算术表达式展开12echo $((expression))echo 5+$((9-8)) 8.5 花括号展开1echo Front-&#123;A,B,C&#125;-Back 花括号展开模式可能包含一个开头部分叫做报头，一个结尾部分叫做附言。花括号表达式 本身可能包含一个由逗号分开的字符串列表，或者一个整数区间，或者单个的字符的区间。这 种模式不能嵌入空白字符 12echo Number &#123;1..5&#125;echo &#123;Z..A&#125; 花括号展开可以嵌套，最常见的应用是，创建一系列的文件或目录列表 1234mkdir Picscd Picsmkdir &#123;2007..2019&#125;-0&#123;1..9&#125; &#123;2007..2019&#125;-&#123;10..12&#125;ls 8.6 命令替换 命令替换允许我们把一个命令的输出作为一个展开模式来使用 不只限制于简单命令,也可以使用整个管道 线 12ls -l $(which cd) //which得到cd命令的地址，ls显示文件信息file $(ls /usr/bin/* | grep zip) //用于管道线，管道线输出结果为file命令的参数列表 8.7 引用 双引号 把文本放在双引号中，shell 使用的特殊字 符，都失去它们的特殊含义，被当作普通字符来看待 在双引号中，参数展开、算术表达式展开和命令替换仍然有效 123ls -l &quot;two words.txt&quot; //防止单词分割echo $(cal)echo &quot;$(cal)&quot; //在第一个实例中，没有引用的命令替换导致命令行包含38 个参数。在第二个例子中，命令行只有一个参数，参数中包括嵌入的空格和换行符。 单引号 禁止所有展开，包括转义字符 123echo text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USERecho &quot;text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER&quot;echo &#x27;text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER&#x27; 8.8 转义字符 \\ 作为转义字符，阻止展开、消除特殊含义字符(比如$) 在文件名包含特殊字符时起作用 12echo &quot;The balance for user $USER is: \\$5.00&quot;echo &quot;The balance for user $USER is: $5.00&quot; 9 键盘高级操作9.1 移动光标 9.2 修改文本 9.3 剪切和粘贴文本 9.4 自动补全 按下tab，自动补全路径名、对变量补全、用户名、命令、主机名 9.5 利用历史命令 搜索历史命令 123history | less //浏览历史列表的内容history | grep /usr/bin!88 //展开历史列表中88行的内容 ctrl-r进入搜索 9.8 历史命令展开 10 权限10.1 拥有者、组成员和其他人1id //显示用户id并且映射到一个用户名 用户帐户定义在/etc/passwd 文件里面,用户组定义在/etc/group 10.2 读取写入和执行 剩下的九个字符叫做文件模式，代表着文件所有者、文件组所有者和其他人的读、写和执 行权限。 owner group world rwx rwx rwx 属性 文件 目录 r 允许打开并 读取文件内 容 允许列出目录中的内容，前提是目录必须设置了可执 行属性（x） w 允许写入文 件内容或截 断文件。但 是 不允 许 对文件进行重命名或删 除，重命名 或删除是由 目录的属性 决定的 允许在目录下新建、删除或重命名文件，前提是目录 必须设置了可执行属性（x） x 允许将文件 作为程序来 执行，使用 脚本语言编 写的程序必 须设置为可 读才能被执 行。 允许进入目录，例如：cd directory 10.3 chomod更改文件模式分为八进制表示法和符号表示法两种 八进制对应3个二进制数字，正好用于映射存储文件模式所使用的方案 chomod 600 foo.txt 常见映射7 (rwx)，6 (rw-)，5 (r-x)，4 (r–)，和 0 (—) 符号表示法 操作内容 u+x 为文件所有者添加可执行权限 u-x 为文件所有者添加可执行权限 +x 为文件所有者，用户组，和其他所有人添加可执行权限。等 价于 a+x o-rw 除了文件所有者和用户组，删除其他人的读权限和写权限 go=rw 给文件所属的组和文件所属者/组以外的人读写权限。如果 文件所属组或其他人已经拥有执行的权限，执行权限将被移 除 u+x,go=rw 给文件拥有者执行权限并给组和其他人读和执行的权限。 多种设定可以用逗号分开 10.4 借助GUI来设置文件模式 右击文件或者目录图标 10.5 umask设置默认权限 umask值 权限 0000 -rw-rw-rw- 0002 -rw-rw-r– 有二进制数字1的位置属性被删除 12umask //得到掩码值umask 0000 //设置掩码值 setuid、setgid、sticky位特殊权限 123chmod u+s program //授予一个程序 setuid 权限chmod g+s dir //授予一个目录 setgid 权限chmod +t dir //授予一个目录 sticky 权限 属性 结果 具有 setuid 属性的程序 -rw**s**r-xr-x 具有 setgid 属性的目录 drwxrw**s**r-x 设置了 sticky 位的目录 drwxrwxrwt 10.6 更改身份 注销系统并以其他用户身份重新登录系统。 使用 su 命令 使用 sudo 命令 10.7 su命令1su [-[l]] [user] 如果包含 “-l” 选项，那么会为指定用户启动一个需要登录的 shell。这意味着会加载此用户 的 shell 环境，并且工作目录会更改到这个用户的家目录。这通常是我们所需要的。**-l可以缩写为-** 如果不指 定用户，那么就假定是超级用户 输入exit回到原来的shell 12su -c &#x27;command&#x27; //格式su -c &#x27;ls -l /root/*&#x27; 传递命令command到新的shell中执行，而不启动这个shell，引号防止命令展开 10.8 sudo命令 sudo 命令不要求超级用户的密码，使用 sudo 命令时，用户 使用他/她自己的密码来认证 管理员能够配置 sudo 命令，从而允许一个普通用户以不同的身份（通常是超级用户），通过一种非常可控的方式来执行命令 su 和 sudo 之间的一个重要区别是 sudo 不会重新启动一个 shell，也不会加载 另一个用户的 shell 运行环境 10.9 chown更改文件所有者和用户组1chown [owner][:[group]] file 1234567[janet@linuxbox ~]$ sudo cp myfile.txt ~tony //用户 janet 把文件从她的目录复制到 tony 的家目录Password:[janet@linuxbox ~]$ sudo ls -l ~tony/myfile.txt-rw-r--r-- 1 root root 8031 2008-03-20 14:30 /home/tony/myfile.txt[janet@linuxbox ~]$ sudo chown tony: ~tony/myfile.txt //janet 把文件所有者从 root（使用 sudo 命令的原因）改到 tony,同时把文件用户组改为 tony 登录系统时，所属的用户组，碰巧是用户组 tony[janet@linuxbox ~]$ sudo ls -l ~tony/myfile.txt-rw-r--r-- 1 tony tony 8031 2008-03-20 14:30 /home/tony/myfile.txt 可能存在的问题： 系统中默认的掩码值是 0022，这会禁止用户组成员编辑 属于同组成员的文件，修改掩码值解决 用户组成员创建的文件和目录的用户组，将会设置为用户的主要组，而不是想要的用户组，设置此目录的setgid位来解决 10.10 更改用户密码1passwd [user] 如果你具有超级用户权限，你可以指定一个用户名作为 passwd 命令的参数，这样可以设置 另一个用户的密码。还有其它的 passwd 命令选项对超级用户有效，允许帐号锁定，密码失效,详细内容参考 passwd 命令的手册页 还有一系列的命令行程序，可以用来创建和维护用户和用户组： adduser useradd groupadd 11 进程11.1 ps查看进程123psps x //显示所有进程ps aux //显示所有进程并获得详细信息 stat状态含义 11.1 top查看进程1top //动态显示进程 h查看帮助，q退出 11.2信号kill命令可以像进程发送信号，默认是term 注意，信号既可以用号码，也可以用名字来 指定，包括在前面加上字母“SIG”的名字 12kill -signal PIDkill -1 13546 11.3 killall向多个进程发送信号1killall [-u user] [-signal] name... 10.4 关闭系统4种方式 halt poweroff reboot shutdown 123sudo rebootsudo shutdown -h now //挂起sudo shutdown -r now //重启 12 环境12.1检查环境1234printenv | lessprintenv USER //列出指定环境变量的值set | lessecho $HOME //用echo命令查看变量内容 环境中的别名无法使用set命令和printenv命令显示，想要查看别名，可以使用不包含参数的alias 查找用/ ,区分大小写 12.2 值得注意的环境变量 12.3 如何建立环境 是登录 shell 会话 非登录shell会话 非登录 shell 会话也会继承它们父进程的环境设置，通常是一 个登录 shell 12.4 启动文件 当我们 输入 ls 后，shell 不会查找整个计算机系统来找到 /bin/ls（ls 命令的全路径名），相反，它查找 一个目录列表，这些目录包含在 PATH 变量中 1PATH=$PATH:$HOME/bin //修改 PATH 变量，添加目录 $HOME/bin 到目录列表的末尾 12.5 修改环境、使用文本编辑器 添加目录到你的 PATH 变量或者是定义额外的环境变量，要把这些更改放置 到.bash_profile 文件中 1gedit some_file //如果所输入的文件名不存在，编辑器则会假定你想要创建一个新文件 当我们编辑一个重要的配置文件时，首先创建一个这个文件的备份总是一个不错的主意。这样能避免我们在编辑文件时弄乱文件 1cp .bashrc .bashrc.bak ctrl O 保存文件，ctrl X 退出 我们对于文件.bashrc 的修改不会生效，直到我们关闭终端会话，再重新启动一个新的会话，因 为.bashrc 文件只是在刚开始启动终端会话时读取。然而，我们可以强迫 bash 重新读取修改过 的.bashrc 文件,用命令 1source .bashrc 13 vi入门13.1 启动和退出1234vi //启动vi:q //退出vi:q! //强制退出（一般是修改没保存）//连按两下esc可以回到命令模式 13.2 编辑模式 刚进入vi进入到命令模式，每一个按键都是命令，按i键进入输入模式 按两下esc回到命令模式，输入:w保存 小贴示：如果你阅读 vim 的文档，你会发现命令模式被（令人困惑地）叫做普通模式（normal mode)，ex 命令叫做命令模式 13.3 光标移动 G是大写，要配合shift vi命令都可以加上数字前缀，5j可以使光标下移5行 13.4 基本编辑追加 insert命令做不到 a 命令，在当前光标后追加（进入插入模式） A命令，在当前行末尾追加（进入插入模式） 新建 删除 手速要快 按u撤销删除 剪切复制和粘贴 d 命令不仅删除文本，它还“剪切”文本。每次我们使用 d 命令，删除的部分被复制到一 个粘贴缓冲区中（看作剪切板） y命令复制文本 命令 功能 p 粘贴至下一行（无论光标在这一行的哪里） P 粘贴至上一行（无论光标在这一行的哪里） 合并 J 命令合并光标所在行与下一行 13.5 搜索和替换搜索 行内搜索用 fa 命令；按 ; 继续行内搜索 搜索整个文件 /,重复搜索n即可 全局搜索和替换123:%s/Line/line/g //把文件中所有的单词Line都更改为line:1,$s/Line/line/g //与前面那个一样:%s/line/Line/gv //把line改回去，c要求每一次替换前确认替换 13.6 编辑多个文件12345vim file1 file2 file3... //用vi会出现问题（可能vi不支持）:bn //切换到下一个文件（强制切换加上！）:bp //切换到上一个文件:buffers //显示缓冲区:buffer 1 载入更多文件 1:e ls-output.txt 将一个文件的内容复制到另一个文件: 用yy复制buffer切换p粘贴即可 将整个文件插入另一个文件（注意是在光标位置之后） 1:r foo.txt //在光标位置之后将文件读入并 13.7 保存工作 在命令模式下输入 ZZ 即可 输入:w 另存为 :w foo1.txt (注意这样是另存为foo1，现在仍在编辑foo) 14. 定制提示符14.1 分解提示符12echo $PS1[\\u@\\h \\W]\\$ 转移字符表 14.2 换一种提示符123ps1_old=&quot;$PS1&quot; //首先备份现有的提示符PS1=&quot;$ps1_old&quot; //恢复原有的提示符PS1=&quot;\\[\\033[0;41m\\]&lt;\\u@\\h \\W&gt;\\$\\[\\033[0m\\]&quot; //前一个使输出系统信息为红色，后一个使输入文字信息为黑色 背景颜色 光标设置 PS1=&quot;\\[\\033[s\\033[0;0H\\033[0;41m\\033[K\\033[1;33m\\t\\033[0m\\033[u\\]&lt;\\u@\\h \\W&gt;\\$&quot;使用上面的编码，我们将构建一个提示符，每次当这个提示符出现的时候，会在屏幕的上方 画出一个包含时钟（由黄色文本渲染）的红色长条 14.3 保存提示符 把下面两行添加到.bashr文件中去 12PS1=&quot;\\[\\033[s\\033[0;0H\\033[0;41m\\033[K\\033[1;33m\\t\\033[0m\\033[u\\]&lt;\\u@\\h \\W&gt;\\$&quot;export PS1 15 软件包管理15.1 打包系统 15.2 软件包的工作方式 Linux系统中几乎所有的软件都可以在互联网上找到。其中大多数软件由发行商以包文件的形式提供，剩下的则以源码形式存在，可以手动安装。 在包管理系统中软件的基本单元是包文件。包文件是一个构成软件包的文件压缩集合。一个软件包可能由大量程序以及支持这些程序的数据文件组成。 系统发行版的用户可以在一个中心资源库中得到这些软件包，这个资 源库可能包含了成千上万个软件包，每一个软件包都是专门为这个系统发行版建立和维护的。 程序很少独立工作；他们需要依靠其他程序的组件来完成他们的工作。现代的软件包管理系统都提供了一些依赖项解析方法，以确保安装软 件包时，其所有的依赖也被安装。 15.3 常见的软件包管理任务查找 安装 下载安装 下载好文件直接安装 卸载 更新 通过下载的软件包升级 列出 确认是否安装 显示安装包信息 查找安装了某个文件的包 16 存储介质16.1存储设备的挂载与卸载 Linux 在单一文件系统树中维 护连接在各个节点的各种设备。在MS-DOS 和 Windows 系 统中，每个设备（例如 C:\\，D:\\，等）保持着单独的文件系统树 文件 /etc/fstab 列出了系统启动时要挂载的设备 cat /etc/fstab 查看已挂载的文件系统列表 mount命令 若有光盘： 123umount /dev/hdc //卸载CDROM（需要root权限）mkdir /mnt/cdrom //建立新目录mount -t iso9660 /dev/hdc /mnt/cdrom //将CDROM挂载到新的挂载点，-t指定文件系统类型 16.2 确定设备名称 列出/dev 目录下的内容 ls /dev tail -f /var/log/messages 对操作系统实时监测，插入设备观察设备名称，知道设备名称之后挂载设备 挂载之后设备只要不拔下来，并且系统不重启，设备名称就不会发生变化 用df命令显示目前在 Linux 系统上的文件系统磁盘使用情况统计 16.3 创建新文件系统用fdisk修改文件系统12345678sudo umount /dev/sdb1sudo fdisk /dev/sdbCommand (m for help):m //显示菜单Command (m for help):p //显示设备分区表Command (m for help):l //显示可能的文件系统列表及对应的idCommand (m for help):t //修改Hex code (type L to list codes): 83Command (m for help):w //保存 使用mkfs创建新的文件系统make file system 12sudo mkfs -t ext3 /dev/sdb1 //指定ext4为文件系统类型sudo mkfs -t vfat /dev/sdb1 //指定vfat为文件系统类型 16.4 文件系统的检查与修复 sudo fsck /dev/sdb1修复损坏的文件系统 已修复的文件会存放在各个文件系统根目录下的lost+found 目录里面 16.5 设备之间直接移动数据 dd命令实现将数据块从一处复制到另一处 12345dd if=input_file of=output_file [bs=block_size [count=blocks]]dd if=/dev/sdb of=/dev/sdc //如果连接两个设备到计算机上，它们各自被分配到设备/dev/sdb和/dev/sdc上把第一个驱动器中的所有数据复制到第二个驱动器中dd if=/dev/sdb of=flash_drive.img //如果只有第一个驱动器被连接到计算机上，我们可以把它的内容复制到一个普通文件中供以后恢复或复制数据 ==注意==： dd命令的功能非常强大，起名取自“data definition”（数据定义），然而有时候也会被成为“destory disk”（摧毁磁盘），因为用户经常不小心输错if 或者of 说明。在Enter之前，一定要检查一遍if of说明！ 向可刻录CD写入数据写入一个可记录的 CD-ROM（一个 CD-R 或者是 CD-RW）由两步组成 首先，构建一个 iso 映像文件，这就是一个 CD-ROM 的文件系统映像 第二步，把这个映像文件写入到 CD-ROM 媒介中。 创建iso映像文件123dd if=/dev/cdrom of=ubuntu.iso //使用 dd 命令来读取 CD-ROW 中的所有数据块，并把它们复制到本地文件中genisoimage -o cd-rom.iso -R -J ~/cd-rom-files //用genisoimage命令来从文件集合中创建一个映像//“-R” 选项添加元数据为 Rock Ridge 扩展，这允许使用长文件名和 POSIX 风格的文件权限。 “-J” 选项使 Joliet 扩展生效，这样Windows中就支持长文件名了 写入CD-ROM中 直接挂载iso映像文件 1234mkdir /mnt/iso_image //创建挂载点mount -t iso9660 -o loop image.iso /mnt/iso_image //使用mount命令的-o loop选项、指定文件系统类型的-t iso9660选项，将iso映像文件当作设备挂载到文件系统树（可以把它当作真实的CD使用）md5sum image.iso //使用md5sum命令产生十六进制书校验文件(检查完整性)md5sum /dev/cdrom 擦除可刻录CD、刻录映像文件 17 联网17.1 网络检查与监控ping ping命令： ping 命令发送一个特殊的网络数据包，叫做 ICMP ECHO_REQUEST，到一台指定的主机。大多数接收这个包的网络设备将会回复它，来 允许网络连接验证 注意：大多数网络设备（包括 Linux 主机）都可以被配置为忽略这些数据包。通常，这样 做是出于网络安全原因，部分地遮蔽一台主机免受一个潜在攻击者地侵袭。配置防火墙来阻塞 IMCP 流量也很普遍。 traceroute traceroute程序完整过程：首先它发送一份TTL字段为1的IP数据包给目的主机，处理这个数据包的第一个路由器将TTL值减1，然后丢弃该数据报，并给源主机发送一个ICMP报文（“超时”信息，这个报文包含了路由器的IP地址，这样就得到了第一个路由器的地址），然后traceroute发送一个TTL为2的数据报来得到第二个路由器的IP地址，继续这个过程，直至这个数据报到达目的主机 输出结果中会列出网络流量从本地系统到指定主机的所有跳（hop）数，其中没有提供标识信息的路由器用*号表示 ip ip a检查系统的网络接口和路由表 当执行日常网络诊断时，要查看的重要信息是每个网络接口第四行开头出现的单词“UP”， 说明这个网络接口已经生效，还要查看第二行中 inet字段出现的有效 IP 地址。 netstat netstatt 程序被用来检查各种各样的网络设置和统计数据。通过此命令的许多选项，我们可以看 看网络设置中的各种特性 使用“-ie”选项，我们能够查看系统中的网络接口 “-r”选项能够显示内核的网络路由表，从中能够看出分组时如何在网络之间传送的 17.2 通过网络来传输文件ftp FTP指的是协议，ftp指的是与之同名的程序 命令 功能 ftp fileserver 连接名叫fileserver的ftp服务器 cd pub/ 在大多数匿名的 FTP 服务器中，支持公共 下载的文件都能在目录 pub 下找到 lcd Desktop 将本地目录改为 ~/Desktop,ftp程序工作目录默认在 ~/Desktop下 get …iso 将远程系统文件传至本地，即~/Desktop bye 登出远程服务器 lftp-更好的ftp：包括多协议支持（包括 HTTP），若下载失败会自动地重新下载， 后台处理，用 tab 按键来补全路径名 wget 支持递归下载、后台下载、断点续传 wget http://linuxcommand.org/index.php 17.3 与远程主机的通信 都在OpenSSH包中 ssh（Secure Shell) 认证身份 加密本地与远程主机通信（从22端口） SSH 由两部分组成。(必须都要安装) 1.SSH服务端运行在远端主机上，在端口 22 上监听收到的外部连接 2.SSH客户端用在本地系统中，用来和远端服务器通信 命令 功能 ssh bob@remote-sys 以用户bob的身份连接远程主机 ssh remote-sys free 在远程主机上运行free命令并在本地显示结果 ssh remote-sys &#39;ls *&#39; &gt; dirlist.txt 输出到本地主机文件（ls命令用单引号括起来防止在本地展开） ssh remote-sys &#39;ls * &gt; dirlist.txt&#39; 输出到远程主机（注意单引号位置） ssh -X remote-sys;xload 在远程主机上运行xload窗口出现在本地主机（-X传界面） scp与sftpscp scp（安全复制）被用来复制文件，与熟悉的 cp 程序非常相似。最显著的区别就是源或者目标 路径名要以远端主机的名字，后跟一个冒号字符开头 1scp bob@remote-sys:document.txt //以bob账号登入远程主机并复制文件 sftp ftp 程序的安全替代品,是 sftp 不需要远端系统中运行 FTP 服务端。 它仅仅需要 SSH 服务端。这意味着任何一台能用 SSH 客户端连接的远端机器，也可当作类似 于 FTP 的服务器来使用。 用法参照ftp 18 查找文件18.1 locate查找文件 locate bin/zip列出所有以zip开头的程序，目录以bin/结尾的程序 结合grep命令使用更高效 18.2 find-复杂的文件的查找方法12find ~ //指定一个目录为查找范围find ~ | wc -l 测试条件123find ~ -type d | wc -l //type d限制只查找目录find ~ -type f | wc -l //限制只查找普通文件find ~ -type f -name &quot;*.JPG&quot; -size +1M | wc -l //查找所有匹配*.JPG而且大于1MB的普通文件（加入双引号防止路径名扩展） 操作符 查找权限不为0600的文件和权限不为0700的目录 1find ~ \\( -type f -not -perm 0600 \\) -or \\( -type d -not -perm 0700 \\) 注意默认使用and 以及括号组合字符 对于被分隔的表达式，不一定默认求值 expr1 -operator expr2 预定义操作 -print 为默认操作 12find ~ -type f -name &#x27;*.bak&#x27; -print //先筛选再printfind ~ -print -type f -name &#x27;*.bak&#x27; //先print再筛选 在使用delete命令之前，先用print检查输出，确保万无一失 自定义操作 find的-exec选项 command是命令名， {} 是代表当前路径名的符号， ; 作为分隔符，表示命令结束（需要转义，用\\ 和 ‘’ 都可以） 123-exec command &#123;&#125; ; //-exec操作用法find ~ -type f -name &#x27;.*&#x27; -exec ls -l &#x27;&#123;&#125;&#x27; &#x27;;&#x27; //在当前目录下，找到所有的隐藏文件并ls -l输出find ~ -type f -name &#x27;.*&#x27; -ok ls -l &#x27;&#123;&#125;&#x27; &#x27;;&#x27; //加入 -ok 在执行操作前提示用户 提高效率 （使用xargs 或者find命令自身新特性） 将结尾的分号改成加号，就能让find命令将查找结果组合成参数列表，共指定的命令一次性使用 1find ~ -type f -name &#x27;.*&#x27; -exec ls -l &#x27;&#123;&#125;&#x27; + 虽然得到一样的结果，但是只执行了一次ls命令 xargs 从标注输入接受输入，将其转换为指定命令的参数列表 命令参数数量不是无限制的，超出shell支持的最大参数xargs会重复使用最大参数直至完成 12find ~ -type f -name &#x27;.*&#x27; -print | xargs ls -l //find命令的输出结果通过管道传给了xargs命令，后者构造ls命令的参数列表，然后执行该命令find ~ -type f -name &#x27;.*&#x27; -print | xargs --show-limits ls -l //执行xargs 时加入--show-limits显示最大支持参数(注意是在xargs命令后面加入) 18.3 实战演练 mkdir -p 命令创建指定路径的父目录以及子目录 touch 命令通常被用来设置或更新文件的访问，更改，和修改时间。如果一个文件名参数是一个不存在的文件，则会创建一个空文件。 1234567891011[me@linuxbox ~]$ mkdir -p playground/dir-&#123;00&#123;1..9&#125;,0&#123;10..99&#125;,100&#125; //创建100个子目录[me@linuxbox ~]$ touch playground/dir-&#123;00&#123;1..9&#125;,0&#123;10..99&#125;,100&#125;/file-&#123;A..Z&#125; //每个目录26个空文件[me@linuxbox ~]$ find playground -type f -name &#x27;file-A&#x27; | wc -l[me@linuxbox ~]$ touch playground/timestamp //创建timestamp将其时间设置当前时间[me@linuxbox ~]$ stat playground/timestamp //查看属性（ls增强版）[me@linuxbox ~]$ touch playground/timestamp[me@linuxbox ~]$ stat playground/timestamp[me@linuxbox ~]$ find playground -type f -name &#x27;file-B&#x27; -exec touch &#x27;&#123;&#125;&#x27; &#x27;;&#x27; //更新所有file-B文件[me@linuxbox ~]$ find playground -type f -newer playground/timestamp //识别所有更新[me@linuxbox ~]$ find playground \\( -type f -not -perm 0600 \\) -or \\( -type d -not -perm 0700 \\)[me@linuxbox ~]$ find playground \\( -type f -not -perm 0600 -exec chmod 0600 &#x27;&#123;&#125;&#x27; &#x27;;&#x27; \\) -or \\( -type d -not -perm 0711 -exec chmod 0700 &#x27;&#123;&#125;&#x27; &#x27;;&#x27; \\) //为所有文件设置新的权限 18.4 find命令选项 19 归档与备份19.1 文件压缩gzip123456gzip foo.txtgzip -tv foo.txt.gz //没有v只验证完整性不输出结果gunzip foo.txt //解压，不用带.gz的后缀名ls -l /etc | gzip &gt; foo.txt.gz //输出直接压缩成文件（加上后缀表名是压缩过的）gunzip -c foo.txt.gz | less //只查看压缩文件的文本内容（注意-c后缀的作用）zcat foo.txt.gz | less //等同于-c的gzip zless 程序共功能等同于管道操作符 bzip2 用法与gzip差不多 扩展名为.bz2 牺牲压缩速度实现了更高的压缩率 二次压缩 二次压缩并不会节省空间，所有压缩技术都涉及额外信息，用来描述压缩过程 尝试压缩不包含任何冗余信息的文件，省下来的空间不足以抵消额外信息使用的空间 19.2 文件归档 文件归档：收集多个文件将其组合成一个大文件(可以同时压缩) tar f选项指定名称，是必须的，“-”不是必须的 v选项获得详细清单 tar命令从归档中提取出来的文件所有权属于执行提取操作的用户，而非原先的用户（超级用户操作除外） tar命令归档、提取都是相对路径 归档tar，归档压缩tgz、tbz 123tar mode[options] pathnametar cf playground.tar playground //为playgorund归档，f选项为指定名称tar tvf playground.tar //列出归档文件的详细内容 通过硬盘把一台电脑系统主目录复制到另一台电脑 1234sudo tar cf /media/BigDisk/home.tar /home //硬盘自动挂载在/media目录下//卸载硬盘接入另一台计算机cd / //提取归档是相对路径，不进入根目录就会出现/home/usr/home...sudo tar xf /media/BigDisk/home.tar 限制提取 12tar xf archive.tar pathname //只提取指定文件，可多指定tar xf ../playground2.tar --wildcards &#x27;home/playground/dir-*/file-A&#x27; //提取所有的fileA，--wildcards加入对通配符的支持 与find配合 1find playground -name &#x27;file-A&#x27; -exec tar rvf playground.tar &#x27;&#123;&#125;&#x27; &#x27;+&#x27; //以追加模式（r）调用tar，将查找到的所有文件添加进来 可以通过find查找更新的文件，创建上一次归档之后出现的那些文件的归档 利用标准输入输出 12find playground -name &#x27;file-A&#x27; | tar cvf - --files-from=- | gzip &gt; playground.tgz //先用find匹配文件列表，通过管道线传给tar，“-”为标准输入输出的惯例，--files-from (也可以写为-T)使其从文件中而不是命令行中读取文件列表，最后传给gzip压缩find playground -name &#x27;file-A&#x27; | tar czf playground.tgz -T - //简化命令，通过z选项指定gzip压缩，j选项可有指定bzip2压缩（文件后缀改为tbz） 通过ssh打包远程主机文件 1ssh remote-sys &#x27;tar cf - Documents&#x27; | tar xf - //在远程主机上执行tar命令，标准输出传到本地主机，本地主机把标准输出提取（x命令） zip zip既能压缩也能归档（gzip、bzip2在linux上才是主流） zip与tar不同之处在于，如果内容已存在（同名），zip是添加新文件并且替换，而tar是直接替换 1234zip options zipfile filezip -r playground.zip playground //不加入递归（-r)则只保留目录不包含内容unzip playground.zip //提取并解压缩unzip -l playground.zip playground/dir-087/file-Z //指定文件-l选项只列出不提取解压缩 zip 的标准输入输出（unzip不接受标准输入） 123find playground -name &quot;file-A&quot; | zip -@ file-A.zip //-@选项将文件名列表传给zipls -l /etc/ | zip ls-etc.zip - //结尾的“-”是标准输入unzip -p ls-etc.zip | less //将unzip结果发送到标准输出 19.3 同步文件与目录 rsync 远程更新协议 这里 source 和 destination 是下列选项之一：• 一个本地文件或目录• 一个远端文件或目录，以 [user@]host:path的形式存在• 一个远端 rsync 服务器，由rsync://[user@]host[:port]/path指定 123rsync options source destinationrsync -av playground foo //playground的所有内容包括自身都同步到foo中（-a表示递归且保留文件属性，-v显示详细）rsync source/ destination //source下的所有文件不包括自身被同步，只复制目录不复制目录本身 硬盘备份 123mkdir /media/BigDisk/backupsudo rsync -av --delete /etc /home /usr/local /media/BigDisk/bcakup //添加--delete选项，用于删除存在于备份设备而原设备不存在的文件// alias backup=&#x27;sudo rsync -av --delete /etc /home /usr/local /media/BigDisk/bcakup&#x27; 定义别名备份更方便 在网络上使用rsync 方法一 12sudo rsync -av --delete --rsh=ssh /etc /home /usr/local remote-sys:/backup//加入--rsh=ssh选项，用于指示rsync用远程shell备份 方法二 20.正则表达式https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md 21. 文本处理","categories":[{"name":"linux / unix","slug":"linux-unix","permalink":"https://wuyifff.github.io/categories/linux-unix/"}],"tags":[]}],"categories":[{"name":"Distributed Systems","slug":"Distributed-Systems","permalink":"https://wuyifff.github.io/categories/Distributed-Systems/"},{"name":"c++","slug":"c","permalink":"https://wuyifff.github.io/categories/c/"},{"name":"linux / unix","slug":"linux-unix","permalink":"https://wuyifff.github.io/categories/linux-unix/"}],"tags":[]}