{"meta":{"title":"wuyifff's blog","subtitle":"hello","description":"this is my blog","author":"wuyifff","url":"https://wuyifff.github.io","root":"/"},"pages":[{"title":"about","date":"2021-10-17T07:55:55.000Z","updated":"2021-10-17T07:55:55.415Z","comments":false,"path":"about/index-1.html","permalink":"https://wuyifff.github.io/about/index-1.html","excerpt":"","text":""},{"title":"about","date":"2021-10-17T07:14:00.000Z","updated":"2021-10-17T07:14:30.016Z","comments":false,"path":"about/index.html","permalink":"https://wuyifff.github.io/about/index.html","excerpt":"","text":"这里写关于页的正文，支持 Markdown, HTML"}],"posts":[{"title":"C++ primer 读书笔记 chapter 7 类","slug":"7.类","date":"2021-10-19T11:02:00.000Z","updated":"2021-10-19T11:06:20.054Z","comments":true,"path":"2021/10/19/7.类/","link":"","permalink":"https://wuyifff.github.io/2021/10/19/7.%E7%B1%BB/","excerpt":"","text":"C++ primer chapter 7类类的基本思想是数据抽象（data abstraction）和封装（encapsulation）。数据抽象是一种依赖于接口（interface）和实现（implementation）分离的编程及设计技术。类的接口包括用户所能执行的操作；类的实现包括类的数据成员、负责接口实现的函数体以及其他私有函数。 定义抽象数据类型使用class或是struct关键字可以定义类类型，struct是为了兼容旧式C风格结构体，对于定义类类型来说，struct和class的唯一区别在于默认访问权限不同。 this指针成员函数通过一个名为this的隐式参数来访问调用它的对象。this是一个常量指针，无法改变this中保存的地址。 const成员函数isbn函数的参数列表后跟随了一个const关键字，这里的const是用来修改隐式this指针的类型。 默认情况下，this类型是指向类类型非常量版本的常量指针。比如Sales_data类成员函数中，this的类型是Sales_data *const。尽管this是隐式的，但它仍然需要遵守初始化规则，这就意味着我们不能把this绑定到一个常量对象上。因此，受这一限制，我们无法在一个常量对象上调用普通的成员函数。 因为this是隐式的，我们没有办法像修饰其他参数一样，去声明其为指向常量的指针，所以C++的语法只好提供实现途径——把const关键字放在成员函数的参数列表之后，此时，this就是一个指向常量的指针，这种const成员函数被叫做常量成员函数。 12345//伪代码，说明隐式this指针是如何使用的//下面的代码非法：我们不能显式地定义自己的this指针//此处的this是一个指向常量的指针，因为isbn是一个常量成员std::string Sales_data::isbn(const Sales_data *const this)&#123;return this-&gt;isbn;&#125; 因为this指向常量，所以常量成员函数不能改变调用它的对象的内容。只读不可写。 外部定义成员函数注意需要加作用域运算符，否则谁知道你定义的是谁的成员。 为了实现连续调用链，可以令成员函数返回this对象本身： 123456Sales_data &amp;Sales_data::combine(const Sales_data &amp;rhs)&#123; units_sold += rhs.units_sold; revenue += rhs.revenue; return *this; // 返回调用该函数的对象&#125; 辅助函数类的作者往往还需要定义一些辅助函数，这些函数不作为类的成员函数，但也作为类的接口的一部分。 12345678910111213istream &amp;read(istream &amp;is, Sales_data &amp;item)&#123; double price = 0; is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price; item.revenue = price * item.units_sold; return is;&#125;ostream &amp;print(ostream &amp;os, const Sales_data &amp;item)&#123; os &lt;&lt; item.isbn() &lt;&lt; &quot; &quot; &lt;&lt; item.units_sold &lt;&lt; &quot; &quot; &lt;&lt; item.revenue &lt;&lt; &quot; &quot; &lt; item.avg_price(); return os;&#125; 构造函数每个类都定义了对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫构造函数。构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。 ==构造函数的名字和类名一致，没有返回类型==，构造函数可以重载，不能被声明成const（因为创建一个const对象时，会先调用构造函数，再得到const属性）。 合成的默认构造函数如果类不定义任何构造函数，编译器会提供一个没有任何实参的默认构造函数。编译器创建的构造函数也叫合成的默认构造函数。 合成的默认构造函数完成以下任务： 如果存在类内的初始值，用它来初始化成员。 否则，默认初始化该成员。 一旦定义了一个构造函数，那么编译器不再合成默认构造函数，即使我们定义的构造函数并不是没有参数的默认构造函数。 123456789struct Sales_data&#123; Sales_data() = default; Sales_data(const std::string &amp;s):bookNo(s)&#123;&#125; Sales_data(const std::string &amp;s, unsigned n, double p):bookNo(s), units_sold(n), revenue(p*n)&#123;&#125; Sales_data(std::istream &amp;); std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;&#125;; =default是C11引入的， 用于显式要求编译器合成默认构造函数（因为定义了其他构造函数，编译器不会自动合成默认构造函数，但我们又想要编译器提供的默认构造函数，所以这是一种偷懒的语法糖）。 =default可以出现在类的内部，也可以出现在外部，内部意味着inline。 紧跟在构造函数参数列表之后在花括号之前的部分是初始值列表。它负责为新创建的对象的一个或几个数据成员赋初值。被忽略的成员则将以合成默认构造函数相同的方式隐式初始化。 C++的编译器并不都支持类内初始值。为了可移植性，最好用初始值列表。 拷贝、赋值和析构除了构造函数以外，类还有3个特殊的成员函数：拷贝构造、赋值操作和析构。 拷贝构造会在拷贝初始化变量和值传递方式传递或返回一个对象时被调用。 赋值操作则在对类对象使用赋值运算符时会被调用。 而析构函数则在对象被销毁时被调用。 与构造函数类似，如果不去定义这3个成员，编译器也会默认合成。关于这一议题，后面第13章会单独讲解。 访问控制与封装C++用访问说明符加强了类的封装性： 定义在public说明符之后的成员在整个程序内都可以被访问，public成员定义类的接口。 定义在private说明符之后的成员仅可以被类的内部成员函数访问，外部代码无法访问，private封装了类的实现细节。 struct的默认访问权限是public，class的默认访问权限是private。 友元加上了权限之后，一些外部接口函数就无法访问类的private成员，这种情况要么提供public接口，要么就使用友元。 123456class Sales_data&#123; friend Sales_data add(const Sales_data&amp;, const Sales_data&amp;); friend std::istream &amp;read(std::istream&amp;, Sales_data&amp;); friend std::ostream &amp;print(std::ostream&amp;, const Sales_data&amp;); ...&#125; friend关键字用于表示这三个函数是类Sales_data的友元函数，如此这三个函数可以访问类的private成员。friend相当于白名单，除了友元函数以外，还可以定义友元类。 12345class Screen&#123; // Window_mgr的成员可以访问Screen类的private成员 friend class Window_mgr; ...&#125; 每个类负责控制自己的友元类和友元函数。 有时候整个类作为友元比较冒险，可以只对类的几个成员函数声明为友元： 12345class Screen&#123; // Window_mgr::clear必须在Screen类之前被声明 friend void Window_mgr::clear(ScreenIndex); ...&#125; 但是要注意声明的前后关系 类的其他特性在外部定义的成员函数也可以通过inline关键字来显式内联。 成员函数也是可以重载的。 可变数据成员使用关键字mutable可以声明可变数据成员（mutable data member）。可变数据成员永远不会是const的，即使它在const对象内。因此const成员函数可以修改可变成员的值。 12345678910111213class Screen &#123;public: void some_member() const;private: mutable size_t access_ctr; // may change even in a const object // other members as before&#125;;void Screen::some_member() const&#123; ++access_ctr; // keep a count of the calls to any member function // whatever other work this member needs to do&#125; 类内初始值花括号初始化类内初始值除了=初始化形式以外，还可以用花括号形式（C++11）： （对screens对象列表初始化）（类内初始值的两种初始化方式） 12345class Window_mgr&#123;private: //默认情况下，一个Window_mgr包含一个标准尺寸的空白Screen std::vector&lt;Screen&gt; screens&#123;Screen(24, 80, &#x27; &#x27;)&#125;;&#125; 为什么要返回*this12345//返回引用成为左值myScreen.move(4,0).set(&#x27;#&#x27;);//返回的是拷贝,只能改变临时副本Screen temp = myScreen.move(4,0);temp.set(&#x27;#&#x27;) const成员函数以引用形式返回*this，则它的返回类型将是常量引用。 成员函数可以基于const重载12345678910class Screen&#123;public: Screen &amp;display(std::ostream &amp;os) &#123;do_display(os);return *this;&#125; //非常量版本调用do_display时，this指针将隐式的从指向非常量的指针转换成指向常量的指针 const Screen &amp;display(std::ostream &amp;os) const &#123;do_display(os);return *this;&#125;private: void do_display(std::ostream &amp;os) const &#123;os &lt;&lt; contents;&#125;&#125;; 因为非常量版本的函数对于常量对象是不可用的，所以只能在常量对象上调用const成员函数。尽管明面上参数列表相同，但实际上隐式的this指针类型是不同的，区别在于是否有底层const。 当我们在对象上调用display()时，该对象是否const决定了应该调用display的哪个版本。 友元 允许特定的非成员函数访问一个类的私有成员. 友元的声明以关键字 friend开始。 friend Sales_data add(const Sales_data&amp;, const Sales_data&amp;);表示非成员函数add可以访问类的非公有成员。 通常将友元声明成组地放在类定义的开始或者结尾。 类之间的友元： 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。 友元不具有传递性 声明重载函数为友元必须指明参数 可以把另一个类的公有成员函数声明为自己的友元函数。 必须按照三步走，很容易出错。（前向声明、不完全类型） 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;class B; //提前引用声明，因为友元A中要用到B，必须让编译器知道B为一个类class A&#123; public: void disp(B &amp;b); //只能声明不能定义，因为类B内部还没有定义&#125;;class B&#123; private: int val; public: friend void A::disp(B &amp;b); //声明友元函数&#125;;//这时候才可以去定义友元函数void A::disp(B &amp;b)&#123; cout&lt;&lt;&quot;B::val=&quot;&lt;&lt;b.val&lt;&lt;endl;&#125; 类的作用域 每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由引用、对象、指针使用成员访问运算符来访问。 函数的返回类型通常在函数名前面，因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。 如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字。 类中的类型名定义都要放在一开始。 构造函数再探构造函数和初始化列表初始值列表提供了成员初始化的机会，如果在构造函数体内对成员进行赋值，那执行的就是赋值操作了（**==区分初始化和赋值==*），对于类类型来说，初始化和赋值操作可能行为不一致。 如果成员是const、引用，或者是某种未定义默认构造函数的类类型，==必须==在初始值列表中将其初始化。（因为const不能用赋值来初始化） 1234567891011class ConstRef&#123;public: ConstRef(int ii);private: int i; const int ci; int &amp;ri;&#125;;ConstRef::ConstRef(int ii): i(ii), ci(ii), ri(i) &#123; &#125; 最好令构造函数初始值的顺序与成员声明的顺序一致，并且尽量避免使用某些成员初始化其他成员。因为类成员的初始化顺序与它们在类定义中出现的顺序一致。 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。 委托构造函数C++11引入了委托构造函数： 123456789101112class Sales_data&#123;public: //非委托构造函数使用对应实参初始化成员 Sales_data(std:string s, unsigned cnt, double price):bookNo(s), units_sold(cnt), revenue(cnt*price)&#123;&#125; //该构造函数函数体为空 //其余构造函数全都委托给另一个构造函数 Sales_data():Sales_data(&quot;&quot;, 0, 0)&#123;&#125; //默认构造函数委托给第一个constructor Sales_data(std::string s):Sales_data(s, 0, 0)&#123;&#125; Sales_data(std::istream &amp;is):Sales_data()&#123;read(is, *this);&#125; //委托给默认构造函数，默认构造函数委托给第一个constructor ...&#125;; 当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数值被依次执行，然后控制权才会交还给委托者的函数体（例子中恰好函数体为空）。 默认构造函数的作用默认初始化的发生情况： 在块作用域内不使用初始值定义非静态变量或数组。 类本身含有类类型的成员且使用合成默认构造函数。 类类型的成员没有在构造函数初始值列表中显式初始化。 值初始化的发生情况： 数组初始化时提供的初始值数量少于数组大小。 不使用初始值定义局部静态变量。 通过T()形式（T为类型）的表达式显式地请求值初始化。 类必须包含一个默认构造函数以便在上述情况下使用。 隐式的类类型转换如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制（从构造函数的参数类型向类类型隐式转换）。这种构造函数被称为转换构造函数（converting constructor）。 1234string null_book = &quot;9-999-99999-9&quot;;// 构造一个临时的Sales_data对象// 该对象的units_sold和revenue等于0，bookNo等于null_bookitem.combine(null_book); 类类型转换只允许一步，这意味着： 1234//错误，需要两次转换item.combine(&quot;9-999-99999-9&quot;);//正确，显式转换为string，隐式转为Sales_dataitem.combine(string(&quot;9-999-99999-9&quot;)); 只有一个参数的构造函数，或者构造函数有n个参数，但有n-1个参数提供了默认值，这样的情况才能进行类型转换。 如果构造函数声明为explicit，就可以抑制隐式的类类型转换。同样的，需要多个实参的构造函数不能执行隐式转换，所以无须将这些构造函数指定为explicit的。 explicit关键字只允许出现在类内的构造函数声明处，不允许在类外部定义函数时重复。 c++的初始化类型 初始化类型 举例 默认初始化 例如T t; 直接（非列表）初始化 例如T t(args...); 复制（非列表）初始化 例如T t = init;） 直接列表初始化 例如T t&#123; args... &#125;; 复制列表初始化 例如T t = &#123; args... &#125;; 为什么C++的初始化规则这么复杂？ - d41d8c的回答 - 知乎 类的静态成员使用关键字static可以声明类的静态成员。静态成员可以是public的或是private的，类型可以是常量、引用、指针类类型等。静态成员存在于任何对象之外，对象中不包含与静态成员相关的数据。 12345678910111213class Account&#123;public: void calculate() &#123; amount += amount * interestRate; &#125; static double rate() &#123; return interestRate; &#125; static void rate(double); private: std::string owner; double amount; static double interestRate; static double initRate();&#125;; 静态成员实际上是全局变量，只不过通过语法的封装，让他和所属类建立了耦合的关系。 每个static数据成员是与类关联的对象，并不与该类的对象相关联。 由于静态成员不与任何对象绑定，因此静态成员函数不能声明为const，也不能在静态成员函数内使用this指针。 用户代码可以使用作用域运算符访问静态成员，也可以通过类对象、引用或指针访问。类的成员函数可以直接访问静态成员。 1234567891011121314151617181920class Account&#123;public: //成员函数无需作用域运算符即可使用静态成员 void calculate()&#123;amount += amount * interestRate;&#125; static double rate()&#123;return interestRate;&#125; static void rate(double);private: std::string owner; double amount; static double interestRate; static double initRate();&#125;;double r;r = Account::rate(); //用户代码可以使用作用域运算符访问静态成员//可以通过类对象、引用或指针访问Account ac1;Account *ac2 = &amp;ac1;r = ac1.rate();r = ac2-&gt;rate(); 在类外部定义静态成员时，不能重复static关键字，其只能用于类内部的声明语句。（在类外部定义时不用加static） 由于静态数据成员不属于类的任何一个对象，因此它们并不是在创建类对象时被定义的。通常情况下，不应该在类内部初始化静态成员。而必须在类外部定义并初始化每个静态成员。一个静态成员只能被定义一次。一旦它被定义，就会一直存在于程序的整个生命周期中。 想要保证对象只被定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一个文件中 如果一定要在类内部定义，则要求必须是字面值常量类型的constexpr","categories":[],"tags":[]},{"title":"UNIX环境高级编程 阅读笔记","slug":"apue","date":"2021-10-17T07:22:38.472Z","updated":"2021-10-17T07:38:39.541Z","comments":true,"path":"2021/10/17/apue/","link":"","permalink":"https://wuyifff.github.io/2021/10/17/apue/","excerpt":"","text":"0.tips输入输出问题 在linux系统下使用printf发现有时没有立即输出，有时又能立即输出 原因是printf使用行缓冲，没有刷新缓冲区，故没有输出。 缓冲区刷新的条件：1.进程结束。2.遇到\\n。3.缓冲区满。4.手动刷新缓冲区fflush(stdout)。 一些有用的函数&lt;stdlib.h&gt; atoi(str) 用法：将字符串里的数字字符转化为整形数。返回整形值。 注意：转化时跳过前面的空格字符，直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(’/0’)才结束转换，并将结果返回。 用于转化argv[]的参数 小知识 C/C++规定，一个数如果要指明它采用八进制，必须在它前面加上一个0（数字0），如：123是十进制，但0123则表示采用八进制。这就是八进制数在C、C++中的表达方法。（很多宏的掩码就是八进制与） 1.基础1.1what is os1.1.1内核 进程线程管理 进程管理主要为linux，windows只是壳子 内存管理 设备驱动 windows .sys文件 linux .ko文件 文件系统 中断子系统 1.1.2内核/用户态 ring0/ring3 环0内核态，环3用户态 ring1/ring2暂时没用到 系统调用 内核为应用程序提供的接口 用户态-&gt;内核态 体系结构 shell sh/bash/csh/ksh 库函数 库函数到系统调用 1.2登录1.2.1 tty/psedo-ttyTTY是电传打字机Teletypewriter的缩写，在带显示屏的视频终端出现之前，TTY是最流行的终端设备 1.2.2 /etc/password 密码可以在etc/password看到 shadow文件 起始目录 用户id 组id shell 1.3 文件1.3.1 一切皆为文件 目录 文本文件/二进制文件一视同仁 设备文件：字符设备、块设备、网络设备（在/dev下ll看第一位） socket linux与windows不同 管道、消息队列等 1.3.2 相对路径/绝对路径 / .. . 1.4 I/O 文件描述符fd stdin/stdout/stderr 对应0/1/2 1.5 进程 进程与程序的关系 进程id windows下为4的倍数（复用原因） linux下用ps命令查看 进程控制 fork 子进程都是由父进程fork出来的（写时复制） exec fork之后调用，类似windows的winexecute api waitpid 1.6 出错处理 errno windows下有geterrornumber strerror 1.7信号可以理解为用户层的中断，异步打断执行流 信号的处理 系统默认处理： 忽略/中止进程 为指定信号注册处理函数 是Linux编程重点，也容易踩坑 1.8 时间日历时间UTC time-t 进程时间clock_t 用户CPU时间 系统CPU时间 2.UNIX标准2.1 标准ISO C组成 语法、语义 标准库 ISO C历史 ANSI C89 C99 restrict long long 单行注释 分散代码与声明 C11 POSIX标准 提升各种应用程序在各种UNIX系统环境间的可移植性 只定义接口而非实现 SUS(single UNIX specification) POSIX的超集 扩展了功能 2.2 实现 FreeBSD Linux Mac OS X Solaris 2.3限制编译时限制 ISO C limits.h 各种最大最小值(宏内定义了，include直接用) float.h 浮点数相关 stdio.h POSIX 限制 运行时限制只有运行时才能拿到，例如系统调用给出 sysconf pathconf/fpathconf 3. 无缓冲I/O（文件IO）3.1 文件描述符fd 所有打开文件都由fd引用，fd为非负int（出错时为负） 类似windows的HANDLE STDIN_FILENO STDOUT_FILENO STDERR_FILENO OPEN_MAX（文件打开的极限值） 进程各自维护自己的文件描述符表，文件描述符表记录文件描述符标志，和一个指向文件表项的指针 文件表项由内核为每一个打开的文件维护，包括文件状态标志、当前文件偏移、以及指向v结点的指针 ==不同进程打开同一个文件、同一进程调用多次open同一个文件==并不共享file table entry（文件表项） 因为各自的偏移可能不同，也可以理解为调用一次open打开一个文件表项，而复制fd与之无关 但是fork出来的子进程的fd指向同一个文件表项（因为文件描述符表也copy，p397） /dev/fd /prof/self/fd 3.2 APIopen/openat/create oflag 文件状态标志 O_RDONLY O_WRONLY O_RDWR 必须指定且互斥 O_APPEND O_CLOEXEC O_CREAT O_DIRECTORY O_EXCL O_SYNC O_DSYNC O_TRUNC O_CREAT | O_EXCL 配合测试创建文件的原子性 openat的path可以为相对路径 creat只写创建，想要创建写之后再读必须close之后再open，用open实现： open(path, O_RDWR | O_CREAT | O_TRUNC, mode) close 会关闭记录锁 进程终止，内核会自动关闭文件对象 RAII的思想 lseek 当前文件偏移量 文件空洞 read 返回值 &lt; 待读字节数的情景 eof 终端设备/行缓冲 管道/FIFO 中断 write 返回值 &lt; 待写字节数的情景 磁盘满 超过了给定进程的文件长度限制 pread/pwrite原子lseek + read/write dup/dup2 新描述符的FD_CLOEXEC总是被清除 （即fd flag） dup(fd) = fcntl(fd, F_DUPFD, 0); dup2(fd) = close(fd2); fcntl(fd, F_DUPFD, fd2); //且为原子操作 dup 和 fcntl 的 errno 不同 sync/fsync/fdatasync 内核维护高速缓存 延迟写 update守护进程周期性调用sync fcntl（重点）#include&lt;fcntl.h&gt; int fcntl(int fd, int cmd, … ); 复制一个已有的描述符 F_DUPFD/F_DUPFD_CLOEXEC 获取/设置文件描述符标志**(fd flag)** F_GETFD/F_SETFD 仅有的就是FD_CLOEXEC标志 fcntl(fd, F_SETFD, 1); 默认为0，即不关闭 获取/设置文件状态标志 F_GETFL/F_SETFL ==注意GETFL与GETFD的区别== 获取/设置异步I/O所有权 F_GETOWN/F_SETOWN 获取/设置记录锁 F_GETLK/F_SETLK/F_SETLKW ioctl 设备驱动 某个特定操作的接口 类比于windows的 DeviceControl 应用程序到设备驱动的万用接口 4. 文件和目录4.1 struct statPOSIX标准 + XSI扩展定义的字段 描述一个特定文件相关的信息 linux下的struct stat st_mode 文件类型 文件类型 宏 普通文件 regular file S_ISREG() 目录文件 directory file S_ISDIR() 符号链接 symbolic link S_ISLINK() 块特殊文件 block special file S_ISCHR() 字符特殊文件 character special file S_ISBLK() FIFO 命名管道 S_ISFIFO() socket S_ISSOCK() 消息队列 S_TYPEISMQ() 信号量 S_TYPEISEM() 共享内存 S_TYPEISSHM() mode set-user-id bit S_ISUID set-group-id bit S_ISGID 进程关联ID： 实际用户/组ID 有效用户/组ID 附属组ID 文件和目录的权限位 S_ISUID：执行时设置用户ID S_ISGID：执行时设置组ID S_ISVTX：粘着位 S_IRWXU：用户读、写和执行 S_IRUSR：用户读 S_IWUSR：用户写 S_IXUSR：用户执行 S_IRWXG：组读、写和执行 S_IRGRP：用户读 S_IWGRP：用户写 S_IXGRP：用户执行 S_IRWXO：其他读、写和执行 S_IROTH：用户读 S_IWOTH：用户写 S_IXOTH：用户执行 鉴权流程 4.2 文件系统VFS superblock incode 与文件一一对应，相当于身份证号 包含文件的元数据，不包含名称 内存中的inode和磁盘中的inode 名称-&gt;inode-&gt;disk block dentry 文件的逻辑属性 一个dentry对应一个inode 多个dentry可能对应一个inode(硬链接/软链接) file object 4.3 API状态相关 stat / fstat / statat / lstat ls - l命令 注意是否跟踪符号链接 权限相关 access / faccessat 探测文件是否存在 以实际用户ID和实际组ID测试访问能力 faccessat提供了 AT_EACCESS 和 AT_SYMLINK_NOFOLLOW umask 创建新目录或文件时，屏蔽字中置1的权限都会被关闭 区分umask命令 chmod / fchmod / fchmodat S_ISUID / S_ISGID S_IRWXU / S_IRWXG / S_IRWXO S_ISVTX(粘着位在linux无效) chown / fchown / fchownat / lchown chown命令 注意符号链接的处理 变更相关 truncate / ftruncate 截断/扩充 link / linkat unlink / unlinkat 用于确保临时文件被删除 标准库的remove rename / renameat oldname 非目录 newname存在 newname不存在 oldname 为目录 newname 存在 newname 不存在 符号链接 . 和 .. 不允许 symlink / symlinkat readlink / readlinkat open的局限：不能打开link本身 mkdir / mkdirat rmdir 控制相关 opendir / fopendir readdir / rewinddir / closedir / telldir / seekdir 类比文件/标准I/O的接口 chdir / fchdir getcwd 时间相关 futimens utimensat utimes 5.标准I/O即ISO C标准I/O 5.1 流 (stream) 无缓冲I/O围绕fd展开 有缓冲I/O围绕stream展开 流的定向(stream’s orientation) 单字节 字节定向 byte flow ASCII 多字节 宽定向 wide bytes flow 国际字符集 进程预定义流 stdin / stdout /stderr 流缓冲 意义 类型 全缓冲：填满I/O缓冲区后才进行实际I/O操作 行缓冲： 输入输出遇到换行符时执行I/O操作 2. 由于每行缓冲区固定，缓冲区满没有遇到换行符也要执行I/O 3. 任何时候只要通过标准lO库，要求从一个不带缓冲的流或者一个行缓冲的流(从内核请求数据的时机）得到输入数据，那么就会冲洗所有行缓冲输出流。(即要缓冲输入，先冲洗输出缓冲) 4. 指向终端的流通常使用行缓冲 不带缓冲：不进行缓冲 stdin 和 stdout 并不指向交互设备时，才能使全缓冲类型 (通过重定向) 如果指向终端设备，则是行缓冲的，否则是全缓冲的 stderr绝不能时全缓冲的，一般是不带缓冲 表现为buffersize = 1 5.2 FILE对象 不同平台的实现不同 linux fd 用于实际I/O buffer指针 buffer尺寸 buffer当前字符数 出错标志 文件结束标志 5.3 API fwide setbuf / setvbuf p118 fflush fopen / freopen / fdopen fclose 读写 getc / fgetc / getchar / ungetc putc / fputc / putchar fgets / (gets) fputs / (puts) fread / fwrite ferror / feof / clearerr ftell / ftello / fseek / fseeko / rewind fgetpos / fsetpos 格式化输入输出 printf / fprintf / dprintf / sprintf / snprintf scanf / fscanf / sscanf fileno 标准I/O到无缓冲I/O的adapter tmpnam / tmpfile 临时文件 fmemopen 内存流 6. 系统信息6.1 数据文件 /etc/passwd pwd.h中定义了struct passwd结构 可以任意由用户读取 是ASCII文件，可以用标准I/O读取，但是效率太低 因此系统提供API接口 /etc/group grp.h中定义了struct group结构 /etc/shadow 经单向加密算法处理过的用户口令副本 shadow.h中定义了struct spwd 阴影口令文件 /etc/shadow 不应该由一般用户读取 仅有少数几个程序需要访问加密口令,如login, passwd, 这些程序通常是设定 set-user-ID为root的程序 6.2 API6.2.1 数据文件 getpwuid / getpwnam getpwent / setpwent / endpwent getspnam / getspent / setspent / endspent getgrgid / getgenam getgrent / setgrent / endgrent getgroups / setgroups / initgroups 返回的结构都是一个静态变量，会覆盖前一次的结果，数据文件的API都提供了 get / set / end 组合技 6.2.2 系统信息 uname struct utsname gethostname time 日历时间 clock_gettime 获取指定的时钟类型的时间 实时系统时间 不带负跳数的实时系统时间 调用进程的CPU时间 调用线程的CPU时间 clock_getres 时间精度调整 clock_settime 对特定的时钟设置时间（某些需要权限） gettimeofday (deprecate) gmtime / localtime 日历时间转换为struct tm 结构 mktime strftime / strftime_l 格式化时间，打印字符串 strptime 7. 进程环境7.1概念1进程终止 从main返回 exit(main(argc, argv)) return 和 exit(0) 并无区别 exit()库函数 _exit / _Exit 系统调用 这两者区别： 不同标准定义 、是否做了清理工作 2 终止处理程序 atexit函数 事先声明，反向调用，类似栈 3 命令行参数 argc argv envp 环境表 全局变量 environ 函数 getenv / putenv 一般调用函数获取环境，而非读取environ 进程地址空间 .text / .data / .bss / stack / heap / others (so , debug , systab ) 4 跨越函数跳转 setjmp / longjmp 靠返回值val与正常函数调用区分 5 进程资源限制 getrlimit / setrlimit 7.2 API exit / _Exit / _exit atexit getenv / putenv / setenv / unsetenv / clearenv setjmp / longjmp 8. 进程控制8.1 概念进程ID 循环复用 特殊的进程ID swapper：0 内核交换进程 init：1 普通用户进程 超级用户特权 所有孤儿进程的父进程 进程的创建一次调用两次返回 父进程中返回创建的子进程ID 子进程返回0 getppid ( get parent id) 获取父进程ID 父子进程谁先执行不确定 子进程是父进程的副本 拷贝数据空间、堆、栈 COW （copy on write）写时复制 试图修改时才真正拷贝 fork + exec 从中受益 代码段共享 （只读） 拷贝文件描述符表 继承父进程相关属性 实际用户ID、实际组ID、有效用户ID、有效组ID 附属组ID 进程组ID 会话ID 控制终端 设置用户ID标识和设置组ID标识 当前工作目录 根目录 文件模式创建屏蔽字 信号屏蔽和安排 对任一打开文件描述符的执行时关闭(close-on-exec)标识 环境变量 连接的共享存储段 存储映像 资源限制 父子进程的不同之处 ID / PID 子进程tms_utime/tms_stime/tms_cutime/tms_ustime被清零 子进程不继承父进程文件锁 子进程未处理闹钟将被清除 子进程未处理信号集设置为空集 父子进程的生死交互子进程先于父进程终止 通过信号SIGCHILD发送退出状态给父进程 父进程可以通过wait / waitpid获取信息 子进程ID / 子进程终止状态 / CPU耗时 未善后的终止子进程为僵死进程（zombie） 父进程先于子进程终止 子进程父亲改为init 进程（pid 1） init进程会调用wait善后处理终止的子进程（防止全是zombie） wait / waitpid 如果所有子进程都还在运行，则阻塞 如果一个子进程终止，正等待父进程获取其终止状态，则取得终止状态立即返回（zombie状态也立即返回） 如果没有任何子进程则出错返回 waitpid功能补充 支持异步（需要设置options参数） 可选择性等待某个进程 ​ pid == -1 / 0 / &gt;0 / &lt;-1 更灵活的wait系列函数 exec族函数 更进一步的封装 popen system fork -&gt; exec -&gt; waitpid 权限 实际用户 / 组ID 有效用户 / 组ID setuid / setgid 进程拥有超级权限，二话不说直接改实际用户/组ID、有效用户/组ID为指定ID 如果没有超级权限，但是uid或gid设置为实际用户/组ID或保存的设置用户/组ID， 则只将有效用户/组ID改为指定ID 不满足前两条，通通返回错误(ret = -1, error = EPERM) 解释器文件 解释型语言源文件起始行标注 进程调度 优先级 nice 0~2*NZERO-1 sysconf获取 越大越低 getpriority setpriority 进程时间 时钟时间 用户CPU时间 系统CPU时间 times 8.2 API getpid getppid getuid geteuid getgid getegid fork vfork wait waitpid waitid wait3/wait4 execl execv execle execve execlp execvp fexecve setuid/setgid seteuid/setegid system nice getpriority/setpriority times 9. 进程关系9.1 概念终端 tty1-6 CTRL ALT F1-6 图形终端 ALT F7 pseudo tty（pty） 网络终端 进程组（作业job） 唯一标志ID getpgrp / getpgid setpgid 进程只能为自己和它的子进程设置进程组ID 唯一标志ID和组长的PID一致 多个进程的集合，每个进程都有所属的进程组 同一进程组的所有进程接受同一终端的各种信号 孤儿进程组 每个成员的父亲要么在本组，要么在其他会话中 会话 可以有0或一个控制终端（tty / pseudo tty) 建立与控制终端连接的会话首进程被称为控制进程 无控制终端可能为守护进程 一个到多个进程组的集合 一个前台进程 这意味着会话有一个控制终端 接受 ctrl c / ctrl \\ 产生的 SIGINT / SIGQUIT 信号 n个后台进程组 新建会话 setsid 该进程变成新会话的会话首进程 (session leader) 此时该 leader 是会话中的唯一进程 这意味这要新建会话 要先 fork 再 setsid 这就保证了进程不是进程组的组长 该进程成为一个新进程组的组长进程 新进程组ID是调用进程的进程ID 也是会话ID 该进程没有控制终端 如果调用 setsid 前有控制终端，则切断联系 作业控制 9.2 API getpgrp / getpgid / sepgid setsid / getsid tcgetpgrp / tcsetpgrp / tcgetsid 10. 信号10.1 概念异步事件 信号的产生是不定时的，随机的 可以简单理解为用户态的中断（软中断） 产生信号的方式 用户按键产生（ctrl C） 硬件异常产生 进程或者用户调用kill 但检测到某种软性条件已经发生，通知有关进程 SIGURG / SIGPIPE / SIGALARM / SIGABRT 进程处理信号的方式 忽略 ignore 大多数信号的默认处理方式 SIGKILL / SIGSTOP 不能被忽略 由硬件异常导致的信号最好不要被忽略 中断允许嵌套，但是一般终端过程中同一个中断会忽略 捕捉 catch 注册一个signal handler 信号到来时会打断当前执行流，转而去执行handler 不能捕捉SIGKILL / SIGSTOP 执行默认动作 函数 signal / sigaction 子进程继承了父进程处理信号的方式 被中断的系统调用 低速系统调用 可能会使进程永久阻塞的一类 出错返回 errno EINTR 自动重新启动的系统调用 ioctl read/readv write/writev wait/waitpid 可重入函数 异步信号安全 不可重入的情况 static静态变量 global全局变量 调用了不可重入函数 malloc是线程安全的（递归锁），但是维护共享内存，故是不可重入的 可靠信号 未决的 pending产生信号和送达之间 信号屏蔽字 signal mask （signal procmask） 进程可以阻塞某种信号递送sigpending 保持未决状态 直到进程接触阻塞或设置为忽略才送达 阻塞期间同一个信号触发多次（是否排队：sigqueue） sigsuspend 解除了 使用 sigprocmask 和 pause 组合 的原子性问题 信号集 sigset_t 相关api ： sigemptyset / sigfillset / sigaddset / sigdelset / sigismember 与 sigprocmask 相配合 递送信号 kill / raise 库函数 kill命令 定时器 alarm：SIGALARM 默认动作为终止进程 一个进程只能有一个定时器 睡眠 sleep / nanosleep / clock_nanosleep 进程控制的延申 信号做父子进程的同步 加入信号处理的system实现 非局部跳出（deprecated） sigsetjmp / siglongjmp 对比 setjmp / longjmp handler自动屏蔽某种信号 跳走后无法保存信号屏蔽字 10.2 API signal kill / raise alarm pause sigemptyset / sigfillset / sigaddset / sigdelset / sigismember sigprocmask / sigpending sigsetjmp / siglongjmp sigsuspend 信号屏蔽字被设置为sigmask指向的值然后挂起，在捕捉一个信号之后返回恢复原来的sigmask abort 11. 线程11.1 进程与线程的概念 进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位） 进程有自己的独立地址空间，线程是共享进程的地址空间 线程之间通信更方便，进程则要通过各种IPC机制 多进程更加健壮，一个进程异常挂掉不会导致其他进程挂掉 11.2 多线程与多核 单核也可以多线程 多核多线程可以达成同时run的效果 11.3 pthread标准 POSIX 线程 LinuxThreads的变化（NPTL） 11.4 线程信息以下不共享 线程ID pthread_t / pthread_equal / pthread_self 栈 信号屏蔽字 调度优先级 errno变量 线程私有数据 11.5 线程的生与死线程创建 pthread_create 线程创建不能保证哪个线程会先运行 线程继承调用线程的浮点环境和信号屏蔽字 但是 pending 信号集会被清除 线程终止 导致进程终止 任意线程调用 exit / _exit / _Exit 发送给线程的信号（默认终止进程） 单一线程终止 线程从启动历程返回 pthread_join / pthread_datch 线程被同一进程的其他线程取消 pthread_cancel 线程调用 pthread_exit 线程清理处理程序 pthread_cleanup_push / pthread_cleanup_pop 清理情况： 主动调用 pthread_exit 响应 pthread_cancel 调用 pthread_cleanup_pop 参数不为0的时候 直接 return 并不会执行清理 执行顺序与注册顺序相反 11.6 进程与线程原语 进程原语 线程原语 描述 fork pthread_create 创建新的控制流 exit pthread_exit 从现有的控制流中退出 waitpid pthread_join 从控制流中得到退出状态 atexit pthread_cancel_push 注册在退出控制流时调用的函数 getpid pthread_self 获取控制流的ID abort pthread_cancel 请求控制流的非正常退出 11.7 线程同步、一致性问题原子操作互斥锁 POSIX互斥量 struct pthread_mutex_t 初始化/销毁 pthread_mutex_init / pthread_mutex_destory 上锁 pthread_mutex_lock / pthread_mutex_timedlock / pthread_mutex_trylock / pthread_mutex_unlock 解锁 pthread_mutex_unlock 死锁 AB型死锁 解决方法： 按序获取锁（程序复杂） trylock / timedlock 读写锁(共享互斥锁) 状态 读锁：读请求 pass ，写请求阻塞直到读锁释放（共享锁） 引用计数实现 注意写请求的饥饿情况，通常写请求后的读请求被阻塞（FIFO) 写锁：阻塞任何的加锁请求（互斥锁） 无锁 一次只有一个线程可以占有写锁，可以有多个线程同时占有读锁 适用于读请求&gt;&gt;写请求的情况 POSIX读写锁 初始化 / 销毁 pthread_rwlock_init / pthread_rwlock_destroy 读锁 pthread_rwlock_rdlock / pthread_rwlock_tryrdlock / pthread_rwlock_timedrdlock 写锁 pthread_rwlock_wrlock / pthread_rwlock_trywrlock / pthread_rwlock_timedwrlock 解锁 pthread_rwlock_unlock 条件变量 配合互斥量使用，提供多线程会合的时间点 初始化 / 销毁 pthread_cond_init / pthread_cond_destroy 等待条件变量变为true pthread_cond_wait / pthread_cond_timedwait 条件变量置信 pthread_cond_signal 唤醒一个 / pthread_cond_broadcast 唤醒所有 自旋锁 spinlock 特征：忙等阻塞 锁持有时间段，线程不希望被调度 用户态基本不使用自旋锁 不要调用在持有自旋锁的情况下可能会进入休眠状态的函数 屏障 barrier 协调多个进程并行工作 每个线程等待，直到所有线程共同达到某一点 初始化 / 销毁 pthread_barrier_init / pthread_barrier_destory 等待 pthread_barrier_wait 未满足屏障计数时阻塞 、满足屏障计数时唤醒所有（最后一个线程） 12. 线程控制12.1 属性pthread遵循的对于属性的模式 每个对象都和自己类型的属性对象相关联（互斥量与互斥量属性相关联，线程与线程属性相关联），表现为 attr 指针，每个属性对象可以代表多个属性。属性对应用不透明，便于提高可移植性，因此需要函数来进行管理 每个属性对象有一个初始化函数，它把属性设置为默认值 还有一个销毁属性对象的函数，用于释放与属性对象的资源 获取各个属性值的函数，返回存储它的内存单元 设置属性值的函数，一般来说属性作为参数用指针传递 线程属性 初始化 / 销毁 pthread_attr_init / pthread_attr_destory 线程分离状态属性(分离线程的资源在线程终止时立即收回，无法用 join 等待其终止状态) pthread_attr_getdetachstate / pthread_attr_setdetachstate 以下不建议用 pthread_attr_getguardsize / pthread_attr_setguardsize pthread_attr_getstacksize / pthread_attr_setstacksize pthread_attr_getstack / pthread_attr_setstack 取消状态（取消点）不建议用 PTHREAD_CANCEL_ENABLE / PTHREAD_CANCEL_DISABLE pthread_setcancelstate 被取消线程在调用点会感知到取消 (pthread_cancel调用方不等待) 默认情况延迟取消 同步属性互斥量属性 pthread_mutexattr_t共享属性、健壮属性、类型属性 pthread_mutexattr_init / pthread_mutexattr_destroy 以下不建议使用 进程共享(内核开销大，不属于NPTL) pthread_mutexattr_getpshared / pthread_mutexattr_setpshared 健壮属性 类型属性 pthread_mutexattr_gettype / pthread_mutexattr_settype 互斥量类型 递归上锁 不占用时解锁 已解锁时解锁 PTHREAD_MUTEX_NORMAL 死锁 未定义 未定义 PTHREAD_MUTEX_ERRORCHECK 返回错误 返回错误 返回错误 PTHREAD_MUTEX_RECURSIVE 允许 返回错误 返回错误 PTHREAD_MUTEX_DEFAULT 未定义 未定义 未定义 递归锁的使用场景 读写锁属性 pthread_rwlockattr_t pthread_rwlockattr_init / pthread_rwlockattr_destroy pthread_rwlockattr_getpshared / pthread_rwlockattr_setpshared 条件变量属性 pthread_condattr_t pthread_condattr_init / pthread_condattr_destroy pthread_condattr_getpshared / pthread_condattr_setpshared 屏障属性 pthread_barrierattr_t pthread_barrierattr_init / pthread_barrierattr_destroy pthread_barrierattr_getpshared / pthread_barrierattr_setpshared 12.2 重入概念 如果一个函数对多个线程来说时可重入的，就说这个函数是线程安全的。但并不能说明对信号处理程序来说该函数也是可重入的。 如果函数对于异步信号处理程序的重入是安全的，那么可以说函数是异步信号安全的 重入的要求高于线程安全 可重入要求信号安全 一般来说： 如果一个函数的实现使用了全局或者静态变量，且访问未加锁，那么这个函数既不是可重入的，也不是线程安全的。 如果放宽条件，这个函数仍然用到了全局或者静态变量，但是在访问这些变量时，通过加锁来保证互斥访问，那么这个函数就可以变成线程安全的函数。但它此时仍然是不可重入的，因为通常加锁是针对不同线程的访问，对同一线程可能出现问题（发生信号软中断，signal handler中恰巧也执行了该函数）。 非线程安全函数 替代的线程安全函数 12.3 线程私有数据 由于线程共享地址空间，故线程无法阻止另一个线程访问其私有数据 因此需要管理线程特定数据的函数（设计上封装隔离） pthread_key_create / pthread_key_delete 让不同线程看到同一个键值 pthread_once pthread_once_t = PTHREAD_ONCE_INIT 1234567891011121314void destructor(void *);pthread_key_t key;pthread_once_t init_done = PTHREAD_ONCE_INIT;voidthread_init(Void)&#123; err = pthread_key_create(&amp;key, destructor);&#125;intthreadfunc(void *arg)&#123; pthread_once(&amp;init_done, thread_init); ...&#125; 关联键和私有数据 pthread_getspecific / pthread_setspecific 12.4 线程和信号 线程都有自己的信号屏蔽字 线程的处理是进程中所有线程共享的 信号是传递给单个线程的 信号与硬件相关，递送给引起时间的进程 其他信号发送给任意一个进程 pthread_sigmask sigprocmask在多线程环境中行为未定义 用法类似sigprocmask sigwait等待信号出现 先阻塞等待的信号（在外部） 原子取消信号集阻塞状态 信号递送后返回 返回前恢复阻塞信号集 类比条件变量和互斥量 多个线程等待同一信号，只有一个会被唤醒 pthread_kill 给指定进程发送信号 线程与I/O lseek read 多线程有问题 pread lseek read 的原子操作 12.5 API pthread_attr_init / pthread_attr_destroy pthread_attr_getdetachstate / pthread_attr_setdetachstate pthread_key_create pthread_mutexattr_init / pthread_mutexattr_destroy pthread_mutexattr_gettype / pthread_mutexattr_settype pthread_key_create / pthread_key_delete pthread_getspecific / pthread_setspecific pthread_sigmask pthread_sigkill 13. 守护进程13.1 概念守护进程的概念 内核态守护进程（内核线程） eg： 虚拟内存换页kswapd / 脏页面冲刷 flush 用户态守护进程 由 init 拉起 setsid 使其一般是会话首进程，同时也是进程组组长、唯一进程 编写守护进程的惯例 umask 设置文件模式创建屏蔽字 通常 umask(0) 父进程 fork 并 exit 为子进程 setsid 创建会话创造条件 setsid 会话首进程 / 进程组组长 / 没有控制终端 当前工作目录改为根目录或者其他位置 chdir(“/“) 防挂在umount 关闭不用的文件描述符 首先 getrlimit 判定最高文件描述符的值，然后用循环全部关闭 打开 /dev/null 使具有文件描述符0、1、2 因为守护进程并不与终端设备相关联，无从显示也无需输入 fd0 = open(“/dev/null”, O_RDWR); 一般还需要处理 SIGHUP 信号 原因：孤儿进程 出错记录 内核例程调用log函数 用户守护进程调用 syslog 函数 本地或其他主机可通过 UDP 514端口传递log rsyslog 单例守护进程 文件记录锁 记录锁 惯例 锁通常指定在 /var/run/%name%.pid 内容一般就是pid号 配置文件通常在 /etc/%name%.conf 守护进程一般通过初始化脚本之一启动 /etc/rc* /etc/init.d/* /etc/inittab启动自动重启 一般注册 SIGHUP 处理程序 一方面使为了防止默认动作终止 功能上设置为重新读取配置 13.2 API openlog / syslog / closelog / setlog / mask vsyslog 14 进阶I/O14.1 非阻塞I/O 低速系统调用 定义：会引起进程永久阻塞 某些文件类型数据不存在，读引起永久阻塞 数据不能被相同的文件类型接受，写操作会永久阻塞 对加了记录锁的文件读写 ioctl 进程通信函数 open 先天指定 O_NONBLOCK fcntl 后天设置 O_NONBLOCK 轮询 polling + 非阻塞I/O 类似用户态的自旋锁 浪费cpu时间 多线程 + 阻塞I/O 额外的线程开销、同步开销 14.2 记录锁 recording lock 确保进程单独写文件 进程读或写文件的某个部分时，使用记录锁组织其他进程修改同一文件区 byte range locking fcntl 记录锁 struct flock 1234567struct flock&#123; short l_type; short l_whence; off_t l_start; off_t l_len; pid_t l_pid;&#125; l_type : F_GETLK / F_SETLK / F_SETLKW F_GETLK 检测上锁后上锁不是原子操作 F_SETLKW 检测到死锁后杀死另一个进程获得资源 锁的隐含继承与释放 进程终止时，建立的所有锁全部释放 关联的fd何时关闭，锁都会释放 fork 子进程只能继承文件描述符，不能继承它的锁 文件尾端加锁 建议性锁和强制性锁 14.3 异步I/O不建议用 14.4 I/O多路转接(multiplexing)问题提出 阻塞模式下在多个fd上写，一个block会导致后面的pending polling + 无阻塞可以解决 异步I/O 用信号通知 缺点在于不知道哪个fd ready（不够映射） I/O多路复用 select select / pselect pselect 支持 timespec 结构，更精确的时间 最多支持fd 有上限 poll 通过数组表明关心的条件 解决了fd数量的瓶颈 epoll linux I/O多路转接的最优机制 性能高 规避了所有fd的用户态 copy 到内核态的开销 fd常驻内核 内核以红黑树组织 内核态只回传ready 部分的fd 边沿触发 14.5 其他readv / writev 散布读(scatter read) / 聚集写(gather write) iovec 结构数组 1234struct iovec&#123; void *iov_base; size_t iov_len&#125; 降低系统调用的次数，获取性能 readn / writen apue 对 read / write 的一些容错封装 原因： 管道、FIFO、网络、终端 可能读的字节数小于指定数量 写可能因为内核缓冲区满而失效 mmap / munmap 存储映射I/O 磁盘文件映射到内存空间 直接读写内存就是修改磁盘文件 mprotect 修改映射区权限 msync 立刻同步刷新","categories":[],"tags":[]},{"title":"Linux Cammand Line 阅读笔记","slug":"linux命令行","date":"2021-10-17T07:22:38.467Z","updated":"2021-10-17T07:39:51.329Z","comments":true,"path":"2021/10/17/linux命令行/","link":"","permalink":"https://wuyifff.github.io/2021/10/17/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/","excerpt":"","text":"1.引言 人们说，“图形用户界面让简单的任务更容易完成，而命令行界面使 完成复杂的任务成为可能”，到现在这句话仍然很正确。 2.什么是shell2.1终端仿真器shell 就是一个程序，它接受从键盘输入的命令，然后 把命令传递给操作系统去执行 当使用图形用户界面时，我们需要另一个和 shell 交互的叫做终端仿真器的程序。 2.2第一次按键用户名 @ 主机 名，紧接着当前工作目录和一个美元符号 如果提示符的最后一个字符是“#”, 而不是“$”, 那么这个终端会话就有超级用户权限。 这意味着，我们或者是以 root 用户的身份登录，或者是我们选择的终端仿真器提供超级用户 （管理员）权限。 2.3命令历史默认保存500 上箭头得到上一次命令 按下鼠标左键拖动快速复制，鼠标中键粘贴==不要用ctrl c== 设置聚焦跟随鼠标代替单机聚焦，可以使复制粘贴更方便 2.4简单命令12345datecal //显示月历df //显示磁盘剩余空间free //空闲内存exit //终止会话 2.5幕后控制台 按下 Ctrl-Alt-F1 到 Ctrl-Alt-F6 访问 当一个会话被访问的时候，它会显示登录提示框，我们需要输入用户名和密码。 要从一 个虚拟控制台转换到另一个，按下 Alt 和 F1-F6(中的一个)。返回图形桌面，按下 Alt-F7 3.文件系统中跳转3.1文件系统树 分层目录结构组织文件，所有文件组成一颗树型目录，倒置的树 总是只有一个单一的文件系统树，不管存储设备的连接（不像 Windows ，每个存储设备都有一个独自的文件系统） 3.2当前工作目录123pwd //print working directory显示当前目录ls //列出一个目录包含的文件以及子目录ls -a 当我们首次登录系统（或者启动终端仿真器会话）后，当前工作目录是我们的家目录。每个d用户都有他自己的家目录，当用户以普通用户的身份操控系统时，家目录是唯一允许用户写入文件的地方。 以 “.” 字符开头的文件名是隐藏文件，用ls -a命令 3.4更改当前工作目录123cd /usr/bin //绝对路径cd .. //相对路径回到usrcd ./bin //相对路径进入bin也可以直接cd bin 绝对路径从根目录开始，直到它的目的地，而相对路径开始于工作目录 符号 “.” 指的是工作目录，”..” 指的是工作目录的父目录 ==./是隐含的可以省略== 文件名和命令名是大小写敏感的 文件没有拓展名，文件名可能包含空格，标点符号，但标点符号仅限 使用“.”，“－”，下划线，但是不要使用空格 4.探究操作系统4.1ls123ls /usr //指定别的目录ls ~ /usr //指定多个目录（家目录和usr目录ls -l //以长模式输出 家目录用**~**代表 4.2选项和参数 大多数命令使用的选项，是由一个中划线加上一个字符组成，例如，“-l”，但是许多命令， 包括来自于 GNU 项目的命令，也支持长选项，长选项由两个中划线加上一个字组成。 4.3长格式输出 4.4确定文件类型1file filename //file命令打印文件内容的简单描述 4.5用less浏览文件内容 系统配置文件以文本格式储存 12less filenameless /etc/passwd 按下q键退出less程序 4.6浏览文件目录文件概览 5.操作文件和目录5.1通配符1ls /usr/bin/t* 5.2mkdir创建目录12mkdir directory... //三个点表示参数可重复mkdir dir1 dir2 dir3 5.3cp复制文件或目录12cp item1 item2 //复制单个文件或目录item1到item2cp item... directory //复制多个项目到一个目录下 5.4mv移动和重命名文件12mv item1 item2mv item... directory 5.5rm删除文件和目录1rm item... 5.6ln创建链接12ln file link //创建硬链接ln -s item link //创建符号链接 5.7硬链接 一个硬链接不能关联它所在文件系统之外的文件。 一个硬链接不能关联一个目录。 5.8符号链接（软链接/symlink） 类似于windows的快捷方式，其本身与其他符号链接几乎没有区别 向符号链接写入，写入相关联的文件，删除符号链接不会删除文件自身 坏链接为红色 5.9 playground练习（很重要） cp命令至少两个地址(本地用.) cp -v 看详细做了什么， -i 获得提示 mv要么两个地址（移动），要么改名字 ln创建链接 -s符号链接 跟文件和目录 ls -li 可以看到文件索引结点 创建符号链接可以绝对路径也可以相对路径 6.使用命令6.1命令四种形式 可执行程序，编程语言或脚本语言写成 内建于shell自身的命令,内建命令 shell函数，即小规模shell脚本，混合到环境变量中 命令别名，自定义命令建立在其他命令之上 6.2 type显示命令的类型12type typetype ls 6.3 显示一个可执行程序的位置1which ls 这个命令只对可执行程序有效，不包括内建命令和命令别名，别名是真正的可执行程序的替代物 6.4 help得到shell内建命令的帮助文档12help cdmkdir --help –help显示用法信息 6.5 man显示程序手册页1man ls man使用less显示参考手册，可以使用less命令进行浏览 man参考手册分成的章节： 1man 5 passwd 如果不成功显示No manual entry for passwd in section 5 则需要yum install man-pages 6.6 apropos显示适当的命令12apropos floppyman -k floppy //功能同上 输出结果每行的第一个字段是手册页的名字，第二个字段展示章节 6.7 whatis显示简洁的命令说明1whatis 命令/系统调用/库函数/特殊文件名 相当于man -f 6.8 info显示程序info条目1info ls info 文件是树型结构,包含超链接，可以从*号处跳转到另一个结点 6.9 README以及其他程序文档 许多安装在你系统中的软件，都有自己的文档文件，这些文件位于/usr/share/doc 目录下。大多数是以文本文件的形式存储的，可用 less 阅读器来浏览。 以 “.gz” 结尾的文件表示 gzip压缩程序已经压缩了这些文件。gzip软件包包括一个特殊的 less 版本，叫做 zless，zless 可以显示由 gzip 压缩 的文本文件的内容。 6.10用别名（alias）创建命令1234alias foo=&#x27;cd /usr; ls; cd -&#x27;alias name=&#x27;string&#x27; //格式type foounalias foo //删除别名 在命令 “alias” 之后，输入“name”，紧接着（**没有空格 **）是一个等号，等号之后是一串用引 号引起的字符串，字符串的内容要赋值给 name。 通常经常使用的命令带有普遍用到的选项，例如 ls is aliased to `ls –color=auto’，使用不带参数的alias查看默认定义的别名 ==在命令行中定义别名有点儿小问题。当你的 shell 会话结束时，它们会消失。== 7.I/O重定向7.1标准输入输出和错误 默认情况下，标准输出stdout和标准错误都连接屏幕而不是磁盘文件。 标准输入stdin默认情况下连接键盘 I/O重定向允许我们更改输出地点和输入来源 7.2标准输出重定向 用 &gt; 重定向符接文件名 12ls -l /usr/bin &gt; ls-output.txt //直接创建文件less le-output.txt 当我们使用 “&gt;” 重定向符来重定向输出结果时，目标文件总是 从开头被重写（如果错误了就清空文件） 12&gt; ls-output.txt //故意用重定向符来清空文件内容ls -l /usr/bin &gt;&gt; ls-output.txt 用 &gt;&gt; 操作符可以把输出结果加到文件内容之后，如果文件不存在则会被创建 7.3标准错误重定向 一一个程序可以在几个编号的文件流中的任一个上产生输出。前三个称作标准输入、输出和错误，shell 内部分别将其称为文件描述符 0、1 和 2 1ls -l /bin/usr 2&gt; ls-error.txt //测试错误输出 7.4 重定向标准输出和错误到同一个文件 方法一 1ls -l /bin/usr &gt; ls-output.txt 2&gt;&amp;1 完成两个重定向，首先重定向标准输出到文件，然后重定向标准错误到标准输出，用2&gt;&amp;1。 注意重定向的顺序安排非常重要。标准错误的重定向必须总是出现在标准输出重定向之后， 要不然它不起作用。 12&gt; ls-output.txt 2&gt;&amp;1 //重定向标准错误到文件 ls-output.txt2&gt;&amp;1 &gt; ls-output.txt //标准错误定向到屏幕 方法二 1ls -l /bin/usr &amp;&gt; ls-output.txt 用 &amp;&gt; 来重定向标准输出和错误到文件 ls-output.txt 7.5处理不需要的输出 不想要一个命令的输出结果，系统重定向输出结果到 /dev/null 的特殊文件 1ls -l /bin/usr 2&gt; /dev/null 7.6 cat连接文件 cat 命令读取一个或多个文件，然后复制它们到标准输出 123cat [file] //复制到标准输出cate ls-output.txt //显示简短的文本文件cat -n textfile1 &gt; textfile2 //把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里,换成&gt;&gt;为附加到文档中 1234cat &gt; lazy_dog.txt //等待输入wowowo. //ctrl d结束cat lazy_dog.txt //复制文件内容到标准输出cat &lt; lazy_dog.txt //重定向标准输入，输入源为lazy_dog.txt 7.7管道线 管道线使得标准输入读取数据并输送到标准输出，一个命令的标准输出可以通过管道传到另一个命令的标准输入 12command1 | command2ls -l /usr/bin | less //不加less则直接输出到最后一行等待下一步命令，有less变成浏览文本文件 可以很方便的检测会产生标准输出的命令的运行结果 7.8过滤器 用来对数据完成复杂操作，把几个命令放在一起组成一个管道线，过滤器接受输入，以某种方式改变它，然后输出它。 1ls /bin /usr/bin | sort | less //产生两个目录的有序列表 7.9 uniq 报道或忽略重复行 uniq 经常和 sort 命令结合起来一起使用，默认情况下在数据列表中删除任何重复行 12ls /bin /usr/bin | sort | uniq | lessls /bin /usr/bin | sort | uniq -d | less //只看重复数据列表 7.10 wc 打印行数字数和字节数 wc（字计数）命令是用来显示文件所包含的行数、字数和字节数。 如果 wc 不带命令行参数，它接受标准输入。“-l” 选项限制命令输出只能报道行数。添加 wc 到管道线来统计数据，是个很便利的方法。查看我们的有序列表中程序个数 12wc ls-output.txtls /bin /usr/bin | sort | uniq | wc -l 7.11 grep打印匹配行 grep用来找到文件中的匹配文本 12grep pattern [file...] //使用方法ls /bin /usr/bin | sort |uniq | grep zip //找到文件名中包含单词zip的所有文件 grep -i 忽略大小写 -v 只打印不匹配的行 7.12 head/tail打印文件开头部分/结尾部分1234head -n 5 ls-output.txttail -n 10 ls-output.txtls -l /usr/bin | tail -n 5 //用于管道线中tail -f /var/log/messages //循环读取，跟踪增长情况 7.13 tee从stdin读取数据，并同时输出到stdout和文件 tee 程序从标准输入读入数据，并且同时复制数据到标准输出（允许数据继续随着管道线流动和一个或多个文件。当在某个中间处理阶段来捕捉一个管道线的内容时，这很有帮助。 1ls /usr/bin | tee ls.txt | grep zip 在 grep 过滤 管道线的内容之前，来捕捉整个目录列表到文件 ls.txt 8.从shell眼中看世界8.1 （字符）展开 echo 命令显示一行文本 12echo this is a test //测试echoecho * //观察*的展开,打印了所有文件 shell 中 * 会被展开，当回车键被按下时，shell 在命令被执行前在命令行上自动展开任何符合条件的字符，所以 echo 命令的实际参数并不是 “*”，而 是它展开后的结果。 8.2 路径名展开 通配符所依赖的工作机制叫做路径名展开 1echo /usr/*/share 隐藏文件的路径名展开 12echo .* //隐藏文件均以原点开头，但是输出包含 &#x27;.&#x27; 和 &#x27;..&#x27;ls -d .* | less //-d表示只显示当前目录文件，展开正确 8.3波浪线展开 用在一个单词开头时，它会展开成指定用户的家目录名，如果没有指定用户名，则展开成当前用户的家目录 12echo ~echo ~root 8.4 算术表达式展开12echo $((expression))echo 5+$((9-8)) 8.5 花括号展开1echo Front-&#123;A,B,C&#125;-Back 花括号展开模式可能包含一个开头部分叫做报头，一个结尾部分叫做附言。花括号表达式 本身可能包含一个由逗号分开的字符串列表，或者一个整数区间，或者单个的字符的区间。这 种模式不能嵌入空白字符 12echo Number &#123;1..5&#125;echo &#123;Z..A&#125; 花括号展开可以嵌套，最常见的应用是，创建一系列的文件或目录列表 1234mkdir Picscd Picsmkdir &#123;2007..2019&#125;-0&#123;1..9&#125; &#123;2007..2019&#125;-&#123;10..12&#125;ls 8.6 命令替换 命令替换允许我们把一个命令的输出作为一个展开模式来使用 不只限制于简单命令,也可以使用整个管道 线 12ls -l $(which cd) //which得到cd命令的地址，ls显示文件信息file $(ls /usr/bin/* | grep zip) //用于管道线，管道线输出结果为file命令的参数列表 8.7 引用 双引号 把文本放在双引号中，shell 使用的特殊字 符，都失去它们的特殊含义，被当作普通字符来看待 在双引号中，参数展开、算术表达式展开和命令替换仍然有效 123ls -l &quot;two words.txt&quot; //防止单词分割echo $(cal)echo &quot;$(cal)&quot; //在第一个实例中，没有引用的命令替换导致命令行包含38 个参数。在第二个例子中，命令行只有一个参数，参数中包括嵌入的空格和换行符。 单引号 禁止所有展开，包括转义字符 123echo text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USERecho &quot;text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER&quot;echo &#x27;text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER&#x27; 8.8 转义字符 \\ 作为转义字符，阻止展开、消除特殊含义字符(比如$) 在文件名包含特殊字符时起作用 12echo &quot;The balance for user $USER is: \\$5.00&quot;echo &quot;The balance for user $USER is: $5.00&quot; 9 键盘高级操作9.1 移动光标 9.2 修改文本 9.3 剪切和粘贴文本 9.4 自动补全 按下tab，自动补全路径名、对变量补全、用户名、命令、主机名 9.5 利用历史命令 搜索历史命令 123history | less //浏览历史列表的内容history | grep /usr/bin!88 //展开历史列表中88行的内容 ctrl-r进入搜索 9.8 历史命令展开 10 权限10.1 拥有者、组成员和其他人1id //显示用户id并且映射到一个用户名 用户帐户定义在/etc/passwd 文件里面,用户组定义在/etc/group 10.2 读取写入和执行 剩下的九个字符叫做文件模式，代表着文件所有者、文件组所有者和其他人的读、写和执 行权限。 owner group world rwx rwx rwx 属性 文件 目录 r 允许打开并 读取文件内 容 允许列出目录中的内容，前提是目录必须设置了可执 行属性（x） w 允许写入文 件内容或截 断文件。但 是 不允 许 对文件进行重命名或删 除，重命名 或删除是由 目录的属性 决定的 允许在目录下新建、删除或重命名文件，前提是目录 必须设置了可执行属性（x） x 允许将文件 作为程序来 执行，使用 脚本语言编 写的程序必 须设置为可 读才能被执 行。 允许进入目录，例如：cd directory 10.3 chomod更改文件模式分为八进制表示法和符号表示法两种 八进制对应3个二进制数字，正好用于映射存储文件模式所使用的方案 chomod 600 foo.txt 常见映射7 (rwx)，6 (rw-)，5 (r-x)，4 (r–)，和 0 (—) 符号表示法 操作内容 u+x 为文件所有者添加可执行权限 u-x 为文件所有者添加可执行权限 +x 为文件所有者，用户组，和其他所有人添加可执行权限。等 价于 a+x o-rw 除了文件所有者和用户组，删除其他人的读权限和写权限 go=rw 给文件所属的组和文件所属者/组以外的人读写权限。如果 文件所属组或其他人已经拥有执行的权限，执行权限将被移 除 u+x,go=rw 给文件拥有者执行权限并给组和其他人读和执行的权限。 多种设定可以用逗号分开 10.4 借助GUI来设置文件模式 右击文件或者目录图标 10.5 umask设置默认权限 umask值 权限 0000 -rw-rw-rw- 0002 -rw-rw-r– 有二进制数字1的位置属性被删除 12umask //得到掩码值umask 0000 //设置掩码值 setuid、setgid、sticky位特殊权限 123chmod u+s program //授予一个程序 setuid 权限chmod g+s dir //授予一个目录 setgid 权限chmod +t dir //授予一个目录 sticky 权限 属性 结果 具有 setuid 属性的程序 -rw**s**r-xr-x 具有 setgid 属性的目录 drwxrw**s**r-x 设置了 sticky 位的目录 drwxrwxrwt 10.6 更改身份 注销系统并以其他用户身份重新登录系统。 使用 su 命令 使用 sudo 命令 10.7 su命令1su [-[l]] [user] 如果包含 “-l” 选项，那么会为指定用户启动一个需要登录的 shell。这意味着会加载此用户 的 shell 环境，并且工作目录会更改到这个用户的家目录。这通常是我们所需要的。**-l可以缩写为-** 如果不指 定用户，那么就假定是超级用户 输入exit回到原来的shell 12su -c &#x27;command&#x27; //格式su -c &#x27;ls -l /root/*&#x27; 传递命令command到新的shell中执行，而不启动这个shell，引号防止命令展开 10.8 sudo命令 sudo 命令不要求超级用户的密码，使用 sudo 命令时，用户 使用他/她自己的密码来认证 管理员能够配置 sudo 命令，从而允许一个普通用户以不同的身份（通常是超级用户），通过一种非常可控的方式来执行命令 su 和 sudo 之间的一个重要区别是 sudo 不会重新启动一个 shell，也不会加载 另一个用户的 shell 运行环境 10.9 chown更改文件所有者和用户组1chown [owner][:[group]] file 1234567[janet@linuxbox ~]$ sudo cp myfile.txt ~tony //用户 janet 把文件从她的目录复制到 tony 的家目录Password:[janet@linuxbox ~]$ sudo ls -l ~tony/myfile.txt-rw-r--r-- 1 root root 8031 2008-03-20 14:30 /home/tony/myfile.txt[janet@linuxbox ~]$ sudo chown tony: ~tony/myfile.txt //janet 把文件所有者从 root（使用 sudo 命令的原因）改到 tony,同时把文件用户组改为 tony 登录系统时，所属的用户组，碰巧是用户组 tony[janet@linuxbox ~]$ sudo ls -l ~tony/myfile.txt-rw-r--r-- 1 tony tony 8031 2008-03-20 14:30 /home/tony/myfile.txt 可能存在的问题： 系统中默认的掩码值是 0022，这会禁止用户组成员编辑 属于同组成员的文件，修改掩码值解决 用户组成员创建的文件和目录的用户组，将会设置为用户的主要组，而不是想要的用户组，设置此目录的setgid位来解决 10.10 更改用户密码1passwd [user] 如果你具有超级用户权限，你可以指定一个用户名作为 passwd 命令的参数，这样可以设置 另一个用户的密码。还有其它的 passwd 命令选项对超级用户有效，允许帐号锁定，密码失效,详细内容参考 passwd 命令的手册页 还有一系列的命令行程序，可以用来创建和维护用户和用户组： adduser useradd groupadd 11 进程11.1 ps查看进程123psps x //显示所有进程ps aux //显示所有进程并获得详细信息 stat状态含义 11.1 top查看进程1top //动态显示进程 h查看帮助，q退出 11.2信号kill命令可以像进程发送信号，默认是term 注意，信号既可以用号码，也可以用名字来 指定，包括在前面加上字母“SIG”的名字 12kill -signal PIDkill -1 13546 11.3 killall向多个进程发送信号1killall [-u user] [-signal] name... 10.4 关闭系统4种方式 halt poweroff reboot shutdown 123sudo rebootsudo shutdown -h now //挂起sudo shutdown -r now //重启 12 环境12.1检查环境1234printenv | lessprintenv USER //列出指定环境变量的值set | lessecho $HOME //用echo命令查看变量内容 环境中的别名无法使用set命令和printenv命令显示，想要查看别名，可以使用不包含参数的alias 查找用/ ,区分大小写 12.2 值得注意的环境变量 12.3 如何建立环境 是登录 shell 会话 非登录shell会话 非登录 shell 会话也会继承它们父进程的环境设置，通常是一 个登录 shell 12.4 启动文件 当我们 输入 ls 后，shell 不会查找整个计算机系统来找到 /bin/ls（ls 命令的全路径名），相反，它查找 一个目录列表，这些目录包含在 PATH 变量中 1PATH=$PATH:$HOME/bin //修改 PATH 变量，添加目录 $HOME/bin 到目录列表的末尾 12.5 修改环境、使用文本编辑器 添加目录到你的 PATH 变量或者是定义额外的环境变量，要把这些更改放置 到.bash_profile 文件中 1gedit some_file //如果所输入的文件名不存在，编辑器则会假定你想要创建一个新文件 当我们编辑一个重要的配置文件时，首先创建一个这个文件的备份总是一个不错的主意。这样能避免我们在编辑文件时弄乱文件 1cp .bashrc .bashrc.bak ctrl O 保存文件，ctrl X 退出 我们对于文件.bashrc 的修改不会生效，直到我们关闭终端会话，再重新启动一个新的会话，因 为.bashrc 文件只是在刚开始启动终端会话时读取。然而，我们可以强迫 bash 重新读取修改过 的.bashrc 文件,用命令 1source .bashrc 13 vi入门13.1 启动和退出1234vi //启动vi:q //退出vi:q! //强制退出（一般是修改没保存）//连按两下esc可以回到命令模式 13.2 编辑模式 刚进入vi进入到命令模式，每一个按键都是命令，按i键进入输入模式 按两下esc回到命令模式，输入:w保存 小贴示：如果你阅读 vim 的文档，你会发现命令模式被（令人困惑地）叫做普通模式（normal mode)，ex 命令叫做命令模式 13.3 光标移动 G是大写，要配合shift vi命令都可以加上数字前缀，5j可以使光标下移5行 13.4 基本编辑追加 insert命令做不到 a 命令，在当前光标后追加（进入插入模式） A命令，在当前行末尾追加（进入插入模式） 新建 删除 手速要快 按u撤销删除 剪切复制和粘贴 d 命令不仅删除文本，它还“剪切”文本。每次我们使用 d 命令，删除的部分被复制到一 个粘贴缓冲区中（看作剪切板） y命令复制文本 命令 功能 p 粘贴至下一行（无论光标在这一行的哪里） P 粘贴至上一行（无论光标在这一行的哪里） 合并 J 命令合并光标所在行与下一行 13.5 搜索和替换搜索 行内搜索用 fa 命令；按 ; 继续行内搜索 搜索整个文件 /,重复搜索n即可 全局搜索和替换123:%s/Line/line/g //把文件中所有的单词Line都更改为line:1,$s/Line/line/g //与前面那个一样:%s/line/Line/gv //把line改回去，c要求每一次替换前确认替换 13.6 编辑多个文件12345vim file1 file2 file3... //用vi会出现问题（可能vi不支持）:bn //切换到下一个文件（强制切换加上！）:bp //切换到上一个文件:buffers //显示缓冲区:buffer 1 载入更多文件 1:e ls-output.txt 将一个文件的内容复制到另一个文件: 用yy复制buffer切换p粘贴即可 将整个文件插入另一个文件（注意是在光标位置之后） 1:r foo.txt //在光标位置之后将文件读入并 13.7 保存工作 在命令模式下输入 ZZ 即可 输入:w 另存为 :w foo1.txt (注意这样是另存为foo1，现在仍在编辑foo) 14. 定制提示符14.1 分解提示符12echo $PS1[\\u@\\h \\W]\\$ 转移字符表 14.2 换一种提示符123ps1_old=&quot;$PS1&quot; //首先备份现有的提示符PS1=&quot;$ps1_old&quot; //恢复原有的提示符PS1=&quot;\\[\\033[0;41m\\]&lt;\\u@\\h \\W&gt;\\$\\[\\033[0m\\]&quot; //前一个使输出系统信息为红色，后一个使输入文字信息为黑色 背景颜色 光标设置 PS1=&quot;\\[\\033[s\\033[0;0H\\033[0;41m\\033[K\\033[1;33m\\t\\033[0m\\033[u\\]&lt;\\u@\\h \\W&gt;\\$&quot;使用上面的编码，我们将构建一个提示符，每次当这个提示符出现的时候，会在屏幕的上方 画出一个包含时钟（由黄色文本渲染）的红色长条 14.3 保存提示符 把下面两行添加到.bashr文件中去 12PS1=&quot;\\[\\033[s\\033[0;0H\\033[0;41m\\033[K\\033[1;33m\\t\\033[0m\\033[u\\]&lt;\\u@\\h \\W&gt;\\$&quot;export PS1 15 软件包管理15.1 打包系统 15.2 软件包的工作方式 Linux系统中几乎所有的软件都可以在互联网上找到。其中大多数软件由发行商以包文件的形式提供，剩下的则以源码形式存在，可以手动安装。 在包管理系统中软件的基本单元是包文件。包文件是一个构成软件包的文件压缩集合。一个软件包可能由大量程序以及支持这些程序的数据文件组成。 系统发行版的用户可以在一个中心资源库中得到这些软件包，这个资 源库可能包含了成千上万个软件包，每一个软件包都是专门为这个系统发行版建立和维护的。 程序很少独立工作；他们需要依靠其他程序的组件来完成他们的工作。现代的软件包管理系统都提供了一些依赖项解析方法，以确保安装软 件包时，其所有的依赖也被安装。 15.3 常见的软件包管理任务查找 安装 下载安装 下载好文件直接安装 卸载 更新 通过下载的软件包升级 列出 确认是否安装 显示安装包信息 查找安装了某个文件的包 16 存储介质16.1存储设备的挂载与卸载 Linux 在单一文件系统树中维 护连接在各个节点的各种设备。在MS-DOS 和 Windows 系 统中，每个设备（例如 C:\\，D:\\，等）保持着单独的文件系统树 文件 /etc/fstab 列出了系统启动时要挂载的设备 cat /etc/fstab 查看已挂载的文件系统列表 mount命令 若有光盘： 123umount /dev/hdc //卸载CDROM（需要root权限）mkdir /mnt/cdrom //建立新目录mount -t iso9660 /dev/hdc /mnt/cdrom //将CDROM挂载到新的挂载点，-t指定文件系统类型 16.2 确定设备名称 列出/dev 目录下的内容 ls /dev tail -f /var/log/messages 对操作系统实时监测，插入设备观察设备名称，知道设备名称之后挂载设备 挂载之后设备只要不拔下来，并且系统不重启，设备名称就不会发生变化 用df命令显示目前在 Linux 系统上的文件系统磁盘使用情况统计 16.3 创建新文件系统用fdisk修改文件系统12345678sudo umount /dev/sdb1sudo fdisk /dev/sdbCommand (m for help):m //显示菜单Command (m for help):p //显示设备分区表Command (m for help):l //显示可能的文件系统列表及对应的idCommand (m for help):t //修改Hex code (type L to list codes): 83Command (m for help):w //保存 使用mkfs创建新的文件系统make file system 12sudo mkfs -t ext3 /dev/sdb1 //指定ext4为文件系统类型sudo mkfs -t vfat /dev/sdb1 //指定vfat为文件系统类型 16.4 文件系统的检查与修复 sudo fsck /dev/sdb1修复损坏的文件系统 已修复的文件会存放在各个文件系统根目录下的lost+found 目录里面 16.5 设备之间直接移动数据 dd命令实现将数据块从一处复制到另一处 12345dd if=input_file of=output_file [bs=block_size [count=blocks]]dd if=/dev/sdb of=/dev/sdc //如果连接两个设备到计算机上，它们各自被分配到设备/dev/sdb和/dev/sdc上把第一个驱动器中的所有数据复制到第二个驱动器中dd if=/dev/sdb of=flash_drive.img //如果只有第一个驱动器被连接到计算机上，我们可以把它的内容复制到一个普通文件中供以后恢复或复制数据 ==注意==： dd命令的功能非常强大，起名取自“data definition”（数据定义），然而有时候也会被成为“destory disk”（摧毁磁盘），因为用户经常不小心输错if 或者of 说明。在Enter之前，一定要检查一遍if of说明！ 向可刻录CD写入数据写入一个可记录的 CD-ROM（一个 CD-R 或者是 CD-RW）由两步组成 首先，构建一个 iso 映像文件，这就是一个 CD-ROM 的文件系统映像 第二步，把这个映像文件写入到 CD-ROM 媒介中。 创建iso映像文件123dd if=/dev/cdrom of=ubuntu.iso //使用 dd 命令来读取 CD-ROW 中的所有数据块，并把它们复制到本地文件中genisoimage -o cd-rom.iso -R -J ~/cd-rom-files //用genisoimage命令来从文件集合中创建一个映像//“-R” 选项添加元数据为 Rock Ridge 扩展，这允许使用长文件名和 POSIX 风格的文件权限。 “-J” 选项使 Joliet 扩展生效，这样Windows中就支持长文件名了 写入CD-ROM中 直接挂载iso映像文件 1234mkdir /mnt/iso_image //创建挂载点mount -t iso9660 -o loop image.iso /mnt/iso_image //使用mount命令的-o loop选项、指定文件系统类型的-t iso9660选项，将iso映像文件当作设备挂载到文件系统树（可以把它当作真实的CD使用）md5sum image.iso //使用md5sum命令产生十六进制书校验文件(检查完整性)md5sum /dev/cdrom 擦除可刻录CD、刻录映像文件 17 联网17.1 网络检查与监控ping ping命令： ping 命令发送一个特殊的网络数据包，叫做 ICMP ECHO_REQUEST，到一台指定的主机。大多数接收这个包的网络设备将会回复它，来 允许网络连接验证 注意：大多数网络设备（包括 Linux 主机）都可以被配置为忽略这些数据包。通常，这样 做是出于网络安全原因，部分地遮蔽一台主机免受一个潜在攻击者地侵袭。配置防火墙来阻塞 IMCP 流量也很普遍。 traceroute traceroute程序完整过程：首先它发送一份TTL字段为1的IP数据包给目的主机，处理这个数据包的第一个路由器将TTL值减1，然后丢弃该数据报，并给源主机发送一个ICMP报文（“超时”信息，这个报文包含了路由器的IP地址，这样就得到了第一个路由器的地址），然后traceroute发送一个TTL为2的数据报来得到第二个路由器的IP地址，继续这个过程，直至这个数据报到达目的主机 输出结果中会列出网络流量从本地系统到指定主机的所有跳（hop）数，其中没有提供标识信息的路由器用*号表示 ip ip a检查系统的网络接口和路由表 当执行日常网络诊断时，要查看的重要信息是每个网络接口第四行开头出现的单词“UP”， 说明这个网络接口已经生效，还要查看第二行中 inet字段出现的有效 IP 地址。 netstat netstatt 程序被用来检查各种各样的网络设置和统计数据。通过此命令的许多选项，我们可以看 看网络设置中的各种特性 使用“-ie”选项，我们能够查看系统中的网络接口 “-r”选项能够显示内核的网络路由表，从中能够看出分组时如何在网络之间传送的 17.2 通过网络来传输文件ftp FTP指的是协议，ftp指的是与之同名的程序 命令 功能 ftp fileserver 连接名叫fileserver的ftp服务器 cd pub/ 在大多数匿名的 FTP 服务器中，支持公共 下载的文件都能在目录 pub 下找到 lcd Desktop 将本地目录改为 ~/Desktop,ftp程序工作目录默认在 ~/Desktop下 get …iso 将远程系统文件传至本地，即~/Desktop bye 登出远程服务器 lftp-更好的ftp：包括多协议支持（包括 HTTP），若下载失败会自动地重新下载， 后台处理，用 tab 按键来补全路径名 wget 支持递归下载、后台下载、断点续传 wget http://linuxcommand.org/index.php 17.3 与远程主机的通信 都在OpenSSH包中 ssh（Secure Shell) 认证身份 加密本地与远程主机通信（从22端口） SSH 由两部分组成。(必须都要安装) 1.SSH服务端运行在远端主机上，在端口 22 上监听收到的外部连接 2.SSH客户端用在本地系统中，用来和远端服务器通信 命令 功能 ssh bob@remote-sys 以用户bob的身份连接远程主机 ssh remote-sys free 在远程主机上运行free命令并在本地显示结果 ssh remote-sys &#39;ls *&#39; &gt; dirlist.txt 输出到本地主机文件（ls命令用单引号括起来防止在本地展开） ssh remote-sys &#39;ls * &gt; dirlist.txt&#39; 输出到远程主机（注意单引号位置） ssh -X remote-sys;xload 在远程主机上运行xload窗口出现在本地主机（-X传界面） scp与sftpscp scp（安全复制）被用来复制文件，与熟悉的 cp 程序非常相似。最显著的区别就是源或者目标 路径名要以远端主机的名字，后跟一个冒号字符开头 1scp bob@remote-sys:document.txt //以bob账号登入远程主机并复制文件 sftp ftp 程序的安全替代品,是 sftp 不需要远端系统中运行 FTP 服务端。 它仅仅需要 SSH 服务端。这意味着任何一台能用 SSH 客户端连接的远端机器，也可当作类似 于 FTP 的服务器来使用。 用法参照ftp 18 查找文件18.1 locate查找文件 locate bin/zip列出所有以zip开头的程序，目录以bin/结尾的程序 结合grep命令使用更高效 18.2 find-复杂的文件的查找方法12find ~ //指定一个目录为查找范围find ~ | wc -l 测试条件123find ~ -type d | wc -l //type d限制只查找目录find ~ -type f | wc -l //限制只查找普通文件find ~ -type f -name &quot;*.JPG&quot; -size +1M | wc -l //查找所有匹配*.JPG而且大于1MB的普通文件（加入双引号防止路径名扩展） 操作符 查找权限不为0600的文件和权限不为0700的目录 1find ~ \\( -type f -not -perm 0600 \\) -or \\( -type d -not -perm 0700 \\) 注意默认使用and 以及括号组合字符 对于被分隔的表达式，不一定默认求值 expr1 -operator expr2 预定义操作 -print 为默认操作 12find ~ -type f -name &#x27;*.bak&#x27; -print //先筛选再printfind ~ -print -type f -name &#x27;*.bak&#x27; //先print再筛选 在使用delete命令之前，先用print检查输出，确保万无一失 自定义操作 find的-exec选项 command是命令名， {} 是代表当前路径名的符号， ; 作为分隔符，表示命令结束（需要转义，用\\ 和 ‘’ 都可以） 123-exec command &#123;&#125; ; //-exec操作用法find ~ -type f -name &#x27;.*&#x27; -exec ls -l &#x27;&#123;&#125;&#x27; &#x27;;&#x27; //在当前目录下，找到所有的隐藏文件并ls -l输出find ~ -type f -name &#x27;.*&#x27; -ok ls -l &#x27;&#123;&#125;&#x27; &#x27;;&#x27; //加入 -ok 在执行操作前提示用户 提高效率 （使用xargs 或者find命令自身新特性） 将结尾的分号改成加号，就能让find命令将查找结果组合成参数列表，共指定的命令一次性使用 1find ~ -type f -name &#x27;.*&#x27; -exec ls -l &#x27;&#123;&#125;&#x27; + 虽然得到一样的结果，但是只执行了一次ls命令 xargs 从标注输入接受输入，将其转换为指定命令的参数列表 命令参数数量不是无限制的，超出shell支持的最大参数xargs会重复使用最大参数直至完成 12find ~ -type f -name &#x27;.*&#x27; -print | xargs ls -l //find命令的输出结果通过管道传给了xargs命令，后者构造ls命令的参数列表，然后执行该命令find ~ -type f -name &#x27;.*&#x27; -print | xargs --show-limits ls -l //执行xargs 时加入--show-limits显示最大支持参数(注意是在xargs命令后面加入) 18.3 实战演练 mkdir -p 命令创建指定路径的父目录以及子目录 touch 命令通常被用来设置或更新文件的访问，更改，和修改时间。如果一个文件名参数是一个不存在的文件，则会创建一个空文件。 1234567891011[me@linuxbox ~]$ mkdir -p playground/dir-&#123;00&#123;1..9&#125;,0&#123;10..99&#125;,100&#125; //创建100个子目录[me@linuxbox ~]$ touch playground/dir-&#123;00&#123;1..9&#125;,0&#123;10..99&#125;,100&#125;/file-&#123;A..Z&#125; //每个目录26个空文件[me@linuxbox ~]$ find playground -type f -name &#x27;file-A&#x27; | wc -l[me@linuxbox ~]$ touch playground/timestamp //创建timestamp将其时间设置当前时间[me@linuxbox ~]$ stat playground/timestamp //查看属性（ls增强版）[me@linuxbox ~]$ touch playground/timestamp[me@linuxbox ~]$ stat playground/timestamp[me@linuxbox ~]$ find playground -type f -name &#x27;file-B&#x27; -exec touch &#x27;&#123;&#125;&#x27; &#x27;;&#x27; //更新所有file-B文件[me@linuxbox ~]$ find playground -type f -newer playground/timestamp //识别所有更新[me@linuxbox ~]$ find playground \\( -type f -not -perm 0600 \\) -or \\( -type d -not -perm 0700 \\)[me@linuxbox ~]$ find playground \\( -type f -not -perm 0600 -exec chmod 0600 &#x27;&#123;&#125;&#x27; &#x27;;&#x27; \\) -or \\( -type d -not -perm 0711 -exec chmod 0700 &#x27;&#123;&#125;&#x27; &#x27;;&#x27; \\) //为所有文件设置新的权限 18.4 find命令选项 19 归档与备份19.1 文件压缩gzip123456gzip foo.txtgzip -tv foo.txt.gz //没有v只验证完整性不输出结果gunzip foo.txt //解压，不用带.gz的后缀名ls -l /etc | gzip &gt; foo.txt.gz //输出直接压缩成文件（加上后缀表名是压缩过的）gunzip -c foo.txt.gz | less //只查看压缩文件的文本内容（注意-c后缀的作用）zcat foo.txt.gz | less //等同于-c的gzip zless 程序共功能等同于管道操作符 bzip2 用法与gzip差不多 扩展名为.bz2 牺牲压缩速度实现了更高的压缩率 二次压缩 二次压缩并不会节省空间，所有压缩技术都涉及额外信息，用来描述压缩过程 尝试压缩不包含任何冗余信息的文件，省下来的空间不足以抵消额外信息使用的空间 19.2 文件归档 文件归档：收集多个文件将其组合成一个大文件(可以同时压缩) tar f选项指定名称，是必须的，“-”不是必须的 v选项获得详细清单 tar命令从归档中提取出来的文件所有权属于执行提取操作的用户，而非原先的用户（超级用户操作除外） tar命令归档、提取都是相对路径 归档tar，归档压缩tgz、tbz 123tar mode[options] pathnametar cf playground.tar playground //为playgorund归档，f选项为指定名称tar tvf playground.tar //列出归档文件的详细内容 通过硬盘把一台电脑系统主目录复制到另一台电脑 1234sudo tar cf /media/BigDisk/home.tar /home //硬盘自动挂载在/media目录下//卸载硬盘接入另一台计算机cd / //提取归档是相对路径，不进入根目录就会出现/home/usr/home...sudo tar xf /media/BigDisk/home.tar 限制提取 12tar xf archive.tar pathname //只提取指定文件，可多指定tar xf ../playground2.tar --wildcards &#x27;home/playground/dir-*/file-A&#x27; //提取所有的fileA，--wildcards加入对通配符的支持 与find配合 1find playground -name &#x27;file-A&#x27; -exec tar rvf playground.tar &#x27;&#123;&#125;&#x27; &#x27;+&#x27; //以追加模式（r）调用tar，将查找到的所有文件添加进来 可以通过find查找更新的文件，创建上一次归档之后出现的那些文件的归档 利用标准输入输出 12find playground -name &#x27;file-A&#x27; | tar cvf - --files-from=- | gzip &gt; playground.tgz //先用find匹配文件列表，通过管道线传给tar，“-”为标准输入输出的惯例，--files-from (也可以写为-T)使其从文件中而不是命令行中读取文件列表，最后传给gzip压缩find playground -name &#x27;file-A&#x27; | tar czf playground.tgz -T - //简化命令，通过z选项指定gzip压缩，j选项可有指定bzip2压缩（文件后缀改为tbz） 通过ssh打包远程主机文件 1ssh remote-sys &#x27;tar cf - Documents&#x27; | tar xf - //在远程主机上执行tar命令，标准输出传到本地主机，本地主机把标准输出提取（x命令） zip zip既能压缩也能归档（gzip、bzip2在linux上才是主流） zip与tar不同之处在于，如果内容已存在（同名），zip是添加新文件并且替换，而tar是直接替换 1234zip options zipfile filezip -r playground.zip playground //不加入递归（-r)则只保留目录不包含内容unzip playground.zip //提取并解压缩unzip -l playground.zip playground/dir-087/file-Z //指定文件-l选项只列出不提取解压缩 zip 的标准输入输出（unzip不接受标准输入） 123find playground -name &quot;file-A&quot; | zip -@ file-A.zip //-@选项将文件名列表传给zipls -l /etc/ | zip ls-etc.zip - //结尾的“-”是标准输入unzip -p ls-etc.zip | less //将unzip结果发送到标准输出 19.3 同步文件与目录 rsync 远程更新协议 这里 source 和 destination 是下列选项之一：• 一个本地文件或目录• 一个远端文件或目录，以 [user@]host:path的形式存在• 一个远端 rsync 服务器，由rsync://[user@]host[:port]/path指定 123rsync options source destinationrsync -av playground foo //playground的所有内容包括自身都同步到foo中（-a表示递归且保留文件属性，-v显示详细）rsync source/ destination //source下的所有文件不包括自身被同步，只复制目录不复制目录本身 硬盘备份 123mkdir /media/BigDisk/backupsudo rsync -av --delete /etc /home /usr/local /media/BigDisk/bcakup //添加--delete选项，用于删除存在于备份设备而原设备不存在的文件// alias backup=&#x27;sudo rsync -av --delete /etc /home /usr/local /media/BigDisk/bcakup&#x27; 定义别名备份更方便 在网络上使用rsync 方法一 12sudo rsync -av --delete --rsh=ssh /etc /home /usr/local remote-sys:/backup//加入--rsh=ssh选项，用于指示rsync用远程shell备份 方法二 20.正则表达式https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md 21. 文本处理","categories":[],"tags":[]}],"categories":[],"tags":[]}