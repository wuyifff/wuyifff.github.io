{"meta":{"title":"wuyifff's blog","subtitle":"hello","description":"this is my blog","author":"wuyifff","url":"https://wuyifff.github.io","root":"/"},"pages":[{"title":"about","date":"2021-10-17T07:55:55.000Z","updated":"2021-10-17T07:55:55.415Z","comments":false,"path":"about/index-1.html","permalink":"https://wuyifff.github.io/about/index-1.html","excerpt":"","text":""},{"title":"about","date":"2021-10-17T07:14:00.000Z","updated":"2021-10-17T07:14:30.016Z","comments":false,"path":"about/index.html","permalink":"https://wuyifff.github.io/about/index.html","excerpt":"","text":"这里写关于页的正文，支持 Markdown, HTML"}],"posts":[{"title":"C++ primer 读书笔记 chapter 15 面向对象程序设计","slug":"15.面向对象程序设计","date":"2021-10-24T07:38:00.000Z","updated":"2021-10-24T07:38:57.126Z","comments":true,"path":"2021/10/24/15.面向对象程序设计/","link":"","permalink":"https://wuyifff.github.io/2021/10/24/15.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"C++ Primer chapter 15面向对象程序设计OOP概述OOP三大核心思想：抽象、继承和多态（动态绑定）。 数据抽象将类的接口与实现分离 继承可以定义相似的类型并对其相似关系建模 多态则在一定程度上忽略相似类型的区别，实现统一方式来使用一组对象 对继承来说，层次关系的根部类叫基类，其他类可以直接或间接从基类继承而来，它们叫派生类。基类负责定义在层次关系中所有类共同拥有的成员，派生类定义各自特有的成员。 而一旦有了继承，也就可以应用多态。想要解释继承和多态，再多的语言也是苍白无力。不如从一个例子说起： 123456789class Quote&#123;public: std::string isbn() const; virtual double net_price(std::size_t n) const;//定义为虚函数，实现多态&#125;;class Bulk_quote : public Quote&#123; // Bulk_quote继承了Quotepublic: double net_price(std::size_t) const override;&#125;; Quote为基类，Bulk_quote为Quote的派生类（子类）。派生类通过类派生列表(class derivation list)明确指出从哪个(哪些)基类继承而来。其中关键字public表示公有继承，先不解释其作用。 基类的函数net_price前面加上virtual表示其是一个虚函数，虚函数的作用是为了实现多态。一旦基类定义了虚函数，那么派生的子类就可以通过重新定义来覆盖基类的虚函数实现。派生类可以省略virtual关键字，尽管子类中不声明virtual，覆盖函数定义仍然还是虚函数。(但是还是应该带上virtual,这样间接继承就免得去看基类的实现) C++11标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，这就是上例中override关键字的作用。==（好处是万一同名参数形参列表不同将会overrid失败，编译器将会报错帮助你发现）== virtual实现的动态绑定怎么用呢？（翁恺c++ p23-24） 123456789101112double print_total(ostream &amp;os, const Quote &amp;item, size_t n)&#123; //如果item是Quote对象，调用Quote::net_price //如果item是Bulk_quote对象，调用Bulk_quote::net_price double ret = item.net_price(n); os &lt;&lt; &quot;ISBN: &quot; &lt;&lt; item.isbn() //调用Quote::isbn &lt;&lt; &quot; # sold: &quot; &lt;&lt; n &lt;&lt; &quot; total due: &quot; &lt;&lt; ret &lt;&lt; endl; return ret;&#125;print_total(cout, basic, 20); //basic是Quote对象print_total(cout, bulk, 20); //bulk是Bulk_quote对象 可以看到尽管形参是一个const Quote对象的引用，但可以传入一个派生类对象作为实参，而一旦如此，对形参调用类成员函数时，就会进行动态绑定，即派生类调用派生类重新定义的虚函数体，基类调用基类定义的虚函数体。 如果net_price不是虚函数，即使子类中重新定义了一模一样的net_price，对该例来说，无论传给item的对象是子类还是派生类，最终调用的都是父类的net_price。所以说虚函数才支持动态绑定。深入一点说，拥有虚函数的类对象都有虚表，忽略基类型别动态绑定到子类成员函数的过程实际上是依赖于类对象的虚表指针，因为无论对象被看成基类还是子类，它的虚表指针始终是指向正确的解绑函数的。 所以，多态的存在可以让我们在程序设计上使用父类指针（或引用）指向子类对象，也就是所谓的“一定程度上忽略相似类型的区别，实现统一方式来使用一组对象”。 定义基类和派生类123456789101112131415class Quote&#123;public: Quote() = default; //合成默认构造函数 Quote(const std::string &amp;book, double sales_price):bookNo(book), price(sales_price)&#123;&#125; std::string isbn() const &#123;return bookNo;&#125; //返回给定数量的书籍的销售总额 //派生类负责改写并使用不同的折扣计算算法 virtual double net_price(std::size_t n) const &#123;return n * price;&#125; virtual ~Quote() = default; //对析构函数进行动态绑定private: std::string bookNo; //书籍的ISBN编号protected: double price = 0.0; //代表普通状态下不打折的价格&#125;; 为什么析构函数要定义成虚函数呢？因为我们往往使用多态时，会使用父类指针指向子类对象，而后续可能会delete父类指针，如果析构函数不是虚函数，那么delete一个子类对象不会调用子类对象的析构，而是直接调用父类的析构了，这与预期不符。 所以，==拥有虚函数的父类的析构函数往往也是虚函数==（因为多态需要虚函数来实现）。 这里的一个疑点：类成员protected权限是什么？ 成员函数与继承派生类可以继承基类的成员，基类的成员函数有两种：希望派生类进行覆盖而被声明为virtual的虚函数、希望派生类直接使用的函数。 任何构造函数之外的非静态函数都可以是虚函数。==构造函数不能virtual！== 构造函数为什么不能virtual呢？很简单，因为构造子类理应递归的调用父类的构造器，如果父类构造器被virtual化了，那么子类就无法调用到父类的构造器了。 普通的成员函数的解析过程发生在编译阶段，虚函数的解析过程发生在运行时(从虚表(virtual table)取函数地址)。 所以有虚函数的类会大一点，在类的开头有一个指针指向virtual table。 访问控制与继承派生类可以继承基类的成员，但这并不意味着派生类内部可以随意使用基类的成员。在public继承条件下，如果父类的成员是private权限，那么派生类内部无法访问，如果父类的成员是public权限，那么派生类内部可以访问。 那么，有的时候我们希望父类的一些成员也可以被子类访问，但不希望被其他外部非亲非戚的访问，private和public就都不好用了，于是，就有了protected权限。protected修饰的成员意味着派生类可以访问，外部不行。 继续定义派生类： 12345678910class Bulk_quote : public Quote&#123;public: Bulk_quote() = default; Bulk_quote(const std::string &amp;, double, std::size_t, double); //覆盖基类的虚函数，隐式virtual double net_price(std::size_t) const override;private: std::size_t min_qty = 0; //自己的成员，折扣政策下最低购买量 double discount = 0.0; //折扣额&#125; 派生类对象包含多个组成部分：含有派生类自己定义的(非静态)成员的子对象，以及一个与该类继承的基类对应的子对象，如果有多个基类，那么也就有对应多个子对象。 Bulk_quote对象 | bookNo | 从Quote继承 | price | | min_qty | Bulk_quote自定义的成员 | discount | 之所以能完成继承，本质上是因为派生类对象中拥有基类对象。 C++标准没有规定派生类对象的内存如何分布，有兴趣可以看看《深度探索C++对象模型》，当然由于这本书比较老了，所以现在主流编译器的设计和书中内容有较大差异，但仍然极有价值，毕竟授人以渔。 因为派生类对象中含有与其基类对应的组成部分，所以可以把派生类对象当成基类对象使用，也能将基类指针或引用绑定到派生类对象的基类部分上。 12345Quote item; //基类对象Bulk_quote bulk; //派生类对象Quote *p = &amp;item; //p指向Quote对象p = &amp;bulk; //p指向bulk的Quote部分Quote &amp;r = bulk; //r绑定到bulk的Quote部分 这种称为派生类到基类的类型转换，编译器会隐式执行派生类到基类的转换。 派生类构造函数1Bulk_quote(const std::string &amp;book, double p, std::size_t qty, double disc) : Quote(book, p), min_qty(qty), discount(disc)&#123;&#125; 初始化列表中调用了Quote的构造函数，用来负责初始化基类部分。 除非特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。如果想使用其他的基类构造函数，我们需要以类名加圆括号内的实参列表的形式为构造函数提供初始值。 派生类的构造器总是先初始化基类部分，再按声明顺序依次初始化派生类成员。 派生类使用基类的成员1234567double Bulk_quote::net_price(size_t cnt) const&#123; if(cnt &gt;= min_qty) return cnt * (1 - discount) * price; else return cnt * price;&#125; 继承与静态成员如果基类定义了静态成员，则整个继承体系中只存在该成员的唯一定义。不论基类中派生出多少个派生类，对每个静态成员来说都只存在唯一的一个实例。 因为静态成员实际上是全局的，当然是单例。只是语法上为了关系结构，把它放在类中定义。 另外，静态成员也遵循访问控制权限。 派生类的声明不能包含派生列表，直接class Bulk_quote;就行了。 C++11可以定义一种不允许其他类继承的类。 1class NoDerived final&#123;/* */&#125;; //NoDerived不能做基类 嗯，C++居然反向抄袭了java。 类型转换与继承通常当把引用或指针绑定到一个对象时，引用或指针的类型得和对象的类型一致，或者对象类型含有一个可接受的const类型转换规则。但对于继承类来说还有一个特例，那就是可以把基类的指针或引用绑定到派生类对象上，为了实现多态。 智能指针也支持这一类型转换，所以可以将派生类对象指针存在基类智能指针之内。 从派生类向基类的类型转换只对指针或引用类型有效。 基类向派生类不存在隐式类型转换。 派生类向基类的类型转换也可能会由于访问受限而变得不可行。 虚函数对虚函数的调用在运行时被解析。派生类覆盖虚函数定义需要保证型别完全一致。 有一个例外就是虚函数在基类中如果返回基类指针或引用时，派生类中是可以返回派生类的指针或引用的，这是唯一的一个可行的型别不一致的地方，但这种不一致也有前提条件，即派生类到基类的类型转换是可访问的（不能访问受限）。 1234567891011121314151617181920212223struct B&#123; virtual void f1(int) const; virtual void f(); void f3();&#125;;//这个例子可以看出override的用处，可以直观的找出错误，没有override编译器会曲解原本的意图struct D1 : B&#123; void f1(int) const override; //正确，f1与基类型别一致 void f2(int) override; //错误，B没有该函数 void f3() override; //错误，f3不是虚函数 void f4() override; //错误，B没有f4&#125;;struct D2 : B&#123; //继承B的f2(),f3(),覆盖f1(int) void f1(int) const final; //不允许后续的其他类覆盖f1(int)&#125;;struct D3 : D2&#123; void f2(); //正确：覆盖从间接基类B继承而来的f2() void f1(int) const; //错误，D2已经声明f1为final了&#125;; 虚函数也可以声明final来阻止派生类覆盖。 回避虚函数的机制有时候不希望动态绑定，而是调用某个虚函数的特定版本，可以通过作用域运算符来实现： 1double undiscounted = baseP-&gt;Quote::net_price(42); 无论baseP实际上是啥类型，最后调用的都是Quote的net_price，这是编译时期确定的。 通常只有成员函数(或友元)的代码才需要这种hack技巧。比如派生类虚函数想要调用父类的虚函数版本。 抽象基类有时候父类指向声明一个函数接口，不想实际定义，希望由派生类来定义。C++允许这种设计，可以在virtual的基础上定义纯虚函数： 123456789class Disc_quote : public Quote&#123;public: Disc_quote() = default; Disc_quote(const std::string &amp;book, double price, std:size_t qty, double disc):Quote(book, price), quantity(qty), discount(disc) &#123;&#125; double net_price(std::size_t) const = 0;//=0表示纯虚函数protected: std::size_t quantity = 0; double discount = 0.0;&#125; 纯虚函数无需定义，=0只能出现在类内部的虚函数声明语句处。 纯虚函数也可以定义，但必须在类外部定义，大部分情况不会定义，因为这与我们的使用意图相悖。 类只要含有纯虚函数，就是一个抽象基类，抽象基类负责定义接口，后续的其他类来覆盖接口。不能创建抽象基类的对象，抽象基类需要派生类去继承。 123456class Bulk_quote : public Disc_quote&#123;public: Bulk_quote() = default; Bulk_quote(const std::string &amp;book, double price, std::size_t qty, double disc):Disc_quote(book, price, qty, disc)&#123;&#125; double net_price(std::size_t) const override;&#125;; 直接基类是Disc_quote，间接基类是Quote。各个类控制自己的构造器，构造器会递归下去，先执行根基类构造器，最后执行自身的构造。继承链的构造器形成了层的概念。 访问控制与继承protected的一个坑： 123456789101112class Base&#123;protected: int prot_mem;&#125;;class Sneaky : public Base&#123; friend void clobber(Sneaky&amp;); //可以访问Sneaky::prot_mem friend void clobber(Base&amp;); //不能访问Base::prot_mem int j; //j默认是private&#125;;void clobber(Sneaky &amp;s)&#123;s.j = s.prot_mem = 0;&#125;//clobber可以访问Sneaky的private和protected成员void clobber(Base &amp;b)&#123;b.prot_mem = 0;&#125;//clobber不能访问Base的protected成员 之所以有这种限制，是因为如果第二个用法合法的话，那么就可以通过定义一个形如Sneaky的新类来规避掉protected提供的访问保护了。 所以，派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员，而不能访问普通的基类对象中的成员。 public、private和protected1234567891011121314151617181920212223242526class Base&#123;public: void pub_mem()protected: int prot_mem;private: char priv_mem;&#125;;struct Pub_Derv : public Base&#123; int f()&#123;return prot_mem;&#125;//正确：派生类能访问protected成员 char g()&#123;return priv_mem;&#125;//错误：private成员对于派生类来说是不可访问的&#125;;struct Priv_Derv : private Base&#123; //private不影响派生类的访问权限 int f1() const&#123;return prot_mem;&#125;&#125;;struct Prot_Derv : protected Base&#123; int f1() const&#123;return prot_mem;&#125; //依然是protected&#125;Pub_Derv d1; //继承自Base的成员遵循原有的访问说明符Priv_Derv d2; //继承自Base的成员无论此前是什么权限，都变成privated1.pub_mem(); //正确：pub_mem在派生类中是public的d2.pub_mem(); //错误：pub_mem在派生类中是private的Prot_Derv d3; //继承自Base的成员如果是public，会变成protected，其他不变d3.pub_mem(); //错误，pub_mem是protected，只能成员和友元访问，外部不行 派生类向基类转换的可访问性 只有当D公有继承B时，用户代码才能使用派生类向基类的转换，如果D继承B的方式是受保护或私有继承，则用户代码不能使用该转换。 无论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换，派生类向直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。 如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的类型转换；反之，如果D继承B的方式是私有的，则不能使用。 说白了就一个规则： 对代码中某个给定节点，如果基类的公有成员是可访问的，则派生类向基类的转换就是可访问的，反之则不行。 友元关系不能继承。 class默认继承权限是private，struct是public。这一点和类成员权限很相似。 继承中的类作用域派生类的作用域位于基类作用域之内，因此才可以实现派生类访问基类成员。 如果派生类重用了基类的成员名字，那么基类的对应成员就会被隐藏。此时想要访问隐藏的成员，就要通过域运算符，这一手法类似调用特定虚函数版本。 123456789101112131415161718192021222324252627282930313233343536class Base&#123;public: virtual int fcn();&#125;;class D1 : public Base&#123;public: //隐藏基类的fcn，这个fcn不是虚函数 //D1继承了Base::fcn()的定义 int fcn(int); //形参列表与Base中的fcn不一致 virtual void f2(); //新的虚函数，在Base中不存在&#125;;class D2 : public D1&#123;public: int fcn(int); //非虚函数，隐藏了D1::fcn(int) int fcn(); //覆盖了Base的虚函数fcn void f2(); //覆盖了D1的虚函数f2&#125;;Base bobj;D1 d1obj;D2 d2obj;Base *bp1 = &amp;bobj, *bp2 = &amp;d1obj, *bp3 = &amp;d2obj;bp1-&gt;fcn(); //虚调用，运行时调用Base::fcnbp2-&gt;fcn(); //虚调用，运行时调用Base::fcnbp3-&gt;fcn(); //虚调用，运行时调用D2::fcnD1 *d1p = &amp;d1obj; D2 *d2p = &amp;d2obj;bp2-&gt;f2(); //错误，Base没有f2成员d1p-&gt;f2(); //虚调用，运行时调用D1::f2()d2p-&gt;f2(); //虚调用，运行时调用D2::f2()Base *p1 = &amp;d2obj; D1 *p2 = &amp;d2obj; D2 *p3 = &amp;d2obj;p1-&gt;fcn(42); //错误：Base中没有接受一个int的fcnp2-&gt;fcn(42); //静态绑定，调用D1::fcn(int)p3-&gt;fcn(42); //静态绑定，调用D2::fcn(int) 构造函数与拷贝控制虚析构函数这一点已经说过了，如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义行为。 1234Quote *itemP = new Quote;delete itemP; //调用Quote的析构itemP = new Bulk_quote; //静态类型与动态类型不一致delete itemP; //如果Quote析构是虚函数，则调用Bulk_quote，否则调用Quote析构 三五准则中曾言，如果类需要析构函数，往往也需要拷贝构造和赋值操作，但对虚析构函数来说不遵守该准侧。 虚析构函数将阻止合成移动操作。 合成拷贝控制与继承构造器的调用链： 合成的Bulk_quote默认构造函数运行Disc_quote的默认构造函数，后者又运行Quote的默认构造函数。 Quote的默认构造函数将bookNo成员默认初始化为空串，同时使用类内初始化值将price初始化为0。 Quote的构造函数完成后，继续执行Disc_quote的构造函数，它使用类内初始化qty和discount。 Disc_quote的构造函数完成后，继续执行Bulk_quote的构造函数，但什么具体工作也没做。 类似的，合成的Bulk_quote的拷贝构造也一样，调用Disc_quote的拷贝构造，后者又调用了Quote的拷贝构造。 如果基类的默认构造、拷贝构造、拷贝赋值运算符或析构函数是被删除的函数或不可访问，则派生类中对应的成员也将是删除的。 如果基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数是删除的，因为编译器无法销毁派生类对象的基类部分。 编译器不会合成一个删除掉的移动操作。使用=default请求一个移动操作时，如果基类中对应的操作是删除的或不可访问的，那么派生类中该函数将是被删除的，因为派生类对象的基类部分不可移动。同理，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。 如果确实需要移动操作，那就应该在基类中自己去定义，否则会因为虚析构的存在而默认被delete。 12345678910class Base&#123;&#125;;class D : public Base&#123;public: D(const D&amp; d) : Base(d) D(D&amp;&amp; d) : Base(std::move(d)) D &amp;D::operator=(const D &amp;rhs)&#123; Base::operator=(rhs); return *this; &#125;&#125;; 继承的构造函数C++11可以让派生类重用基类定义的构造函数。 12345class Bulk_quote : public Disc_quote&#123;public: using Disc_quote::Disc_quote; //继承了Disc_quote的构造函数 double net_price(std::size_t) const;&#125;; 编译器会生成形如:derived(params) : base(args)&#123;&#125;的构造函数。这里的using作用给编译器，而不是当前作用域。 using声明语句不能指定constexpr或explicit，所以它继承基类的修饰。 基类构造函数含有默认实参时，默认实参不会被继承。相反，派生类或获得多个继承的构造函数，每个构造函数分别省略掉一个含有默认实参的形参。 如果基类有好几个构造函数，则大多数情况下派生类继承所有构造函数。除了两个例外，其一是派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本。如果派生类定义的构造函数与基类构造函数具有相同的参数列表，则这些构造函数不会被继承。其二是默认、拷贝和移动构造不会被继承。它们按照正常规则来合成，游离于三界之外。 容器与继承123456vector&lt;Quote&gt; basket;basket.push_back(Quote(&quot;0-201-82470-1&quot;, 50));//正确，但是只能把对象的Quote部分拷贝给basketbasket.push_back(Bulk_quote(&quot;0-201-54858-8&quot;, 50, 10, .25));//调用Quote定义的版本cout &lt;&lt; basket.back().net_price(15) &lt;&lt; endl; 因为存放的是对象，所以类型转换上会阉割。 想要多态必须要间接访问，对容器来说也一样，我们要存放指针而不是对象。 1234vector&lt;shared_ptr&lt;Quote&gt;&gt; basket;basket.push_back(make_shared&lt;Quote&gt;(&quot;0-201-82470-1&quot;, 50));basket.push_back(make_shared&lt;Bulk_quote&gt;(&quot;0-201-54848-8&quot;, 50, 10, .25));cout &lt;&lt; basket.back()-&gt;net_price(15) &lt;&lt; endl;","categories":[],"tags":[]},{"title":"C++ primer 读书笔记 chapter 12 动态内存与智能指针","slug":"12.动态内存","date":"2021-10-20T12:32:00.000Z","updated":"2021-10-20T12:32:13.413Z","comments":true,"path":"2021/10/20/12.动态内存/","link":"","permalink":"https://wuyifff.github.io/2021/10/20/12.%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/","excerpt":"","text":"C++ primer chapter 12动态内存动态内存与智能指针C++中的动态内存管理通过一对运算符完成：new在动态内存中为对象分配空间并返回指向该对象的指针，可以选择对对象进行初始化；delete接受一个动态对象的指针，销毁该对象并释放与之关联的内存。 如果忘记释放内存，就会产生内存泄露。而如果在尚有指针引用内存的情况下释放内存，可能产生野指针的使用。 为了安全，标准库提供了两种智能指针(smart pointer)类型来管理动态对象。智能指针的行为类似常规指针，区别在于它负责自动释放所指向的对象。新标准库提供的这两种智能指针的区别在于管理底层指针的方式：shared_ptr 允许多个指针指向同一个对象；unique_ptr则独占所指向的对象。标准库还定义了名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。三者均在memory头文件中定义。 shared_ptr智能指针也是类模板（具有析构函数，在离开作用域析构阶段自动销毁）。 默认初始化： 12shared_ptr&lt;string&gt; p1; //shared_ptr，可以指向stringshared_ptr&lt;list&lt;int&gt;&gt; p2; //shared_ptr, 可以指向int的list 默认初始化的智能指针保存空指针。 使用方式类似普通指针，通过解引用返回对象。 shared_ptr与unique_ptr都支持的操作 shared_ptr&lt;T&gt; sp / unique_ptr&lt;T&gt; up 空智能指针，可以指向类型为T的对象 p 将p用作一个条件判断，若p指向一个对象，则为true *p 解引用p，获得它指向的对象 p-&gt;mem 等价于(*p).mem p.get() 返回p中保存的指针。要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了 swap(p, q) /p.swap(q) 交换p和q中的指针 shared_ptr独有的操作 make_shared&lt;T&gt;(args) 返回一个shared_ptr，指向一个动态分配的类型为T的对象。使用args初始化此对象 shared_ptr&lt;T&gt; p(q) p是shared_ptr q的拷贝；此操作会递增q中的计数器。q中的指针必须能转换为T* p = q p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0，则将其管理的原内存释放 p.unique() 若p.use_count()为1，返回true；否则返回false p.use_count() 返回与p共享对象的智能指针数量；可能很慢，主要用于调试 make_shared标准库函数是分配使用动态内存最安全的方式，在内存中创建一个对象并初始化它。定义在memory头文件中。 make_shared用其参数来构造给定类型的对象。 1234shared_ptr&lt;int&gt; p3 = make_shared&lt;int&gt;(42);//42shared_ptr&lt;string&gt; p4 = make_shared&lt;string&gt;(10, &#x27;9&#x27;);//&quot;9999999999&quot;，体现argsshared_ptr&lt;int&gt; p5 = make_shared&lt;int&gt;();//值初始化，即为0auto p6 = make_shared&lt;vector&lt;string&gt;&gt;();//更通用的定义 shared_ptr的拷贝和赋值拷贝或赋值时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象： 12auto p = make_shared&lt;int&gt;(42); //p指向的对象只有p一个引用者auto q(p); //p和q指向相同对象，此对象有两个引用者 每个shared_ptr都有一个引用计数。拷贝shared_ptr会递增计数器。用一个shared_ptr初始化另一个shared_ptr，或作为参数传递给一个函数或作为函数的返回值时，引用计数都会递增。而shared_ptr赋予其他值时或是shared_ptr被销毁时（比如局部的shared_ptr离开其作用域），计数器会递减。 一旦shared_ptr计数器变为0，它会自动释放自己管理的对象。 12345auto r = make_shared&lt;int&gt;(42); //r指向的int只有一个引用者r = q; //给r赋值，令它指向另一个地址 //递增q指向的对象的引用计数 //递减r原本指向对象的引用计数 //r原本指向对象的引用计数变为0，自动释放 shared_ptr类的自动销毁对象是通过其析构函数完成的。析构函数会递减它所指向对象的引用计数，如果引用计数变为0，shared_ptr的析构函数会销毁对象并释放空间。 如果将shared_ptr存放于容器中，一段时间过后不需要全部元素，而只使用其中一部分，应该用erase删除不再需要的元素，如此才能得以释放内存（如果没有其他的引用的话）。 程序使用动态内存通常出于以下三种原因之一： 不确定需要使用多少对象。 不确定所需对象的准确类型。 需要在多个对象间共享数据。 直接管理内存直接使用new和delete是C++的一把双刃剑。 默认情况下，动态分配的对象是默认初始化的。所以内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化。 12string *ps = new string; //初始化为空字符串int *pi = new int; //pi指向未初始化int 可以使用值初始化方式、直接初始化方式、传统构造方式（圆括号()）或新标准下的列表初始化方式（花括号&#123;&#125;）初始化动态分配的对象。 1234567int *pi = new int(1024); string *ps = new string(10, &#x27;9&#x27;);vector&lt;int&gt; *pv = new vector&lt;int&gt;&#123;0,1,2,3,4,5,6,7,8,9&#125;;string *ps1 = new string; //默认初始化，空串string *ps = new string(); //值初始化，空串int *pi1 = new int; //默认初始化，值未定义int *pi2 = new int(); //值初始化为0 对定义了构造函数的类类型来说，无论是值初始化还是默认初始化，都会调用默认构造函数。而内置类型则不同，值初始化有着良好定义的值，默认初始化则未定义。 可以用new分配const对象，返回指向const类型的指针。动态分配的const对象必须初始化。 如果动态内存被耗尽，new表达式就会失败，默认情况下new失败时会抛出类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛异常： 123//如果分配失败，new返回一个空指针int *p1 = new int; //分配失败，则new抛出std::bad_allocint *p2 = new (nothrow) int; //如果分配失败，则new返回一个空指针 后者的new形式称为定位new。定位new表达式可以传递额外的参数，这里传递了一个标准库定义的名为nothrow的对象，意为不要抛出异常。 nothrow和bad_alloc定义在new头文件中。 释放内存通过delete表达式。 1delete p; //p必须指向一个动态分配的对象或是一个空指针 释放并非new分配的内存，或者将相同的指针值释放多次，行为是未定义的： 1234567int i, *pi1 = &amp;i, *pi2 = nullptr;double *pd = new double(33), *pd2 = pd;delete i; //错误：i不是指针delete pi1; //未定义：pi1指向一个局部变量delete pd; //正确delete pd2; //未定义：pd2指向的内存已经被释放了delete pi2; //正确：释放空指针总是没有错误的 new出来的const对象也可以delete，尽管对象本身不能改变。 shared_ptr和new的联用new返回的指针可以初始化智能指针，智能指针的构造函数是explicit的，因此必须使用直接初始化形式： 12shared_ptr&lt;int&gt; p1 = new int(1024); //错误：必须使用直接初始化shared_ptr&lt;int&gt; p2(new int(1024)); //正确：使用了直接初始化 默认情况下，用来初始化智能指针的内置指针必须指向动态内存，因为智能指针默认使用delete释放它所管理的对象。如果要将智能指针绑定到一个指向其他类型资源的指针上，就必须提供自定义操作来代替delete。 定义和改变shared_ptr的其他方法 shared_ptr&lt;T&gt; p(q) p管理内置指针q所指向的对象；q必须指向new分配的内存，且能够转换为T*类型 shared_ptr&lt;T&gt; p(u) p从unique_ptr u那里接管了对象的所有权；将u置为空 shared_ptr&lt;T&gt; p(q, d) p接管了内置指针q所指向的对象的所有权。q必须能转为T*类型。p将使用可调用对象d来代替delete shared_ptr&lt;T&gt; p(p2, d) p是shared_ptr p2的拷贝，唯一的区别是p将用可调用对象d来代替delete p.reset() 置p为空，若p是唯一指向其对象的shared_ptr，reset会释放此对象。 p.reset(q) 若传递了可选的参数内置指针q，会令p指向q，否则会将p置空。 p.reset(q, d) 若还传递了参数d，将会调用d而不是delete来释放q 区分shared_ptr&lt;T&gt; p(q, d) 和 p.reset(q, d) 中参数 d 的语义 不要混合使用内置指针和智能指针。当将shared_ptr绑定到内置指针后，资源管理就应该交由shared_ptr负责。不应该再使用内置指针访问shared_ptr指向的内存。 1234567891011121314// 函数被调用时ptr被创建并初始化void process(shared_ptr&lt;int&gt; ptr)&#123; // 使用ptr&#125; // ptr离开作用域，被销毁int *x(new int(1024)); // 危险：x是一个普通指针，不是智能指针process(x); // 错误：无法转换 int* 到 shared_ptr&lt;int&gt;process(shared_ptr&lt;int&gt;(x)); // 合法，但是内存会被释放int j = *x; // 未定义的：x是悬垂指针shared_ptr&lt;int&gt; p(new int(42)); // 引用计数为1process(p); // 拷贝p会增加它的引用计数，process中引用计数为2int i = *p; // 正确：引用计数为1 智能指针的get函数返回一个内置指针，指向智能指针管理的对象。主要用于向不能使用智能指针的代码传递内置指针。使用get返回指针的代码不能delete此指针。 1234567shared_ptr&lt;int&gt; p(new int(42)); //引用计数为1int *q = p.get(); //正确：但使用q要注意，不要让它管理的指针被释放&#123; //新程序块 //未定义：两个独立的shared_ptr指向相同的内存 shared_ptr&lt;int&gt;(q);&#125; //程序块结束，q被销毁，它指向的内存被释放int foo = *p; //未定义：p指向的内存已经被释放了 花式作死的另一种用法。 永远不要用get初始化另一个智能指针或为另一个智能指针赋值。 reset可以将新指针赋予shared_ptr： 12p = new int(1024); //错误：不能将一个指针赋予shared_ptrp.reset(new int(1024)); //正确：p指向一个新对象 与赋值类似，reset会更新引用计数，如果需要的话，会释放p指向的对象。reset成员经常与unique一起用，来控制多个shared_ptr共享的对象。 123if(!p.unique()) p.reset(new string(*p)); //不是唯一用户；分配新的拷贝*p += newVal; //现在我们知道自己是唯一的用户，可以改变对象的值 智能指针和异常如果使用智能指针，即使程序块过早结束，智能指针类也能确保在内存不再需要时将其释放。 123456void f()&#123; int *ip = new int(42); //这段代码抛出异常，且在f中未被捕获 delete ip; //退出之前释放内存&#125; 标准的内存泄露。 而如果: 12345void f()&#123; shared_ptr&lt;int&gt; sp(new int(42)); //这段代码抛出异常，且在f中未捕获&#125;//函数结束时shared_ptr自动释放内存 默认情况下shared_ptr假定其指向动态内存，使用delete释放对象。创建shared_ptr时可以传递一个（可选）指向删除函数的指针参数，用来代替delete。这个删除器(deleter)函数必须能够完成对shared_ptr中保存的指针进行释放的操作。 12345678910111213141516struct destination; struct connection; connection connect(destination*); void disconnect(connection); void end_connection(connection *p)&#123; disconnect(*p);&#125;void f(destination &amp;d /* 其他参数 */)&#123; connection c = connect(&amp;d); shared_ptr&lt;connection&gt; p(&amp;c, end_connection); // 使用连接 // f退出时（即使是异常退出），connection会被正确关闭&#125; ==智能指针规范：== 不使用相同的内置指针值初始化或reset多个智能指针。 不释放get返回的指针。 ==不使用get初始化或reset另一个智能指针。== 使用get返回的指针时，如果最后一个对应的智能指针被销毁，指针就无效了。 使用shared_ptr管理并非new分配的资源时，应该传递删除函数。 unique_ptr与shared_ptr不同，同一时刻只能有一个unique_ptr指向给定的对象。当unique_ptr被销毁时，它指向的对象也会被销毁。 make_unique函数（C++14新增，定义在头文件memory中）在动态内存中分配一个对象并初始化它，返回指向此对象的unique_ptr。 123unique_ptr&lt;int&gt; p1(new int(42));// C++14 C11没有make_uniqueunique_ptr&lt;int&gt; p2 = make_unique&lt;int&gt;(42); 由于unique_ptr独占其指向的对象，因此unique_ptr不支持普通的拷贝或赋值操作。 unique_ptr操作 unique_ptr&lt;T&gt; u1 空unique_ptr，可以指向类型为T的对象。u1会使用delete来释放它的指针；u2会使用一个类型为D的可调用对象来释放它的指针 unique_ptr&lt;T, D&gt; u2 unique_ptr&lt;T, D&gt; u(d) 空unique_ptr，指向类型为T的对象，用类型为D的对象d代替delete u = nullptr 释放u指向的对象，将u置空 u.release() u放弃对指针的控制权，返回指针，并将u置空 u.reset() 释放u指向的对象 u.reset(q) 如果提供了内置指针q，令u指向这个对象，否则u置空 u.reset(nullptr) unique_ptr不能拷贝或赋值，但可以转移：(release 和 reset) 12345678//将所有权从p1转移给p2unique_ptr&lt;string&gt; p2(p1.release()); //release将p1置空unique_ptr&lt;string&gt; p3(new string(&quot;Trex&quot;)); //将所有权从p3转移给p2p2.reset(p3.release()); //reset释放了p2原来指向的内存p2.release(); //错误：p2不会释放内存，而且我们弄丢了指针auto p = p2.release(); //正确，但我们必须记得delete(p) 不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr。 1234unique_ptr&lt;int&gt; clone(int p)&#123; //正确：从int*创建一个unique_ptr&lt;int&gt; return unique_ptr&lt;int&gt;(new int(p));&#125; 还可以返回一个局部对象的拷贝： 12345unique_ptr&lt;int&gt; clone(int p)&#123; unique_ptr&lt;int&gt; ret(new int(p)); //... return ret;&#125; 类似shared_ptr，默认情况下unique_ptr用delete释放其指向的对象。unique_ptr的删除器同样可以重载，但unique_ptr管理删除器的方式与shared_ptr不同。定义unique_ptr时必须在尖括号中提供删除器类型。创建或reset这种unique_ptr类型的对象时，必须提供一个指定类型的可调用对象（删除器）。 123456789//p指向一个类型为objT的对象，并使用一个类型为delT的对象释放objT对象//它会调用一个名为fcn的delT类型对象unique_ptr&lt;objT, delT&gt; p(new objT, fcn);void f(destination &amp;d/* 其他参数 */)&#123; connection c = connect(&amp;d); unique_ptr&lt;connection, decltype(end_connection)*&gt; p(&amp;c, end_connection);&#125; weak_ptrweak_ptr是一种不控制所指向对象生存期的智能指针，它指向一个由shared_ptr管理的对象。将weak_ptr绑定到shared_ptr不会改变shared_ptr的引用计数。如果shared_ptr被销毁，即使有weak_ptr指向对象，对象仍然有可能被释放。 weak_ptr weak_ptr&lt;T&gt; w 空weak_ptr可以指向类型为T的对象 weak_ptr&lt;T&gt; w(sp) 与shared_ptr sp指向相同对象的weak_ptr。T必须能转换为sp指向的类型 w = p p可以是一个shared_ptr或一个weak_ptr。赋值后w与p共享对象 w.reset() w置空 w.use_count() 与w共享对象的shared_ptr的数量 w.expired() 若w.use_count()为0，返回true，否则返回false w.lock() 如果expired为true，返回空shared_ptr；否则返回一个指向w的对象的shared_ptr 创建一个weak_ptr时，需要使用shared_ptr来初始化它。 12auto p = make_shared&lt;int&gt;(42);weak_ptr&lt;int&gt; wp(p); // wp弱共享p，p引用计数不变 由于对象可能不存在，所以weak_ptr访问对象前，要先lock： 123if(shared_ptr&lt;int&gt; np = wp.lock())&#123;//np不为空则条件成立 ...&#125; 动态数组new和数组数组是个很特别的存在，对于数组的动态分配和释放C++定义了相应的手法。 new []1int *pia = new int[get_size()]; // pia指向第一个int，调用get_size确定分配多少个int 方括号中的大小必须是整型，但不一定非要常量。 12typedef int arrT[42];int *p = new arrT; //实际上还是用的new[]而非new new返回的是一个元素类型的指针，指向第一个分配的成员。 C++中，动态数组不是数组类型，所以begin或end是不可以使用的，也不能用范围for语句来处理动态数组。 默认情况下，new分配的对象是默认初始化的。可以对数组中的元素进行值初始化，方法是在大小**后面跟一对空括号()**。在新标准中，还可以提供一个元素初始化器的花括号列表。如果初始化器数量大于元素数量，则new表达式失败，不会分配任何内存，并抛出bad_array_new_length异常。 12345678int *pia = new int[10]; // 10个未初始化的intint *pia2 = new int[10](); // 10个值初始化为的intstring *psa = new string[10]; // 10个空stringstring *psa2 = new string[10](); // 10个空string//10个int分别用列表中对应的初始化器初始化int *pia3 = new int[10] &#123; 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;;//10个string，前4个用给定的初始化器初始化，剩余的进行值初始化string *psa3 = new string[10] &#123; &quot;a&quot;, &quot;an&quot;, &quot;the&quot;, string(3,&#x27;x&#x27;) &#125;; 虽然可以使用空括号对new分配的数组元素进行值初始化，但不能在括号中指定初始化器。这意味着不能用auto分配数组。 动态分配一个空数组是合法的，此时new会返回一个合法的非空指针。对于零长度的数组来说，该指针类似尾后指针，不能解引用。 delete []对应new[]，使用==delete[]==释放动态数组。 12delete p; //p必须指向一个动态分配的对象或空delete [] pa; //pa必须指向动态分配的数组或空 数组中元素按逆序销毁。如果忽略了方括号，那么行为未定义。 123typedef int arrT[42];int *p = new arrT;delete [] p; //这个方括号是必须的。 智能指针和动态数组unique_ptr可以直接管理动态数组，**定义时需要在对象类型后添加一对空方括号[]**。 12unique_ptr&lt;int[]&gt; up(new int[10]);up.release(); //自动使用delete []来销毁指针 指向数组的unique_ptr的操作有些不同： 指向数组的unique_ptr unique_ptr&lt;T[]&gt; u u可以指向一个动态分配的数组，数组元素类型为T unique_ptr&lt;T[]&gt; u(p) u指向内置指针p所指向的动态分配的数组。p必须能转换为类型T* u[i] 返回u拥有的数组中i处的对象，u必须指向一个数组 指向数组的unique_ptr不支持成员访问运算符(.和-&gt;)。 shared_ptr不直接支持管理动态数组，如果希望使用shared_ptr管理动态数组，必须提供自定义的删除器： 12shared_ptr&lt;int&gt; sp(new int[10], [](int *p)&#123;delete[] p;&#125;);sp.reset(); //使用我们提供的lambda释放数组，它使用delete [] 如果未提供删除器，则代码是未定义的。 shared_ptr不支持下标运算符，且不支持指针的算数运算，所以需要借助get。 123for(size_t i=0;i!=10;++i)&#123; *(sp.get() + i) = i; //使用get获取一个内置指针&#125; allocator类allocator类也是一个类模板，定义时必须指定其分配的对象类型。 12allocator&lt;string&gt; alloc; // 可以分配string的allocator对象auto const p = alloc.allocate(n); // 分配n个未初始化的string 标准库allocator类及其算法 allocator&lt;T&gt; a 定义了一个名为a的allocator对象，它可以为类型为T的对象分配内存 a.allocate(n) 分配一段原始的、未构造的内存，保存n个类型为T的对象 a.deallocate(p, n) 释放从T*指针p中地址开始的内存，这块内存保存了n个类型为T的对象；p必须是一个先前由allocate返回的指针，且n必须是p创建时所要求的大小。调用deallocate前，用户必须对每个在这块内存中创建的对象调用destroy a.construct(p, args) p必须是一个类型为T的指针，指向一块原始内存；*arg被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象 a.destroy(p) p为T*类型的指针，此算法对p指向的对象执行析构函数 allocator分配的内存是未构造的，程序需要在此内存中构造对象。新标准库的construct函数接受一个指针和零或多个额外参数，在给定位置构造一个元素。额外参数用来初始化构造的对象，必须与对象类型相匹配。 1234auto q = p; // q指向最后构造的元素之后的位置alloc.construct(q++); // *q为空字符串alloc.construct(q++, 10, &#x27;c&#x27;); // *q为ccccccccccalloc.construct(q++, &quot;hi&quot;); // *q为hi 在未构造对象前使用原始内存是错误的： 12cout &lt;&lt; *p &lt;&lt; endl; //正确：使用string的输出运算符cout &lt;&lt; *q &lt;&lt; endl; //灾难：q指向未构造的内存！ 用完对象后，需要对每个构造的元素调用destroy来销毁它们。函数destroy接受一个指针，对指向的对象执行析构函数： 12while(q != p) alloc.destroy(--q); //释放我们真正构造的string 注意只能对已构造的对象进行destroy。 destroy后的内存可以重用。 全部destroy后，可以调用deallocate来归还内存给系统。 1alloc.deallocate(p, n); 标准库还为allocator类定义了两个伴随算法，可以在未初始化内存中创建对象。 allocator算法 uninitialized_copy(b,e,b2) 从迭代器b和e指定的输入范围中拷贝元素到迭代器b2指定的未构造的原始内存中。b2指向的内存必须足够大。 uninitialized_copy_n(b,n,b2) 从迭代器b指向的元素开始，拷贝n个元素到b2开始的内存中 uninitialized_fill(b,e,t) 在迭代器b和e指定的原始内存范围中创建对象，对象的值均为t的拷贝 uninitialized_fill_n(b,n,t) 从迭代器b指向的内存地址开始创建n个对象。b必须指向足够大的未构造的原始内存 这些函数在给定目的位置创建元素，而不是由系统分配内存给它们。它们在memory头文件中。 123auto p = alloc.allocate(vi.size() * 2);auto q = uninitialized_copy(vi.begin(), vi.end(), p);//返回递增后的目的位置迭代器。uninitialized_fill_n(q, vi.size(), 42);","categories":[],"tags":[]},{"title":"C++ primer 读书笔记 chapter 7 类","slug":"7.类","date":"2021-10-19T11:02:00.000Z","updated":"2021-10-19T11:06:20.054Z","comments":true,"path":"2021/10/19/7.类/","link":"","permalink":"https://wuyifff.github.io/2021/10/19/7.%E7%B1%BB/","excerpt":"","text":"C++ primer chapter 7类类的基本思想是数据抽象（data abstraction）和封装（encapsulation）。数据抽象是一种依赖于接口（interface）和实现（implementation）分离的编程及设计技术。类的接口包括用户所能执行的操作；类的实现包括类的数据成员、负责接口实现的函数体以及其他私有函数。 定义抽象数据类型使用class或是struct关键字可以定义类类型，struct是为了兼容旧式C风格结构体，对于定义类类型来说，struct和class的唯一区别在于默认访问权限不同。 this指针成员函数通过一个名为this的隐式参数来访问调用它的对象。this是一个常量指针，无法改变this中保存的地址。 const成员函数isbn函数的参数列表后跟随了一个const关键字，这里的const是用来修改隐式this指针的类型。 默认情况下，this类型是指向类类型非常量版本的常量指针。比如Sales_data类成员函数中，this的类型是Sales_data *const。尽管this是隐式的，但它仍然需要遵守初始化规则，这就意味着我们不能把this绑定到一个常量对象上。因此，受这一限制，我们无法在一个常量对象上调用普通的成员函数。 因为this是隐式的，我们没有办法像修饰其他参数一样，去声明其为指向常量的指针，所以C++的语法只好提供实现途径——把const关键字放在成员函数的参数列表之后，此时，this就是一个指向常量的指针，这种const成员函数被叫做常量成员函数。 12345//伪代码，说明隐式this指针是如何使用的//下面的代码非法：我们不能显式地定义自己的this指针//此处的this是一个指向常量的指针，因为isbn是一个常量成员std::string Sales_data::isbn(const Sales_data *const this)&#123;return this-&gt;isbn;&#125; 因为this指向常量，所以常量成员函数不能改变调用它的对象的内容。只读不可写。 外部定义成员函数注意需要加作用域运算符，否则谁知道你定义的是谁的成员。 为了实现连续调用链，可以令成员函数返回this对象本身： 123456Sales_data &amp;Sales_data::combine(const Sales_data &amp;rhs)&#123; units_sold += rhs.units_sold; revenue += rhs.revenue; return *this; // 返回调用该函数的对象&#125; 辅助函数类的作者往往还需要定义一些辅助函数，这些函数不作为类的成员函数，但也作为类的接口的一部分。 12345678910111213istream &amp;read(istream &amp;is, Sales_data &amp;item)&#123; double price = 0; is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price; item.revenue = price * item.units_sold; return is;&#125;ostream &amp;print(ostream &amp;os, const Sales_data &amp;item)&#123; os &lt;&lt; item.isbn() &lt;&lt; &quot; &quot; &lt;&lt; item.units_sold &lt;&lt; &quot; &quot; &lt;&lt; item.revenue &lt;&lt; &quot; &quot; &lt; item.avg_price(); return os;&#125; 构造函数每个类都定义了对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫构造函数。构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。 ==构造函数的名字和类名一致，没有返回类型==，构造函数可以重载，不能被声明成const（因为创建一个const对象时，会先调用构造函数，再得到const属性）。 合成的默认构造函数如果类不定义任何构造函数，编译器会提供一个没有任何实参的默认构造函数。编译器创建的构造函数也叫合成的默认构造函数。 合成的默认构造函数完成以下任务： 如果存在类内的初始值，用它来初始化成员。 否则，默认初始化该成员。 一旦定义了一个构造函数，那么编译器不再合成默认构造函数，即使我们定义的构造函数并不是没有参数的默认构造函数。 123456789struct Sales_data&#123; Sales_data() = default; Sales_data(const std::string &amp;s):bookNo(s)&#123;&#125; Sales_data(const std::string &amp;s, unsigned n, double p):bookNo(s), units_sold(n), revenue(p*n)&#123;&#125; Sales_data(std::istream &amp;); std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;&#125;; =default是C11引入的， 用于显式要求编译器合成默认构造函数（因为定义了其他构造函数，编译器不会自动合成默认构造函数，但我们又想要编译器提供的默认构造函数，所以这是一种偷懒的语法糖）。 =default可以出现在类的内部，也可以出现在外部，内部意味着inline。 紧跟在构造函数参数列表之后在花括号之前的部分是初始值列表。它负责为新创建的对象的一个或几个数据成员赋初值。被忽略的成员则将以合成默认构造函数相同的方式隐式初始化。 C++的编译器并不都支持类内初始值。为了可移植性，最好用初始值列表。 拷贝、赋值和析构除了构造函数以外，类还有3个特殊的成员函数：拷贝构造、赋值操作和析构。 拷贝构造会在拷贝初始化变量和值传递方式传递或返回一个对象时被调用。 赋值操作则在对类对象使用赋值运算符时会被调用。 而析构函数则在对象被销毁时被调用。 与构造函数类似，如果不去定义这3个成员，编译器也会默认合成。关于这一议题，后面第13章会单独讲解。 访问控制与封装C++用访问说明符加强了类的封装性： 定义在public说明符之后的成员在整个程序内都可以被访问，public成员定义类的接口。 定义在private说明符之后的成员仅可以被类的内部成员函数访问，外部代码无法访问，private封装了类的实现细节。 struct的默认访问权限是public，class的默认访问权限是private。 友元加上了权限之后，一些外部接口函数就无法访问类的private成员，这种情况要么提供public接口，要么就使用友元。 123456class Sales_data&#123; friend Sales_data add(const Sales_data&amp;, const Sales_data&amp;); friend std::istream &amp;read(std::istream&amp;, Sales_data&amp;); friend std::ostream &amp;print(std::ostream&amp;, const Sales_data&amp;); ...&#125; friend关键字用于表示这三个函数是类Sales_data的友元函数，如此这三个函数可以访问类的private成员。friend相当于白名单，除了友元函数以外，还可以定义友元类。 12345class Screen&#123; // Window_mgr的成员可以访问Screen类的private成员 friend class Window_mgr; ...&#125; 每个类负责控制自己的友元类和友元函数。 有时候整个类作为友元比较冒险，可以只对类的几个成员函数声明为友元： 12345class Screen&#123; // Window_mgr::clear必须在Screen类之前被声明 friend void Window_mgr::clear(ScreenIndex); ...&#125; 但是要注意声明的前后关系 类的其他特性在外部定义的成员函数也可以通过inline关键字来显式内联。 成员函数也是可以重载的。 可变数据成员使用关键字mutable可以声明可变数据成员（mutable data member）。可变数据成员永远不会是const的，即使它在const对象内。因此const成员函数可以修改可变成员的值。 12345678910111213class Screen &#123;public: void some_member() const;private: mutable size_t access_ctr; // may change even in a const object // other members as before&#125;;void Screen::some_member() const&#123; ++access_ctr; // keep a count of the calls to any member function // whatever other work this member needs to do&#125; 类内初始值花括号初始化类内初始值除了=初始化形式以外，还可以用花括号形式（C++11）： （对screens对象列表初始化）（类内初始值的两种初始化方式） 12345class Window_mgr&#123;private: //默认情况下，一个Window_mgr包含一个标准尺寸的空白Screen std::vector&lt;Screen&gt; screens&#123;Screen(24, 80, &#x27; &#x27;)&#125;;&#125; 为什么要返回*this12345//返回引用成为左值myScreen.move(4,0).set(&#x27;#&#x27;);//返回的是拷贝,只能改变临时副本Screen temp = myScreen.move(4,0);temp.set(&#x27;#&#x27;) const成员函数以引用形式返回*this，则它的返回类型将是常量引用。 成员函数可以基于const重载12345678910class Screen&#123;public: Screen &amp;display(std::ostream &amp;os) &#123;do_display(os);return *this;&#125; //非常量版本调用do_display时，this指针将隐式的从指向非常量的指针转换成指向常量的指针 const Screen &amp;display(std::ostream &amp;os) const &#123;do_display(os);return *this;&#125;private: void do_display(std::ostream &amp;os) const &#123;os &lt;&lt; contents;&#125;&#125;; 因为非常量版本的函数对于常量对象是不可用的，所以只能在常量对象上调用const成员函数。尽管明面上参数列表相同，但实际上隐式的this指针类型是不同的，区别在于是否有底层const。 当我们在对象上调用display()时，该对象是否const决定了应该调用display的哪个版本。 友元 允许特定的非成员函数访问一个类的私有成员. 友元的声明以关键字 friend开始。 friend Sales_data add(const Sales_data&amp;, const Sales_data&amp;);表示非成员函数add可以访问类的非公有成员。 通常将友元声明成组地放在类定义的开始或者结尾。 类之间的友元： 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。 友元不具有传递性 声明重载函数为友元必须指明参数 可以把另一个类的公有成员函数声明为自己的友元函数。 必须按照三步走，很容易出错。（前向声明、不完全类型） 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;class B; //提前引用声明，因为友元A中要用到B，必须让编译器知道B为一个类class A&#123; public: void disp(B &amp;b); //只能声明不能定义，因为类B内部还没有定义&#125;;class B&#123; private: int val; public: friend void A::disp(B &amp;b); //声明友元函数&#125;;//这时候才可以去定义友元函数void A::disp(B &amp;b)&#123; cout&lt;&lt;&quot;B::val=&quot;&lt;&lt;b.val&lt;&lt;endl;&#125; 类的作用域 每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由引用、对象、指针使用成员访问运算符来访问。 函数的返回类型通常在函数名前面，因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。 如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字。 类中的类型名定义都要放在一开始。 构造函数再探构造函数和初始化列表初始值列表提供了成员初始化的机会，如果在构造函数体内对成员进行赋值，那执行的就是赋值操作了（**==区分初始化和赋值==*），对于类类型来说，初始化和赋值操作可能行为不一致。 如果成员是const、引用，或者是某种未定义默认构造函数的类类型，==必须==在初始值列表中将其初始化。（因为const不能用赋值来初始化） 1234567891011class ConstRef&#123;public: ConstRef(int ii);private: int i; const int ci; int &amp;ri;&#125;;ConstRef::ConstRef(int ii): i(ii), ci(ii), ri(i) &#123; &#125; 最好令构造函数初始值的顺序与成员声明的顺序一致，并且尽量避免使用某些成员初始化其他成员。因为类成员的初始化顺序与它们在类定义中出现的顺序一致。 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。 委托构造函数C++11引入了委托构造函数： 123456789101112class Sales_data&#123;public: //非委托构造函数使用对应实参初始化成员 Sales_data(std:string s, unsigned cnt, double price):bookNo(s), units_sold(cnt), revenue(cnt*price)&#123;&#125; //该构造函数函数体为空 //其余构造函数全都委托给另一个构造函数 Sales_data():Sales_data(&quot;&quot;, 0, 0)&#123;&#125; //默认构造函数委托给第一个constructor Sales_data(std::string s):Sales_data(s, 0, 0)&#123;&#125; Sales_data(std::istream &amp;is):Sales_data()&#123;read(is, *this);&#125; //委托给默认构造函数，默认构造函数委托给第一个constructor ...&#125;; 当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数值被依次执行，然后控制权才会交还给委托者的函数体（例子中恰好函数体为空）。 默认构造函数的作用默认初始化的发生情况： 在块作用域内不使用初始值定义非静态变量或数组。 类本身含有类类型的成员且使用合成默认构造函数。 类类型的成员没有在构造函数初始值列表中显式初始化。 值初始化的发生情况： 数组初始化时提供的初始值数量少于数组大小。 不使用初始值定义局部静态变量。 通过T()形式（T为类型）的表达式显式地请求值初始化。 类必须包含一个默认构造函数以便在上述情况下使用。 隐式的类类型转换如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制（从构造函数的参数类型向类类型隐式转换）。这种构造函数被称为转换构造函数（converting constructor）。 1234string null_book = &quot;9-999-99999-9&quot;;// 构造一个临时的Sales_data对象// 该对象的units_sold和revenue等于0，bookNo等于null_bookitem.combine(null_book); 类类型转换只允许一步，这意味着： 1234//错误，需要两次转换item.combine(&quot;9-999-99999-9&quot;);//正确，显式转换为string，隐式转为Sales_dataitem.combine(string(&quot;9-999-99999-9&quot;)); 只有一个参数的构造函数，或者构造函数有n个参数，但有n-1个参数提供了默认值，这样的情况才能进行类型转换。 如果构造函数声明为explicit，就可以抑制隐式的类类型转换。同样的，需要多个实参的构造函数不能执行隐式转换，所以无须将这些构造函数指定为explicit的。 explicit关键字只允许出现在类内的构造函数声明处，不允许在类外部定义函数时重复。 c++的初始化类型 初始化类型 举例 默认初始化 例如T t; 直接（非列表）初始化 例如T t(args...); 复制（非列表）初始化 例如T t = init;） 直接列表初始化 例如T t&#123; args... &#125;; 复制列表初始化 例如T t = &#123; args... &#125;; 为什么C++的初始化规则这么复杂？ - d41d8c的回答 - 知乎 类的静态成员使用关键字static可以声明类的静态成员。静态成员可以是public的或是private的，类型可以是常量、引用、指针类类型等。静态成员存在于任何对象之外，对象中不包含与静态成员相关的数据。 12345678910111213class Account&#123;public: void calculate() &#123; amount += amount * interestRate; &#125; static double rate() &#123; return interestRate; &#125; static void rate(double); private: std::string owner; double amount; static double interestRate; static double initRate();&#125;; 静态成员实际上是全局变量，只不过通过语法的封装，让他和所属类建立了耦合的关系。 每个static数据成员是与类关联的对象，并不与该类的对象相关联。 由于静态成员不与任何对象绑定，因此静态成员函数不能声明为const，也不能在静态成员函数内使用this指针。 用户代码可以使用作用域运算符访问静态成员，也可以通过类对象、引用或指针访问。类的成员函数可以直接访问静态成员。 1234567891011121314151617181920class Account&#123;public: //成员函数无需作用域运算符即可使用静态成员 void calculate()&#123;amount += amount * interestRate;&#125; static double rate()&#123;return interestRate;&#125; static void rate(double);private: std::string owner; double amount; static double interestRate; static double initRate();&#125;;double r;r = Account::rate(); //用户代码可以使用作用域运算符访问静态成员//可以通过类对象、引用或指针访问Account ac1;Account *ac2 = &amp;ac1;r = ac1.rate();r = ac2-&gt;rate(); 在类外部定义静态成员时，不能重复static关键字，其只能用于类内部的声明语句。（在类外部定义时不用加static） 由于静态数据成员不属于类的任何一个对象，因此它们并不是在创建类对象时被定义的。通常情况下，不应该在类内部初始化静态成员。而必须在类外部定义并初始化每个静态成员。一个静态成员只能被定义一次。一旦它被定义，就会一直存在于程序的整个生命周期中。 想要保证对象只被定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一个文件中 如果一定要在类内部定义，则要求必须是字面值常量类型的constexpr","categories":[],"tags":[]},{"title":"UNIX环境高级编程 阅读笔记","slug":"apue","date":"2021-10-17T07:22:38.472Z","updated":"2021-10-17T07:38:39.541Z","comments":true,"path":"2021/10/17/apue/","link":"","permalink":"https://wuyifff.github.io/2021/10/17/apue/","excerpt":"","text":"0.tips输入输出问题 在linux系统下使用printf发现有时没有立即输出，有时又能立即输出 原因是printf使用行缓冲，没有刷新缓冲区，故没有输出。 缓冲区刷新的条件：1.进程结束。2.遇到\\n。3.缓冲区满。4.手动刷新缓冲区fflush(stdout)。 一些有用的函数&lt;stdlib.h&gt; atoi(str) 用法：将字符串里的数字字符转化为整形数。返回整形值。 注意：转化时跳过前面的空格字符，直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(’/0’)才结束转换，并将结果返回。 用于转化argv[]的参数 小知识 C/C++规定，一个数如果要指明它采用八进制，必须在它前面加上一个0（数字0），如：123是十进制，但0123则表示采用八进制。这就是八进制数在C、C++中的表达方法。（很多宏的掩码就是八进制与） 1.基础1.1what is os1.1.1内核 进程线程管理 进程管理主要为linux，windows只是壳子 内存管理 设备驱动 windows .sys文件 linux .ko文件 文件系统 中断子系统 1.1.2内核/用户态 ring0/ring3 环0内核态，环3用户态 ring1/ring2暂时没用到 系统调用 内核为应用程序提供的接口 用户态-&gt;内核态 体系结构 shell sh/bash/csh/ksh 库函数 库函数到系统调用 1.2登录1.2.1 tty/psedo-ttyTTY是电传打字机Teletypewriter的缩写，在带显示屏的视频终端出现之前，TTY是最流行的终端设备 1.2.2 /etc/password 密码可以在etc/password看到 shadow文件 起始目录 用户id 组id shell 1.3 文件1.3.1 一切皆为文件 目录 文本文件/二进制文件一视同仁 设备文件：字符设备、块设备、网络设备（在/dev下ll看第一位） socket linux与windows不同 管道、消息队列等 1.3.2 相对路径/绝对路径 / .. . 1.4 I/O 文件描述符fd stdin/stdout/stderr 对应0/1/2 1.5 进程 进程与程序的关系 进程id windows下为4的倍数（复用原因） linux下用ps命令查看 进程控制 fork 子进程都是由父进程fork出来的（写时复制） exec fork之后调用，类似windows的winexecute api waitpid 1.6 出错处理 errno windows下有geterrornumber strerror 1.7信号可以理解为用户层的中断，异步打断执行流 信号的处理 系统默认处理： 忽略/中止进程 为指定信号注册处理函数 是Linux编程重点，也容易踩坑 1.8 时间日历时间UTC time-t 进程时间clock_t 用户CPU时间 系统CPU时间 2.UNIX标准2.1 标准ISO C组成 语法、语义 标准库 ISO C历史 ANSI C89 C99 restrict long long 单行注释 分散代码与声明 C11 POSIX标准 提升各种应用程序在各种UNIX系统环境间的可移植性 只定义接口而非实现 SUS(single UNIX specification) POSIX的超集 扩展了功能 2.2 实现 FreeBSD Linux Mac OS X Solaris 2.3限制编译时限制 ISO C limits.h 各种最大最小值(宏内定义了，include直接用) float.h 浮点数相关 stdio.h POSIX 限制 运行时限制只有运行时才能拿到，例如系统调用给出 sysconf pathconf/fpathconf 3. 无缓冲I/O（文件IO）3.1 文件描述符fd 所有打开文件都由fd引用，fd为非负int（出错时为负） 类似windows的HANDLE STDIN_FILENO STDOUT_FILENO STDERR_FILENO OPEN_MAX（文件打开的极限值） 进程各自维护自己的文件描述符表，文件描述符表记录文件描述符标志，和一个指向文件表项的指针 文件表项由内核为每一个打开的文件维护，包括文件状态标志、当前文件偏移、以及指向v结点的指针 ==不同进程打开同一个文件、同一进程调用多次open同一个文件==并不共享file table entry（文件表项） 因为各自的偏移可能不同，也可以理解为调用一次open打开一个文件表项，而复制fd与之无关 但是fork出来的子进程的fd指向同一个文件表项（因为文件描述符表也copy，p397） /dev/fd /prof/self/fd 3.2 APIopen/openat/create oflag 文件状态标志 O_RDONLY O_WRONLY O_RDWR 必须指定且互斥 O_APPEND O_CLOEXEC O_CREAT O_DIRECTORY O_EXCL O_SYNC O_DSYNC O_TRUNC O_CREAT | O_EXCL 配合测试创建文件的原子性 openat的path可以为相对路径 creat只写创建，想要创建写之后再读必须close之后再open，用open实现： open(path, O_RDWR | O_CREAT | O_TRUNC, mode) close 会关闭记录锁 进程终止，内核会自动关闭文件对象 RAII的思想 lseek 当前文件偏移量 文件空洞 read 返回值 &lt; 待读字节数的情景 eof 终端设备/行缓冲 管道/FIFO 中断 write 返回值 &lt; 待写字节数的情景 磁盘满 超过了给定进程的文件长度限制 pread/pwrite原子lseek + read/write dup/dup2 新描述符的FD_CLOEXEC总是被清除 （即fd flag） dup(fd) = fcntl(fd, F_DUPFD, 0); dup2(fd) = close(fd2); fcntl(fd, F_DUPFD, fd2); //且为原子操作 dup 和 fcntl 的 errno 不同 sync/fsync/fdatasync 内核维护高速缓存 延迟写 update守护进程周期性调用sync fcntl（重点）#include&lt;fcntl.h&gt; int fcntl(int fd, int cmd, … ); 复制一个已有的描述符 F_DUPFD/F_DUPFD_CLOEXEC 获取/设置文件描述符标志**(fd flag)** F_GETFD/F_SETFD 仅有的就是FD_CLOEXEC标志 fcntl(fd, F_SETFD, 1); 默认为0，即不关闭 获取/设置文件状态标志 F_GETFL/F_SETFL ==注意GETFL与GETFD的区别== 获取/设置异步I/O所有权 F_GETOWN/F_SETOWN 获取/设置记录锁 F_GETLK/F_SETLK/F_SETLKW ioctl 设备驱动 某个特定操作的接口 类比于windows的 DeviceControl 应用程序到设备驱动的万用接口 4. 文件和目录4.1 struct statPOSIX标准 + XSI扩展定义的字段 描述一个特定文件相关的信息 linux下的struct stat st_mode 文件类型 文件类型 宏 普通文件 regular file S_ISREG() 目录文件 directory file S_ISDIR() 符号链接 symbolic link S_ISLINK() 块特殊文件 block special file S_ISCHR() 字符特殊文件 character special file S_ISBLK() FIFO 命名管道 S_ISFIFO() socket S_ISSOCK() 消息队列 S_TYPEISMQ() 信号量 S_TYPEISEM() 共享内存 S_TYPEISSHM() mode set-user-id bit S_ISUID set-group-id bit S_ISGID 进程关联ID： 实际用户/组ID 有效用户/组ID 附属组ID 文件和目录的权限位 S_ISUID：执行时设置用户ID S_ISGID：执行时设置组ID S_ISVTX：粘着位 S_IRWXU：用户读、写和执行 S_IRUSR：用户读 S_IWUSR：用户写 S_IXUSR：用户执行 S_IRWXG：组读、写和执行 S_IRGRP：用户读 S_IWGRP：用户写 S_IXGRP：用户执行 S_IRWXO：其他读、写和执行 S_IROTH：用户读 S_IWOTH：用户写 S_IXOTH：用户执行 鉴权流程 4.2 文件系统VFS superblock incode 与文件一一对应，相当于身份证号 包含文件的元数据，不包含名称 内存中的inode和磁盘中的inode 名称-&gt;inode-&gt;disk block dentry 文件的逻辑属性 一个dentry对应一个inode 多个dentry可能对应一个inode(硬链接/软链接) file object 4.3 API状态相关 stat / fstat / statat / lstat ls - l命令 注意是否跟踪符号链接 权限相关 access / faccessat 探测文件是否存在 以实际用户ID和实际组ID测试访问能力 faccessat提供了 AT_EACCESS 和 AT_SYMLINK_NOFOLLOW umask 创建新目录或文件时，屏蔽字中置1的权限都会被关闭 区分umask命令 chmod / fchmod / fchmodat S_ISUID / S_ISGID S_IRWXU / S_IRWXG / S_IRWXO S_ISVTX(粘着位在linux无效) chown / fchown / fchownat / lchown chown命令 注意符号链接的处理 变更相关 truncate / ftruncate 截断/扩充 link / linkat unlink / unlinkat 用于确保临时文件被删除 标准库的remove rename / renameat oldname 非目录 newname存在 newname不存在 oldname 为目录 newname 存在 newname 不存在 符号链接 . 和 .. 不允许 symlink / symlinkat readlink / readlinkat open的局限：不能打开link本身 mkdir / mkdirat rmdir 控制相关 opendir / fopendir readdir / rewinddir / closedir / telldir / seekdir 类比文件/标准I/O的接口 chdir / fchdir getcwd 时间相关 futimens utimensat utimes 5.标准I/O即ISO C标准I/O 5.1 流 (stream) 无缓冲I/O围绕fd展开 有缓冲I/O围绕stream展开 流的定向(stream’s orientation) 单字节 字节定向 byte flow ASCII 多字节 宽定向 wide bytes flow 国际字符集 进程预定义流 stdin / stdout /stderr 流缓冲 意义 类型 全缓冲：填满I/O缓冲区后才进行实际I/O操作 行缓冲： 输入输出遇到换行符时执行I/O操作 2. 由于每行缓冲区固定，缓冲区满没有遇到换行符也要执行I/O 3. 任何时候只要通过标准lO库，要求从一个不带缓冲的流或者一个行缓冲的流(从内核请求数据的时机）得到输入数据，那么就会冲洗所有行缓冲输出流。(即要缓冲输入，先冲洗输出缓冲) 4. 指向终端的流通常使用行缓冲 不带缓冲：不进行缓冲 stdin 和 stdout 并不指向交互设备时，才能使全缓冲类型 (通过重定向) 如果指向终端设备，则是行缓冲的，否则是全缓冲的 stderr绝不能时全缓冲的，一般是不带缓冲 表现为buffersize = 1 5.2 FILE对象 不同平台的实现不同 linux fd 用于实际I/O buffer指针 buffer尺寸 buffer当前字符数 出错标志 文件结束标志 5.3 API fwide setbuf / setvbuf p118 fflush fopen / freopen / fdopen fclose 读写 getc / fgetc / getchar / ungetc putc / fputc / putchar fgets / (gets) fputs / (puts) fread / fwrite ferror / feof / clearerr ftell / ftello / fseek / fseeko / rewind fgetpos / fsetpos 格式化输入输出 printf / fprintf / dprintf / sprintf / snprintf scanf / fscanf / sscanf fileno 标准I/O到无缓冲I/O的adapter tmpnam / tmpfile 临时文件 fmemopen 内存流 6. 系统信息6.1 数据文件 /etc/passwd pwd.h中定义了struct passwd结构 可以任意由用户读取 是ASCII文件，可以用标准I/O读取，但是效率太低 因此系统提供API接口 /etc/group grp.h中定义了struct group结构 /etc/shadow 经单向加密算法处理过的用户口令副本 shadow.h中定义了struct spwd 阴影口令文件 /etc/shadow 不应该由一般用户读取 仅有少数几个程序需要访问加密口令,如login, passwd, 这些程序通常是设定 set-user-ID为root的程序 6.2 API6.2.1 数据文件 getpwuid / getpwnam getpwent / setpwent / endpwent getspnam / getspent / setspent / endspent getgrgid / getgenam getgrent / setgrent / endgrent getgroups / setgroups / initgroups 返回的结构都是一个静态变量，会覆盖前一次的结果，数据文件的API都提供了 get / set / end 组合技 6.2.2 系统信息 uname struct utsname gethostname time 日历时间 clock_gettime 获取指定的时钟类型的时间 实时系统时间 不带负跳数的实时系统时间 调用进程的CPU时间 调用线程的CPU时间 clock_getres 时间精度调整 clock_settime 对特定的时钟设置时间（某些需要权限） gettimeofday (deprecate) gmtime / localtime 日历时间转换为struct tm 结构 mktime strftime / strftime_l 格式化时间，打印字符串 strptime 7. 进程环境7.1概念1进程终止 从main返回 exit(main(argc, argv)) return 和 exit(0) 并无区别 exit()库函数 _exit / _Exit 系统调用 这两者区别： 不同标准定义 、是否做了清理工作 2 终止处理程序 atexit函数 事先声明，反向调用，类似栈 3 命令行参数 argc argv envp 环境表 全局变量 environ 函数 getenv / putenv 一般调用函数获取环境，而非读取environ 进程地址空间 .text / .data / .bss / stack / heap / others (so , debug , systab ) 4 跨越函数跳转 setjmp / longjmp 靠返回值val与正常函数调用区分 5 进程资源限制 getrlimit / setrlimit 7.2 API exit / _Exit / _exit atexit getenv / putenv / setenv / unsetenv / clearenv setjmp / longjmp 8. 进程控制8.1 概念进程ID 循环复用 特殊的进程ID swapper：0 内核交换进程 init：1 普通用户进程 超级用户特权 所有孤儿进程的父进程 进程的创建一次调用两次返回 父进程中返回创建的子进程ID 子进程返回0 getppid ( get parent id) 获取父进程ID 父子进程谁先执行不确定 子进程是父进程的副本 拷贝数据空间、堆、栈 COW （copy on write）写时复制 试图修改时才真正拷贝 fork + exec 从中受益 代码段共享 （只读） 拷贝文件描述符表 继承父进程相关属性 实际用户ID、实际组ID、有效用户ID、有效组ID 附属组ID 进程组ID 会话ID 控制终端 设置用户ID标识和设置组ID标识 当前工作目录 根目录 文件模式创建屏蔽字 信号屏蔽和安排 对任一打开文件描述符的执行时关闭(close-on-exec)标识 环境变量 连接的共享存储段 存储映像 资源限制 父子进程的不同之处 ID / PID 子进程tms_utime/tms_stime/tms_cutime/tms_ustime被清零 子进程不继承父进程文件锁 子进程未处理闹钟将被清除 子进程未处理信号集设置为空集 父子进程的生死交互子进程先于父进程终止 通过信号SIGCHILD发送退出状态给父进程 父进程可以通过wait / waitpid获取信息 子进程ID / 子进程终止状态 / CPU耗时 未善后的终止子进程为僵死进程（zombie） 父进程先于子进程终止 子进程父亲改为init 进程（pid 1） init进程会调用wait善后处理终止的子进程（防止全是zombie） wait / waitpid 如果所有子进程都还在运行，则阻塞 如果一个子进程终止，正等待父进程获取其终止状态，则取得终止状态立即返回（zombie状态也立即返回） 如果没有任何子进程则出错返回 waitpid功能补充 支持异步（需要设置options参数） 可选择性等待某个进程 ​ pid == -1 / 0 / &gt;0 / &lt;-1 更灵活的wait系列函数 exec族函数 更进一步的封装 popen system fork -&gt; exec -&gt; waitpid 权限 实际用户 / 组ID 有效用户 / 组ID setuid / setgid 进程拥有超级权限，二话不说直接改实际用户/组ID、有效用户/组ID为指定ID 如果没有超级权限，但是uid或gid设置为实际用户/组ID或保存的设置用户/组ID， 则只将有效用户/组ID改为指定ID 不满足前两条，通通返回错误(ret = -1, error = EPERM) 解释器文件 解释型语言源文件起始行标注 进程调度 优先级 nice 0~2*NZERO-1 sysconf获取 越大越低 getpriority setpriority 进程时间 时钟时间 用户CPU时间 系统CPU时间 times 8.2 API getpid getppid getuid geteuid getgid getegid fork vfork wait waitpid waitid wait3/wait4 execl execv execle execve execlp execvp fexecve setuid/setgid seteuid/setegid system nice getpriority/setpriority times 9. 进程关系9.1 概念终端 tty1-6 CTRL ALT F1-6 图形终端 ALT F7 pseudo tty（pty） 网络终端 进程组（作业job） 唯一标志ID getpgrp / getpgid setpgid 进程只能为自己和它的子进程设置进程组ID 唯一标志ID和组长的PID一致 多个进程的集合，每个进程都有所属的进程组 同一进程组的所有进程接受同一终端的各种信号 孤儿进程组 每个成员的父亲要么在本组，要么在其他会话中 会话 可以有0或一个控制终端（tty / pseudo tty) 建立与控制终端连接的会话首进程被称为控制进程 无控制终端可能为守护进程 一个到多个进程组的集合 一个前台进程 这意味着会话有一个控制终端 接受 ctrl c / ctrl \\ 产生的 SIGINT / SIGQUIT 信号 n个后台进程组 新建会话 setsid 该进程变成新会话的会话首进程 (session leader) 此时该 leader 是会话中的唯一进程 这意味这要新建会话 要先 fork 再 setsid 这就保证了进程不是进程组的组长 该进程成为一个新进程组的组长进程 新进程组ID是调用进程的进程ID 也是会话ID 该进程没有控制终端 如果调用 setsid 前有控制终端，则切断联系 作业控制 9.2 API getpgrp / getpgid / sepgid setsid / getsid tcgetpgrp / tcsetpgrp / tcgetsid 10. 信号10.1 概念异步事件 信号的产生是不定时的，随机的 可以简单理解为用户态的中断（软中断） 产生信号的方式 用户按键产生（ctrl C） 硬件异常产生 进程或者用户调用kill 但检测到某种软性条件已经发生，通知有关进程 SIGURG / SIGPIPE / SIGALARM / SIGABRT 进程处理信号的方式 忽略 ignore 大多数信号的默认处理方式 SIGKILL / SIGSTOP 不能被忽略 由硬件异常导致的信号最好不要被忽略 中断允许嵌套，但是一般终端过程中同一个中断会忽略 捕捉 catch 注册一个signal handler 信号到来时会打断当前执行流，转而去执行handler 不能捕捉SIGKILL / SIGSTOP 执行默认动作 函数 signal / sigaction 子进程继承了父进程处理信号的方式 被中断的系统调用 低速系统调用 可能会使进程永久阻塞的一类 出错返回 errno EINTR 自动重新启动的系统调用 ioctl read/readv write/writev wait/waitpid 可重入函数 异步信号安全 不可重入的情况 static静态变量 global全局变量 调用了不可重入函数 malloc是线程安全的（递归锁），但是维护共享内存，故是不可重入的 可靠信号 未决的 pending产生信号和送达之间 信号屏蔽字 signal mask （signal procmask） 进程可以阻塞某种信号递送sigpending 保持未决状态 直到进程接触阻塞或设置为忽略才送达 阻塞期间同一个信号触发多次（是否排队：sigqueue） sigsuspend 解除了 使用 sigprocmask 和 pause 组合 的原子性问题 信号集 sigset_t 相关api ： sigemptyset / sigfillset / sigaddset / sigdelset / sigismember 与 sigprocmask 相配合 递送信号 kill / raise 库函数 kill命令 定时器 alarm：SIGALARM 默认动作为终止进程 一个进程只能有一个定时器 睡眠 sleep / nanosleep / clock_nanosleep 进程控制的延申 信号做父子进程的同步 加入信号处理的system实现 非局部跳出（deprecated） sigsetjmp / siglongjmp 对比 setjmp / longjmp handler自动屏蔽某种信号 跳走后无法保存信号屏蔽字 10.2 API signal kill / raise alarm pause sigemptyset / sigfillset / sigaddset / sigdelset / sigismember sigprocmask / sigpending sigsetjmp / siglongjmp sigsuspend 信号屏蔽字被设置为sigmask指向的值然后挂起，在捕捉一个信号之后返回恢复原来的sigmask abort 11. 线程11.1 进程与线程的概念 进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位） 进程有自己的独立地址空间，线程是共享进程的地址空间 线程之间通信更方便，进程则要通过各种IPC机制 多进程更加健壮，一个进程异常挂掉不会导致其他进程挂掉 11.2 多线程与多核 单核也可以多线程 多核多线程可以达成同时run的效果 11.3 pthread标准 POSIX 线程 LinuxThreads的变化（NPTL） 11.4 线程信息以下不共享 线程ID pthread_t / pthread_equal / pthread_self 栈 信号屏蔽字 调度优先级 errno变量 线程私有数据 11.5 线程的生与死线程创建 pthread_create 线程创建不能保证哪个线程会先运行 线程继承调用线程的浮点环境和信号屏蔽字 但是 pending 信号集会被清除 线程终止 导致进程终止 任意线程调用 exit / _exit / _Exit 发送给线程的信号（默认终止进程） 单一线程终止 线程从启动历程返回 pthread_join / pthread_datch 线程被同一进程的其他线程取消 pthread_cancel 线程调用 pthread_exit 线程清理处理程序 pthread_cleanup_push / pthread_cleanup_pop 清理情况： 主动调用 pthread_exit 响应 pthread_cancel 调用 pthread_cleanup_pop 参数不为0的时候 直接 return 并不会执行清理 执行顺序与注册顺序相反 11.6 进程与线程原语 进程原语 线程原语 描述 fork pthread_create 创建新的控制流 exit pthread_exit 从现有的控制流中退出 waitpid pthread_join 从控制流中得到退出状态 atexit pthread_cancel_push 注册在退出控制流时调用的函数 getpid pthread_self 获取控制流的ID abort pthread_cancel 请求控制流的非正常退出 11.7 线程同步、一致性问题原子操作互斥锁 POSIX互斥量 struct pthread_mutex_t 初始化/销毁 pthread_mutex_init / pthread_mutex_destory 上锁 pthread_mutex_lock / pthread_mutex_timedlock / pthread_mutex_trylock / pthread_mutex_unlock 解锁 pthread_mutex_unlock 死锁 AB型死锁 解决方法： 按序获取锁（程序复杂） trylock / timedlock 读写锁(共享互斥锁) 状态 读锁：读请求 pass ，写请求阻塞直到读锁释放（共享锁） 引用计数实现 注意写请求的饥饿情况，通常写请求后的读请求被阻塞（FIFO) 写锁：阻塞任何的加锁请求（互斥锁） 无锁 一次只有一个线程可以占有写锁，可以有多个线程同时占有读锁 适用于读请求&gt;&gt;写请求的情况 POSIX读写锁 初始化 / 销毁 pthread_rwlock_init / pthread_rwlock_destroy 读锁 pthread_rwlock_rdlock / pthread_rwlock_tryrdlock / pthread_rwlock_timedrdlock 写锁 pthread_rwlock_wrlock / pthread_rwlock_trywrlock / pthread_rwlock_timedwrlock 解锁 pthread_rwlock_unlock 条件变量 配合互斥量使用，提供多线程会合的时间点 初始化 / 销毁 pthread_cond_init / pthread_cond_destroy 等待条件变量变为true pthread_cond_wait / pthread_cond_timedwait 条件变量置信 pthread_cond_signal 唤醒一个 / pthread_cond_broadcast 唤醒所有 自旋锁 spinlock 特征：忙等阻塞 锁持有时间段，线程不希望被调度 用户态基本不使用自旋锁 不要调用在持有自旋锁的情况下可能会进入休眠状态的函数 屏障 barrier 协调多个进程并行工作 每个线程等待，直到所有线程共同达到某一点 初始化 / 销毁 pthread_barrier_init / pthread_barrier_destory 等待 pthread_barrier_wait 未满足屏障计数时阻塞 、满足屏障计数时唤醒所有（最后一个线程） 12. 线程控制12.1 属性pthread遵循的对于属性的模式 每个对象都和自己类型的属性对象相关联（互斥量与互斥量属性相关联，线程与线程属性相关联），表现为 attr 指针，每个属性对象可以代表多个属性。属性对应用不透明，便于提高可移植性，因此需要函数来进行管理 每个属性对象有一个初始化函数，它把属性设置为默认值 还有一个销毁属性对象的函数，用于释放与属性对象的资源 获取各个属性值的函数，返回存储它的内存单元 设置属性值的函数，一般来说属性作为参数用指针传递 线程属性 初始化 / 销毁 pthread_attr_init / pthread_attr_destory 线程分离状态属性(分离线程的资源在线程终止时立即收回，无法用 join 等待其终止状态) pthread_attr_getdetachstate / pthread_attr_setdetachstate 以下不建议用 pthread_attr_getguardsize / pthread_attr_setguardsize pthread_attr_getstacksize / pthread_attr_setstacksize pthread_attr_getstack / pthread_attr_setstack 取消状态（取消点）不建议用 PTHREAD_CANCEL_ENABLE / PTHREAD_CANCEL_DISABLE pthread_setcancelstate 被取消线程在调用点会感知到取消 (pthread_cancel调用方不等待) 默认情况延迟取消 同步属性互斥量属性 pthread_mutexattr_t共享属性、健壮属性、类型属性 pthread_mutexattr_init / pthread_mutexattr_destroy 以下不建议使用 进程共享(内核开销大，不属于NPTL) pthread_mutexattr_getpshared / pthread_mutexattr_setpshared 健壮属性 类型属性 pthread_mutexattr_gettype / pthread_mutexattr_settype 互斥量类型 递归上锁 不占用时解锁 已解锁时解锁 PTHREAD_MUTEX_NORMAL 死锁 未定义 未定义 PTHREAD_MUTEX_ERRORCHECK 返回错误 返回错误 返回错误 PTHREAD_MUTEX_RECURSIVE 允许 返回错误 返回错误 PTHREAD_MUTEX_DEFAULT 未定义 未定义 未定义 递归锁的使用场景 读写锁属性 pthread_rwlockattr_t pthread_rwlockattr_init / pthread_rwlockattr_destroy pthread_rwlockattr_getpshared / pthread_rwlockattr_setpshared 条件变量属性 pthread_condattr_t pthread_condattr_init / pthread_condattr_destroy pthread_condattr_getpshared / pthread_condattr_setpshared 屏障属性 pthread_barrierattr_t pthread_barrierattr_init / pthread_barrierattr_destroy pthread_barrierattr_getpshared / pthread_barrierattr_setpshared 12.2 重入概念 如果一个函数对多个线程来说时可重入的，就说这个函数是线程安全的。但并不能说明对信号处理程序来说该函数也是可重入的。 如果函数对于异步信号处理程序的重入是安全的，那么可以说函数是异步信号安全的 重入的要求高于线程安全 可重入要求信号安全 一般来说： 如果一个函数的实现使用了全局或者静态变量，且访问未加锁，那么这个函数既不是可重入的，也不是线程安全的。 如果放宽条件，这个函数仍然用到了全局或者静态变量，但是在访问这些变量时，通过加锁来保证互斥访问，那么这个函数就可以变成线程安全的函数。但它此时仍然是不可重入的，因为通常加锁是针对不同线程的访问，对同一线程可能出现问题（发生信号软中断，signal handler中恰巧也执行了该函数）。 非线程安全函数 替代的线程安全函数 12.3 线程私有数据 由于线程共享地址空间，故线程无法阻止另一个线程访问其私有数据 因此需要管理线程特定数据的函数（设计上封装隔离） pthread_key_create / pthread_key_delete 让不同线程看到同一个键值 pthread_once pthread_once_t = PTHREAD_ONCE_INIT 1234567891011121314void destructor(void *);pthread_key_t key;pthread_once_t init_done = PTHREAD_ONCE_INIT;voidthread_init(Void)&#123; err = pthread_key_create(&amp;key, destructor);&#125;intthreadfunc(void *arg)&#123; pthread_once(&amp;init_done, thread_init); ...&#125; 关联键和私有数据 pthread_getspecific / pthread_setspecific 12.4 线程和信号 线程都有自己的信号屏蔽字 线程的处理是进程中所有线程共享的 信号是传递给单个线程的 信号与硬件相关，递送给引起时间的进程 其他信号发送给任意一个进程 pthread_sigmask sigprocmask在多线程环境中行为未定义 用法类似sigprocmask sigwait等待信号出现 先阻塞等待的信号（在外部） 原子取消信号集阻塞状态 信号递送后返回 返回前恢复阻塞信号集 类比条件变量和互斥量 多个线程等待同一信号，只有一个会被唤醒 pthread_kill 给指定进程发送信号 线程与I/O lseek read 多线程有问题 pread lseek read 的原子操作 12.5 API pthread_attr_init / pthread_attr_destroy pthread_attr_getdetachstate / pthread_attr_setdetachstate pthread_key_create pthread_mutexattr_init / pthread_mutexattr_destroy pthread_mutexattr_gettype / pthread_mutexattr_settype pthread_key_create / pthread_key_delete pthread_getspecific / pthread_setspecific pthread_sigmask pthread_sigkill 13. 守护进程13.1 概念守护进程的概念 内核态守护进程（内核线程） eg： 虚拟内存换页kswapd / 脏页面冲刷 flush 用户态守护进程 由 init 拉起 setsid 使其一般是会话首进程，同时也是进程组组长、唯一进程 编写守护进程的惯例 umask 设置文件模式创建屏蔽字 通常 umask(0) 父进程 fork 并 exit 为子进程 setsid 创建会话创造条件 setsid 会话首进程 / 进程组组长 / 没有控制终端 当前工作目录改为根目录或者其他位置 chdir(“/“) 防挂在umount 关闭不用的文件描述符 首先 getrlimit 判定最高文件描述符的值，然后用循环全部关闭 打开 /dev/null 使具有文件描述符0、1、2 因为守护进程并不与终端设备相关联，无从显示也无需输入 fd0 = open(“/dev/null”, O_RDWR); 一般还需要处理 SIGHUP 信号 原因：孤儿进程 出错记录 内核例程调用log函数 用户守护进程调用 syslog 函数 本地或其他主机可通过 UDP 514端口传递log rsyslog 单例守护进程 文件记录锁 记录锁 惯例 锁通常指定在 /var/run/%name%.pid 内容一般就是pid号 配置文件通常在 /etc/%name%.conf 守护进程一般通过初始化脚本之一启动 /etc/rc* /etc/init.d/* /etc/inittab启动自动重启 一般注册 SIGHUP 处理程序 一方面使为了防止默认动作终止 功能上设置为重新读取配置 13.2 API openlog / syslog / closelog / setlog / mask vsyslog 14 进阶I/O14.1 非阻塞I/O 低速系统调用 定义：会引起进程永久阻塞 某些文件类型数据不存在，读引起永久阻塞 数据不能被相同的文件类型接受，写操作会永久阻塞 对加了记录锁的文件读写 ioctl 进程通信函数 open 先天指定 O_NONBLOCK fcntl 后天设置 O_NONBLOCK 轮询 polling + 非阻塞I/O 类似用户态的自旋锁 浪费cpu时间 多线程 + 阻塞I/O 额外的线程开销、同步开销 14.2 记录锁 recording lock 确保进程单独写文件 进程读或写文件的某个部分时，使用记录锁组织其他进程修改同一文件区 byte range locking fcntl 记录锁 struct flock 1234567struct flock&#123; short l_type; short l_whence; off_t l_start; off_t l_len; pid_t l_pid;&#125; l_type : F_GETLK / F_SETLK / F_SETLKW F_GETLK 检测上锁后上锁不是原子操作 F_SETLKW 检测到死锁后杀死另一个进程获得资源 锁的隐含继承与释放 进程终止时，建立的所有锁全部释放 关联的fd何时关闭，锁都会释放 fork 子进程只能继承文件描述符，不能继承它的锁 文件尾端加锁 建议性锁和强制性锁 14.3 异步I/O不建议用 14.4 I/O多路转接(multiplexing)问题提出 阻塞模式下在多个fd上写，一个block会导致后面的pending polling + 无阻塞可以解决 异步I/O 用信号通知 缺点在于不知道哪个fd ready（不够映射） I/O多路复用 select select / pselect pselect 支持 timespec 结构，更精确的时间 最多支持fd 有上限 poll 通过数组表明关心的条件 解决了fd数量的瓶颈 epoll linux I/O多路转接的最优机制 性能高 规避了所有fd的用户态 copy 到内核态的开销 fd常驻内核 内核以红黑树组织 内核态只回传ready 部分的fd 边沿触发 14.5 其他readv / writev 散布读(scatter read) / 聚集写(gather write) iovec 结构数组 1234struct iovec&#123; void *iov_base; size_t iov_len&#125; 降低系统调用的次数，获取性能 readn / writen apue 对 read / write 的一些容错封装 原因： 管道、FIFO、网络、终端 可能读的字节数小于指定数量 写可能因为内核缓冲区满而失效 mmap / munmap 存储映射I/O 磁盘文件映射到内存空间 直接读写内存就是修改磁盘文件 mprotect 修改映射区权限 msync 立刻同步刷新","categories":[],"tags":[]}],"categories":[],"tags":[]}