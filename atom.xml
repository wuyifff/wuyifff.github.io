<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>w1fly&#39;s blog</title>
  
  <subtitle>hello world</subtitle>
  <link href="https://wuyifff.github.io/atom.xml" rel="self"/>
  
  <link href="https://wuyifff.github.io/"/>
  <updated>2021-10-17T07:38:39.541Z</updated>
  <id>https://wuyifff.github.io/</id>
  
  <author>
    <name>wuyifff</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UNIX环境高级编程 阅读笔记</title>
    <link href="https://wuyifff.github.io/2021/10/17/apue/"/>
    <id>https://wuyifff.github.io/2021/10/17/apue/</id>
    <published>2021-10-17T07:22:38.472Z</published>
    <updated>2021-10-17T07:38:39.541Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-tips"><a href="#0-tips" class="headerlink" title="0.tips"></a>0.tips</h1><h2 id="输入输出问题"><a href="#输入输出问题" class="headerlink" title="输入输出问题"></a>输入输出问题</h2><ul><li><p>在linux系统下使用printf发现有时没有立即输出，有时又能立即输出</p><p>原因是printf使用行缓冲，没有刷新缓冲区，故没有输出。</p><p><strong>缓冲区刷新的条件：</strong><br>1.进程结束。<br>2.遇到\n。<br>3.缓冲区满。<br>4.手动刷新缓冲区fflush(stdout)。</p></li></ul><h2 id="一些有用的函数"><a href="#一些有用的函数" class="headerlink" title="一些有用的函数"></a>一些有用的函数</h2><h3 id="lt-stdlib-h-gt"><a href="#lt-stdlib-h-gt" class="headerlink" title="&lt;stdlib.h&gt;"></a>&lt;stdlib.h&gt;</h3><ul><li><p>atoi(str)</p><p>用法：将字符串里的数字字符转化为整形数。返回整形值。</p><p>注意：转化时跳过前面的空格字符，直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(’/0’)才结束转换，并将结果返回。</p><p>用于转化argv[]的参数</p></li></ul><h2 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h2><ul><li>C/C++规定，一个数如果要指明它采用八进制，必须在它前面加上一个0（数字0），如：123是十进制，但0123则表示采用八进制。这就是八进制数在C、C++中的表达方法。（<strong>很多宏的掩码就是八进制与</strong>）</li></ul><h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h1><h1 id="1-1what-is-os"><a href="#1-1what-is-os" class="headerlink" title="1.1what is os"></a>1.1what is os</h1><h2 id="1-1-1内核"><a href="#1-1-1内核" class="headerlink" title="1.1.1内核"></a>1.1.1内核</h2><ul><li><p>进程线程管理</p><p>进程管理主要为linux，windows只是壳子</p></li><li><p>内存管理</p></li><li><p>设备驱动</p><p>windows  .sys文件    linux .ko文件</p></li><li><p>文件系统</p></li><li><p>中断子系统</p></li></ul><h3 id="1-1-2内核-用户态"><a href="#1-1-2内核-用户态" class="headerlink" title="1.1.2内核/用户态"></a>1.1.2内核/用户态</h3><ul><li><p>ring0/ring3    环0内核态，环3用户态</p><p>ring1/ring2暂时没用到</p></li><li><p>系统调用 内核为应用程序提供的接口   用户态-&gt;内核态</p></li><li><p>体系结构</p><p><img src="https://i.loli.net/2021/10/07/I9bfymOhG5PSKnX.png" alt="image-20211007104949635"></p><p>shell    sh/bash/csh/ksh </p><p>库函数    库函数到系统调用</p></li></ul><h2 id="1-2登录"><a href="#1-2登录" class="headerlink" title="1.2登录"></a>1.2登录</h2><h3 id="1-2-1-tty-psedo-tty"><a href="#1-2-1-tty-psedo-tty" class="headerlink" title="1.2.1 tty/psedo-tty"></a>1.2.1 tty/psedo-tty</h3><p>TTY是电传打字机Teletypewriter的缩写，在带显示屏的视频终端出现之前，TTY是最流行的终端设备</p><h3 id="1-2-2-etc-password"><a href="#1-2-2-etc-password" class="headerlink" title="1.2.2 /etc/password"></a>1.2.2 /etc/password</h3><ul><li>密码可以在etc/password看到</li><li>shadow文件</li><li>起始目录</li><li>用户id</li><li>组id</li><li>shell</li></ul><h2 id="1-3-文件"><a href="#1-3-文件" class="headerlink" title="1.3 文件"></a>1.3 文件</h2><h3 id="1-3-1-一切皆为文件"><a href="#1-3-1-一切皆为文件" class="headerlink" title="1.3.1 一切皆为文件"></a>1.3.1 一切皆为文件</h3><ul><li>目录</li><li>文本文件/二进制文件一视同仁</li><li>设备文件：字符设备、块设备、网络设备（在/dev下ll看第一位）</li><li>socket   linux与windows不同</li><li>管道、消息队列等</li></ul><h3 id="1-3-2-相对路径-绝对路径"><a href="#1-3-2-相对路径-绝对路径" class="headerlink" title="1.3.2 相对路径/绝对路径"></a>1.3.2 相对路径/绝对路径</h3><p> /    ..     .</p><h2 id="1-4-I-O"><a href="#1-4-I-O" class="headerlink" title="1.4 I/O"></a>1.4 I/O</h2><ul><li>文件描述符fd</li><li>stdin/stdout/stderr  对应0/1/2</li></ul><h2 id="1-5-进程"><a href="#1-5-进程" class="headerlink" title="1.5 进程"></a>1.5 进程</h2><ul><li><p>进程与程序的关系</p></li><li><p>进程id</p><p>windows下为4的倍数（复用原因）</p><p>linux下用ps命令查看</p></li><li><p>进程控制</p><p>fork 子进程都是由父进程fork出来的（写时复制）</p><p>exec  fork之后调用，类似windows的winexecute api</p><p>waitpid</p></li></ul><h2 id="1-6-出错处理"><a href="#1-6-出错处理" class="headerlink" title="1.6 出错处理"></a>1.6 出错处理</h2><ul><li><p>errno</p><p>windows下有geterrornumber</p></li><li><p>strerror</p></li></ul><h2 id="1-7信号"><a href="#1-7信号" class="headerlink" title="1.7信号"></a>1.7信号</h2><p>可以理解为用户层的中断，异步打断执行流</p><ul><li><p>信号的处理</p><p>系统默认处理： 忽略/中止进程</p><p>为指定信号注册处理函数</p></li></ul><p>是Linux编程重点，也容易踩坑</p><h2 id="1-8-时间"><a href="#1-8-时间" class="headerlink" title="1.8 时间"></a>1.8 时间</h2><h3 id="日历时间"><a href="#日历时间" class="headerlink" title="日历时间"></a>日历时间</h3><p>UTC</p><p>time-t</p><h3 id="进程时间"><a href="#进程时间" class="headerlink" title="进程时间"></a>进程时间</h3><p>clock_t</p><p>用户CPU时间</p><p>系统CPU时间</p><h1 id="2-UNIX标准"><a href="#2-UNIX标准" class="headerlink" title="2.UNIX标准"></a>2.UNIX标准</h1><h2 id="2-1-标准"><a href="#2-1-标准" class="headerlink" title="2.1 标准"></a>2.1 标准</h2><h3 id="ISO-C组成"><a href="#ISO-C组成" class="headerlink" title="ISO C组成"></a>ISO C组成</h3><ul><li>语法、语义</li><li>标准库</li></ul><h3 id="ISO-C历史"><a href="#ISO-C历史" class="headerlink" title="ISO C历史"></a>ISO C历史</h3><ul><li>ANSI C89</li><li>C99<ul><li>restrict</li><li>long long</li><li>单行注释</li><li>分散代码与声明</li></ul></li><li>C11</li></ul><h3 id="POSIX标准"><a href="#POSIX标准" class="headerlink" title="POSIX标准"></a>POSIX标准</h3><ul><li>提升各种应用程序在各种UNIX系统环境间的可移植性</li><li>只定义接口而非实现</li></ul><h3 id="SUS-single-UNIX-specification"><a href="#SUS-single-UNIX-specification" class="headerlink" title="SUS(single UNIX specification)"></a>SUS(single UNIX specification)</h3><ul><li>POSIX的超集</li><li>扩展了功能</li></ul><h2 id="2-2-实现"><a href="#2-2-实现" class="headerlink" title="2.2 实现"></a>2.2 实现</h2><ul><li>FreeBSD</li><li>Linux</li><li>Mac OS X</li><li>Solaris</li></ul><h2 id="2-3限制"><a href="#2-3限制" class="headerlink" title="2.3限制"></a>2.3限制</h2><h3 id="编译时限制"><a href="#编译时限制" class="headerlink" title="编译时限制"></a>编译时限制</h3><ul><li><p>ISO C</p><p>limits.h    各种最大最小值(宏内定义了，include直接用)</p><p>float.h    浮点数相关</p><p>stdio.h</p></li><li><p>POSIX 限制</p></li></ul><h3 id="运行时限制"><a href="#运行时限制" class="headerlink" title="运行时限制"></a>运行时限制</h3><p>只有运行时才能拿到，例如系统调用给出</p><ul><li>sysconf</li><li>pathconf/fpathconf</li></ul><h1 id="3-无缓冲I-O（文件IO）"><a href="#3-无缓冲I-O（文件IO）" class="headerlink" title="3. 无缓冲I/O（文件IO）"></a>3. 无缓冲I/O（文件IO）</h1><h2 id="3-1-文件描述符fd"><a href="#3-1-文件描述符fd" class="headerlink" title="3.1 文件描述符fd"></a>3.1 文件描述符fd</h2><ul><li><p>所有打开文件都由fd引用，fd为非负int（出错时为负）</p></li><li><p>类似windows的HANDLE</p></li><li><p>STDIN_FILENO  STDOUT_FILENO  STDERR_FILENO</p></li><li><p>OPEN_MAX（文件打开的极限值）</p></li><li><p><img src="https://i.loli.net/2021/10/08/Uto3clnhVJEy12D.png" alt="image-20211008102820346"></p></li><li><p><img src="https://i.loli.net/2021/10/08/gsyILjapZ29F7t6.png" alt="image-20211008103035519"></p><ul><li><strong>进程各自维护自己的文件描述符表，文件描述符表记录文件描述符标志，和一个指向文件表项的指针</strong></li><li><strong>文件表项由内核为每一个打开的文件维护，包括文件状态标志、当前文件偏移、以及指向v结点的指针</strong><ul><li><strong>==不同进程打开同一个文件、同一进程调用多次open同一个文件==并不共享file table entry（文件表项）</strong> 因为各自的偏移可能不同，也可以理解为调用一次open打开一个文件表项，而复制fd与之无关<ul><li>但是fork出来的子进程的fd指向同一个文件表项（因为文件描述符表也copy，p397）</li></ul></li></ul></li></ul></li><li><p>/dev/fd</p><p>/prof/self/fd</p></li></ul><h2 id="3-2-API"><a href="#3-2-API" class="headerlink" title="3.2 API"></a>3.2 API</h2><h3 id="open-openat-create"><a href="#open-openat-create" class="headerlink" title="open/openat/create"></a>open/openat/create</h3><ul><li><p>oflag    <strong>文件状态标志</strong></p><ul><li><p>O_RDONLY    O_WRONLY    O_RDWR</p><p>必须指定且互斥</p></li><li><p>O_APPEND    O_CLOEXEC    O_CREAT    O_DIRECTORY    O_EXCL    O_SYNC    O_DSYNC    O_TRUNC</p></li><li><p>O_CREAT | O_EXCL 配合测试创建文件的原子性</p></li></ul></li><li><p>openat的path可以为相对路径</p></li><li><p>creat只写创建，想要创建写之后再读必须close之后再open，用open实现：</p><p>open(path, O_RDWR | O_CREAT | O_TRUNC, mode)</p></li></ul><h3 id="close"><a href="#close" class="headerlink" title="close"></a>close</h3><ul><li><p>会关闭记录锁</p></li><li><p>进程终止，内核会自动关闭文件对象</p><p>RAII的思想</p></li></ul><h3 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h3><ul><li>当前文件偏移量</li><li>文件空洞</li></ul><h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><ul><li>返回值 &lt; 待读字节数的情景<ul><li>eof</li><li>终端设备/行缓冲</li><li>管道/FIFO</li><li>中断</li></ul></li></ul><h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><ul><li>返回值 &lt; 待写字节数的情景<ul><li>磁盘满</li><li>超过了给定进程的文件长度限制</li></ul></li></ul><h3 id="pread-pwrite"><a href="#pread-pwrite" class="headerlink" title="pread/pwrite"></a>pread/pwrite</h3><p>原子lseek + read/write</p><h3 id="dup-dup2"><a href="#dup-dup2" class="headerlink" title="dup/dup2"></a>dup/dup2</h3><ul><li><img src="https://i.loli.net/2021/10/08/I9dk2Rxzu4bLwXe.png" alt="image-20211008212224736"></li><li>新描述符的FD_CLOEXEC总是被清除 （即fd flag）</li><li>dup(fd) = fcntl(fd, F_DUPFD, 0);</li><li>dup2(fd) = close(fd2); fcntl(fd, F_DUPFD, fd2); //且为<strong>原子操作</strong></li><li>dup 和 fcntl 的 errno 不同</li></ul><h3 id="sync-fsync-fdatasync"><a href="#sync-fsync-fdatasync" class="headerlink" title="sync/fsync/fdatasync"></a>sync/fsync/fdatasync</h3><ul><li>内核维护高速缓存</li><li>延迟写</li><li>update守护进程周期性调用sync</li></ul><h3 id="fcntl（重点）"><a href="#fcntl（重点）" class="headerlink" title="fcntl（重点）"></a>fcntl（重点）</h3><p>#include&lt;fcntl.h&gt;</p><p><strong>int fcntl(int fd, int cmd, … );</strong>  </p><ul><li><p>复制一个已有的描述符</p><ul><li>F_DUPFD/F_DUPFD_CLOEXEC</li></ul></li><li><p>获取/设置文件描述符标志**(fd flag)**</p><ul><li><p>F_GETFD/F_SETFD</p></li><li><p>仅有的就是FD_CLOEXEC标志</p><p>fcntl(fd, F_SETFD, 1);    默认为0，即不关闭</p></li></ul></li><li><p>获取/设置文件状态标志</p><ul><li><p>F_GETFL/F_SETFL</p><p>==注意GETFL与GETFD的区别==</p></li></ul></li><li><p>获取/设置异步I/O所有权</p><ul><li>F_GETOWN/F_SETOWN</li></ul></li><li><p>获取/设置记录锁</p><ul><li>F_GETLK/F_SETLK/F_SETLKW</li></ul></li></ul><h3 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h3><ul><li><p>设备驱动</p><p>某个特定操作的接口</p></li><li><p>类比于windows的 DeviceControl</p><p>应用程序到设备驱动的万用接口</p></li></ul><h1 id="4-文件和目录"><a href="#4-文件和目录" class="headerlink" title="4. 文件和目录"></a>4. 文件和目录</h1><h2 id="4-1-struct-stat"><a href="#4-1-struct-stat" class="headerlink" title="4.1 struct stat"></a>4.1 struct stat</h2><p>POSIX标准 + XSI扩展定义的字段</p><p>描述一个特定文件相关的信息</p><h3 id="linux下的struct-stat"><a href="#linux下的struct-stat" class="headerlink" title="linux下的struct stat"></a>linux下的struct stat</h3><ul><li><p>st_mode</p><ul><li><p>文件类型</p><table><thead><tr><th>文件类型</th><th>宏</th></tr></thead><tbody><tr><td>普通文件 regular file</td><td>S_ISREG()</td></tr><tr><td>目录文件 directory file</td><td>S_ISDIR()</td></tr><tr><td>符号链接 symbolic link</td><td>S_ISLINK()</td></tr><tr><td>块特殊文件 block special file</td><td>S_ISCHR()</td></tr><tr><td>字符特殊文件 character special file</td><td>S_ISBLK()</td></tr><tr><td>FIFO 命名管道</td><td>S_ISFIFO()</td></tr><tr><td>socket</td><td>S_ISSOCK()</td></tr><tr><td>消息队列</td><td>S_TYPEISMQ()</td></tr><tr><td>信号量</td><td>S_TYPEISEM()</td></tr><tr><td>共享内存</td><td>S_TYPEISSHM()</td></tr></tbody></table></li><li><p>mode</p><p>set-user-id bit            S_ISUID</p><p>set-group-id bit         S_ISGID</p><p>进程关联ID：</p><ol><li>实际用户/组ID</li><li>有效用户/组ID  附属组ID</li></ol></li><li><p>文件和目录的权限位</p><ul><li><code>S_ISUID</code>：执行时设置用户ID</li><li><code>S_ISGID</code>：执行时设置组ID</li><li><code>S_ISVTX</code>：粘着位</li><li><code>S_IRWXU</code>：用户读、写和执行</li><li><code>S_IRUSR</code>：用户读</li><li><code>S_IWUSR</code>：用户写</li><li><code>S_IXUSR</code>：用户执行</li><li><code>S_IRWXG</code>：组读、写和执行</li><li><code>S_IRGRP</code>：用户读</li><li><code>S_IWGRP</code>：用户写</li><li><code>S_IXGRP</code>：用户执行</li><li><code>S_IRWXO</code>：其他读、写和执行</li><li><code>S_IROTH</code>：用户读</li><li><code>S_IWOTH</code>：用户写</li><li><code>S_IXOTH</code>：用户执行</li></ul><p><img src="https://i.loli.net/2021/10/10/2q7eFnO8j6xHNyY.png" alt="image-20211010161123024"></p></li><li><p>鉴权流程</p></li></ul></li></ul><h2 id="4-2-文件系统"><a href="#4-2-文件系统" class="headerlink" title="4.2 文件系统"></a>4.2 文件系统</h2><h3 id="VFS"><a href="#VFS" class="headerlink" title="VFS"></a>VFS</h3><ul><li>superblock</li><li>incode<ul><li>与文件一一对应，相当于身份证号</li><li>包含文件的元数据，<strong>不包含名称</strong></li><li>内存中的inode和磁盘中的inode</li><li>名称-&gt;inode-&gt;disk block</li></ul></li><li>dentry<ul><li>文件的逻辑属性</li><li>一个dentry对应一个inode</li><li>多个dentry可能对应一个inode(硬链接/软链接)</li></ul></li><li>file object</li></ul><h2 id="4-3-API"><a href="#4-3-API" class="headerlink" title="4.3 API"></a>4.3 API</h2><h3 id="状态相关"><a href="#状态相关" class="headerlink" title="状态相关"></a>状态相关</h3><ul><li><p>stat / fstat / statat / lstat</p></li><li><p>ls - l命令</p><p>注意是否跟踪符号链接</p></li></ul><h3 id="权限相关"><a href="#权限相关" class="headerlink" title="权限相关"></a>权限相关</h3><ul><li><p>access / faccessat</p><p>探测文件是否存在</p><p><strong>以实际用户</strong>ID和实际组ID测试访问能力</p><p>faccessat提供了 AT_EACCESS  和 AT_SYMLINK_NOFOLLOW</p></li><li><p>umask</p><p>创建新目录或文件时，屏蔽字中置1的权限都会被关闭</p><p>区分umask命令</p></li><li><p>chmod / fchmod / fchmodat</p><ul><li>S_ISUID / S_ISGID</li><li>S_IRWXU / S_IRWXG / S_IRWXO</li><li>S_ISVTX(粘着位在linux无效)</li></ul></li><li><p>chown / fchown / fchownat / lchown</p><p>chown命令</p><p>注意符号链接的处理</p></li></ul><h3 id="变更相关"><a href="#变更相关" class="headerlink" title="变更相关"></a>变更相关</h3><ul><li><p>truncate / ftruncate</p><p>截断/扩充</p></li><li><p>link / linkat</p></li><li><p>unlink / unlinkat</p><p>用于确保临时文件被删除</p><p>标准库的remove</p></li><li><p>rename / renameat</p><ul><li>oldname 非目录<ul><li>newname存在</li><li>newname不存在</li></ul></li><li>oldname 为目录<ul><li>newname 存在</li><li>newname 不存在</li></ul></li><li>符号链接</li><li>. 和 .. 不允许</li></ul></li><li><p>symlink / symlinkat</p></li><li><p>readlink / readlinkat</p><p>open的局限：不能打开link本身</p></li><li><p>mkdir / mkdirat</p></li><li><p>rmdir</p></li></ul><h3 id="控制相关"><a href="#控制相关" class="headerlink" title="控制相关"></a>控制相关</h3><ul><li><p>opendir /  fopendir </p><p>readdir / rewinddir / closedir / telldir / seekdir </p><p>类比文件/标准I/O的接口</p></li><li><p>chdir / fchdir</p></li><li><p>getcwd</p></li></ul><h3 id="时间相关"><a href="#时间相关" class="headerlink" title="时间相关"></a>时间相关</h3><ul><li>futimens</li><li>utimensat</li><li>utimes</li></ul><h1 id="5-标准I-O"><a href="#5-标准I-O" class="headerlink" title="5.标准I/O"></a>5.标准I/O</h1><p><strong>即ISO C标准I/O</strong></p><h2 id="5-1-流-stream"><a href="#5-1-流-stream" class="headerlink" title="5.1 流 (stream)"></a>5.1 流 (stream)</h2><ul><li><p>无缓冲I/O围绕fd展开</p></li><li><p>有缓冲I/O围绕stream展开</p></li><li><p>流的定向(stream’s orientation)</p><ul><li><p>单字节 字节定向</p><p>byte flow                 ASCII</p></li><li><p>多字节 宽定向</p><p>wide bytes flow      国际字符集  </p></li></ul></li><li><p>进程预定义流</p><p>stdin / stdout /stderr</p></li><li><p>流缓冲</p><ul><li><p>意义</p></li><li><p>类型</p><p>全缓冲：填满I/O缓冲区后才进行实际I/O操作</p><p>行缓冲：</p><ol><li><p>输入输出遇到换行符时执行I/O操作</p><pre><code>            2. 由于每行缓冲区固定，缓冲区满没有遇到换行符也要执行I/O            3.  任何时候只要通过标准lO库，要求从一个不带缓冲的流或者一个行缓冲的流(从内核请求数据的时机）得到输入数据，那么就会冲洗所有行缓冲输出流。(即要缓冲输入，先冲洗输出缓冲)            4. 指向终端的流通常使用行缓冲</code></pre></li></ol><p>不带缓冲：不进行缓冲</p></li></ul></li><li><p>stdin 和 stdout 并不指向交互设备时，才能使全缓冲类型 (通过重定向)</p><p>如果指向终端设备，则是行缓冲的，否则是全缓冲的</p></li><li><p><strong>stderr绝不能时全缓冲的，一般是不带缓冲</strong></p><p>表现为buffersize = 1</p></li></ul><h2 id="5-2-FILE对象"><a href="#5-2-FILE对象" class="headerlink" title="5.2 FILE对象"></a>5.2 FILE对象</h2><ul><li>不同平台的实现不同</li><li>linux<ul><li>fd    用于实际I/O</li><li>buffer指针  buffer尺寸  buffer当前字符数</li><li>出错标志  文件结束标志</li></ul></li></ul><h2 id="5-3-API"><a href="#5-3-API" class="headerlink" title="5.3 API"></a>5.3 API</h2><ul><li><p>fwide</p></li><li><p>setbuf / setvbuf    p118</p></li><li><p>fflush</p></li><li><p>fopen / freopen / fdopen</p></li><li><p>fclose</p></li><li><p>读写</p><ul><li>getc / fgetc /  getchar / ungetc</li><li>putc / fputc / putchar</li><li>fgets / (gets)</li><li>fputs / (puts)</li><li>fread / fwrite</li></ul></li><li><p>ferror / feof / clearerr</p></li><li><p>ftell / ftello / fseek / fseeko / rewind</p></li><li><p>fgetpos / fsetpos</p></li><li><p>格式化输入输出</p><ul><li>printf / fprintf / dprintf / sprintf / snprintf</li><li>scanf / fscanf / sscanf</li></ul></li><li><p>fileno</p><p>标准I/O到无缓冲I/O的adapter</p></li><li><p>tmpnam / tmpfile  临时文件</p></li><li><p>fmemopen  内存流</p></li></ul><h1 id="6-系统信息"><a href="#6-系统信息" class="headerlink" title="6. 系统信息"></a>6. 系统信息</h1><h2 id="6-1-数据文件"><a href="#6-1-数据文件" class="headerlink" title="6.1 数据文件"></a>6.1 数据文件</h2><ul><li><p>/etc/passwd</p><ul><li><p>pwd.h中定义了struct passwd结构</p><p>可以任意由用户读取</p></li><li><p>是ASCII文件，可以用标准I/O读取，但是效率太低</p><p>因此系统提供API接口</p></li></ul></li><li><p>/etc/group</p><ul><li>grp.h中定义了struct group结构</li></ul></li><li><p>/etc/shadow</p><ul><li><p>经单向加密算法处理过的用户口令副本</p></li><li><p>shadow.h中定义了struct spwd</p></li><li><p>阴影口令文件 /etc/shadow 不应该由一般用户读取</p><p>仅有少数几个程序需要访问加密口令,如login, passwd, 这些程序通常是设定 set-user-ID为root的程序</p></li></ul></li></ul><h2 id="6-2-API"><a href="#6-2-API" class="headerlink" title="6.2 API"></a>6.2 API</h2><h3 id="6-2-1-数据文件"><a href="#6-2-1-数据文件" class="headerlink" title="6.2.1 数据文件"></a>6.2.1 数据文件</h3><ul><li>getpwuid / getpwnam</li><li>getpwent / setpwent / endpwent</li><li>getspnam / getspent / setspent / endspent</li><li>getgrgid / getgenam</li><li>getgrent / setgrent / endgrent</li><li>getgroups / setgroups / initgroups</li></ul><p><strong>返回的结构都是一个静态变量，会覆盖前一次的结果，数据文件的API都提供了 get / set / end 组合技</strong></p><h3 id="6-2-2-系统信息"><a href="#6-2-2-系统信息" class="headerlink" title="6.2.2 系统信息"></a>6.2.2 系统信息</h3><ul><li><p>uname</p><p>struct utsname</p></li><li><p>gethostname</p></li><li><p>time</p><p>日历时间</p></li><li><p>clock_gettime</p><p>获取指定的时钟类型的时间</p><ol><li>实时系统时间</li><li>不带负跳数的实时系统时间</li><li>调用进程的CPU时间</li><li>调用线程的CPU时间</li></ol></li><li><p>clock_getres</p><p>时间精度调整</p></li><li><p>clock_settime</p><p>对特定的时钟设置时间（某些需要权限）</p></li><li><p>gettimeofday (deprecate)</p></li><li><p>gmtime / localtime</p><p>日历时间转换为struct tm 结构</p></li><li><p>mktime</p></li><li><p>strftime / strftime_l</p><p>格式化时间，打印字符串</p></li><li><p>strptime</p></li></ul><h1 id="7-进程环境"><a href="#7-进程环境" class="headerlink" title="7. 进程环境"></a>7. 进程环境</h1><h2 id="7-1概念"><a href="#7-1概念" class="headerlink" title="7.1概念"></a>7.1概念</h2><h3 id="1进程终止"><a href="#1进程终止" class="headerlink" title="1进程终止"></a>1进程终止</h3><ul><li><p>从main返回</p><p>exit(main(argc, argv))</p><p>return 和 exit(0) 并无区别</p></li><li><p>exit()库函数</p></li><li><p>_exit / _Exit 系统调用</p></li><li><p>这两者区别： 不同标准定义 、是否做了清理工作</p></li><li><p><img src="https://i.loli.net/2021/10/12/6ILPQsK8ROXj5CF.png" alt="image-20211012235649755"></p></li></ul><h3 id="2-终止处理程序"><a href="#2-终止处理程序" class="headerlink" title="2 终止处理程序"></a>2 终止处理程序</h3><ul><li><p>atexit函数</p><p>事先声明，反向调用，类似栈</p></li></ul><h3 id="3-命令行参数"><a href="#3-命令行参数" class="headerlink" title="3 命令行参数"></a>3 命令行参数</h3><ul><li><p>argc  argv</p></li><li><p>envp   环境表</p><p>全局变量   environ</p><p><img src="https://i.loli.net/2021/10/12/qnl1Hc9s4xKOfUY.png" alt="image-20211012235941033"></p><ul><li>函数 getenv / putenv</li><li>一般调用函数获取环境，而非读取environ</li></ul></li><li><p>进程地址空间</p><p><img src="https://i.loli.net/2021/10/13/9X1HA2xE8dQ7TrI.png" alt="image-20211013000146968"></p><p>.text / .data / .bss / stack / heap / others (so , debug , systab )</p></li></ul><h3 id="4-跨越函数跳转"><a href="#4-跨越函数跳转" class="headerlink" title="4 跨越函数跳转"></a>4 跨越函数跳转</h3><ul><li>setjmp / longjmp</li><li>靠返回值val与正常函数调用区分</li></ul><h3 id="5-进程资源限制"><a href="#5-进程资源限制" class="headerlink" title="5 进程资源限制"></a>5 进程资源限制</h3><ul><li>getrlimit / setrlimit</li></ul><h2 id="7-2-API"><a href="#7-2-API" class="headerlink" title="7.2 API"></a>7.2 API</h2><ul><li>exit / _Exit / _exit</li><li>atexit</li><li>getenv / putenv / setenv / unsetenv / clearenv</li><li>setjmp / longjmp</li></ul><h1 id="8-进程控制"><a href="#8-进程控制" class="headerlink" title="8. 进程控制"></a>8. 进程控制</h1><h2 id="8-1-概念"><a href="#8-1-概念" class="headerlink" title="8.1 概念"></a>8.1 概念</h2><h3 id="进程ID"><a href="#进程ID" class="headerlink" title="进程ID"></a>进程ID</h3><ul><li><p>循环复用</p></li><li><p>特殊的进程ID</p><ul><li><p>swapper：0    内核交换进程</p></li><li><p>init：1</p><p>普通用户进程</p><p>超级用户特权</p><p>所有孤儿进程的父进程</p></li></ul></li></ul><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><h4 id="一次调用两次返回"><a href="#一次调用两次返回" class="headerlink" title="一次调用两次返回"></a>一次调用两次返回</h4><ul><li><p>父进程中返回创建的子进程ID</p></li><li><p>子进程返回0</p><p>getppid ( get parent id) 获取父进程ID</p></li><li><p>父子进程谁先执行不确定</p></li></ul><h4 id="子进程是父进程的副本"><a href="#子进程是父进程的副本" class="headerlink" title="子进程是父进程的副本"></a>子进程是父进程的副本</h4><ul><li><p>拷贝数据空间、堆、栈</p><p>COW （copy on write）写时复制</p><p>试图修改时才真正拷贝</p><p>fork + exec 从中受益</p></li><li><p>代码段共享 （只读）</p></li><li><p>拷贝文件描述符表</p><p><img src="https://i.loli.net/2021/10/13/NQ7HU8TExiwOo3J.png" alt="image-20211013001243684"></p></li><li><p>继承父进程相关属性</p><p>实际用户ID、实际组ID、有效用户ID、有效组ID 附属组ID 进程组ID 会话ID 控制终端 设置用户ID标识和设置组ID标识 当前工作目录 根目录 文件模式创建屏蔽字 信号屏蔽和安排 对任一打开文件描述符的执行时关闭(close-on-exec)标识 环境变量 连接的共享存储段 存储映像 资源限制</p></li><li><p>父子进程的不同之处</p><ul><li>ID / PID</li><li>子进程tms_utime/tms_stime/tms_cutime/tms_ustime被清零</li><li><strong>子进程不继承父进程文件锁</strong></li><li>子进程未处理闹钟将被清除</li><li>子进程未处理信号集设置为空集</li></ul></li></ul><h3 id="父子进程的生死交互"><a href="#父子进程的生死交互" class="headerlink" title="父子进程的生死交互"></a>父子进程的生死交互</h3><h4 id="子进程先于父进程终止"><a href="#子进程先于父进程终止" class="headerlink" title="子进程先于父进程终止"></a>子进程先于父进程终止</h4><ul><li><p>通过信号SIGCHILD发送退出状态给父进程</p></li><li><p>父进程可以通过wait / waitpid获取信息</p><p>子进程ID / 子进程终止状态 / CPU耗时</p></li><li><p>未善后的终止子进程为僵死进程（zombie）</p></li></ul><h4 id="父进程先于子进程终止"><a href="#父进程先于子进程终止" class="headerlink" title="父进程先于子进程终止"></a>父进程先于子进程终止</h4><ul><li><p>子进程父亲改为init 进程（pid 1）</p></li><li><p>init进程会调用wait善后处理终止的子进程（防止全是zombie）</p></li><li><p>wait / waitpid</p><ul><li><p>如果所有子进程都还在运行，则阻塞</p></li><li><p>如果一个子进程终止，正等待父进程获取其终止状态，则取得终止状态立即返回（zombie状态也立即返回）</p></li><li><p>如果没有任何子进程则出错返回</p></li><li><p>waitpid功能补充</p><p>支持异步（需要设置options参数）</p><p>可选择性等待某个进程</p><p>​    pid == -1 / 0 / &gt;0 / &lt;-1</p></li></ul></li><li><p>更灵活的wait系列函数</p></li></ul><h3 id="exec族函数"><a href="#exec族函数" class="headerlink" title="exec族函数"></a>exec族函数</h3><ul><li><p>更进一步的封装</p><ul><li><p>popen</p></li><li><p>system</p><p>fork -&gt; exec -&gt; waitpid</p></li></ul></li></ul><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><ul><li>实际用户 / 组ID</li><li>有效用户 / 组ID</li><li>setuid / setgid<ul><li>进程拥有超级权限，二话不说直接改实际用户/组ID、有效用户/组ID为指定ID </li><li>如果没有超级权限，但是uid或gid设置为实际用户/组ID或保存的设置用户/组ID， 则只将有效用户/组ID改为指定ID </li><li>不满足前两条，通通返回错误(ret = -1, error = EPERM)</li></ul></li></ul><h3 id="解释器文件"><a href="#解释器文件" class="headerlink" title="解释器文件"></a>解释器文件</h3><ul><li>解释型语言源文件起始行标注</li></ul><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><ul><li><p>优先级</p></li><li><p>nice</p><p>0~2*NZERO-1 sysconf获取</p><p>越大越低</p></li><li><p>getpriority setpriority</p></li></ul><h3 id="进程时间-1"><a href="#进程时间-1" class="headerlink" title="进程时间"></a>进程时间</h3><ul><li>时钟时间 </li><li>用户CPU时间 </li><li>系统CPU时间 </li><li>times</li></ul><h1 id="8-2-API"><a href="#8-2-API" class="headerlink" title="8.2 API"></a>8.2 API</h1><ul><li>getpid getppid getuid geteuid getgid getegid</li><li>fork vfork</li><li>wait waitpid</li><li>waitid</li><li>wait3/wait4</li><li>execl execv execle execve execlp execvp fexecve</li><li>setuid/setgid</li><li>seteuid/setegid</li><li>system</li><li>nice</li><li>getpriority/setpriority</li><li>times</li></ul><h1 id="9-进程关系"><a href="#9-进程关系" class="headerlink" title="9. 进程关系"></a>9. 进程关系</h1><h2 id="9-1-概念"><a href="#9-1-概念" class="headerlink" title="9.1 概念"></a>9.1 概念</h2><h3 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h3><p><img src="https://i.loli.net/2021/10/15/pDU7nBhWYsqKtjm.png" alt="image-20211015155106020"></p><ul><li><p>tty1-6</p><p>CTRL ALT F1-6</p></li><li><p>图形终端</p><p>ALT F7</p></li><li><p>pseudo tty（pty） 网络终端</p></li></ul><h3 id="进程组（作业job）"><a href="#进程组（作业job）" class="headerlink" title="进程组（作业job）"></a>进程组（作业job）</h3><ul><li><p>唯一标志ID</p><ul><li><p>getpgrp / getpgid</p></li><li><p>setpgid</p><p><strong>进程只能为自己和它的子进程设置进程组ID</strong></p></li><li><p>唯一标志ID和组长的PID一致</p></li></ul></li><li><p>多个进程的集合，每个进程都有所属的进程组</p></li><li><p>同一进程组的所有进程接受同一终端的各种信号</p></li><li><p><strong>孤儿进程组</strong></p><p>每个成员的父亲要么在本组，要么在其他会话中</p></li></ul><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><ul><li><p>可以有0或一个控制终端（tty / pseudo tty)</p><p>建立与控制终端连接的会话首进程被称为控制进程</p><p>无控制终端可能为守护进程</p></li><li><p>一个到多个进程组的集合</p><ul><li><p>一个前台进程</p><p>这意味着会话有一个控制终端</p><p>接受 ctrl c / ctrl \ 产生的 SIGINT /  SIGQUIT 信号</p></li><li><p>n个后台进程组</p></li><li><p><img src="https://i.loli.net/2021/10/15/qJIVv3AE1sRPOQm.png" alt="image-20211015154131834"></p></li></ul></li><li><p>新建会话 setsid</p><ul><li><p>该进程变成新会话的会话首进程 (session leader)</p><p>此时该 leader 是会话中的唯一进程</p><p>这意味这<strong>要新建会话 要先 fork 再 setsid</strong>     这就保证了进程不是进程组的组长</p></li><li><p>该进程成为一个新进程组的组长进程</p><p>新进程组ID是调用进程的进程ID</p><p>也是会话ID</p></li><li><p>该进程没有控制终端</p><p>如果调用 setsid 前有控制终端，则切断联系</p></li></ul></li></ul><h3 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h3><p><img src="https://i.loli.net/2021/10/15/lSc1txX8ZjoD2sv.png" alt="image-20211015155022811"></p><h2 id="9-2-API"><a href="#9-2-API" class="headerlink" title="9.2 API"></a>9.2 API</h2><ul><li>getpgrp / getpgid / sepgid</li><li>setsid / getsid</li><li>tcgetpgrp / tcsetpgrp / tcgetsid</li></ul><h1 id="10-信号"><a href="#10-信号" class="headerlink" title="10. 信号"></a>10. 信号</h1><h2 id="10-1-概念"><a href="#10-1-概念" class="headerlink" title="10.1 概念"></a>10.1 概念</h2><h3 id="异步事件"><a href="#异步事件" class="headerlink" title="异步事件"></a>异步事件</h3><ul><li>信号的产生是不定时的，随机的</li><li>可以简单理解为用户态的中断（软中断）</li></ul><h3 id="产生信号的方式"><a href="#产生信号的方式" class="headerlink" title="产生信号的方式"></a>产生信号的方式</h3><ul><li>用户按键产生（ctrl C）</li><li>硬件异常产生</li><li>进程或者用户调用kill</li><li>但检测到某种软性条件已经发生，通知有关进程<ul><li>SIGURG / SIGPIPE / SIGALARM / SIGABRT</li></ul></li></ul><h3 id="进程处理信号的方式"><a href="#进程处理信号的方式" class="headerlink" title="进程处理信号的方式"></a>进程处理信号的方式</h3><ul><li><p>忽略 ignore</p><ul><li>大多数信号的默认处理方式</li><li>SIGKILL / SIGSTOP 不能被忽略</li><li>由硬件异常导致的信号最好不要被忽略</li><li>中断允许嵌套，但是一般终端过程中同一个中断会忽略</li></ul></li><li><p>捕捉 catch</p><ul><li>注册一个signal handler</li><li>信号到来时会打断当前执行流，转而去执行handler</li><li>不能捕捉SIGKILL / SIGSTOP</li></ul></li><li><p>执行默认动作</p><p><img src="https://i.loli.net/2021/10/13/oRPtp3KE8DM6zXm.png" alt="image-20211013234629726"></p></li><li><p>函数 signal / sigaction</p></li><li><p>子进程继承了父进程处理信号的方式</p></li></ul><h3 id="被中断的系统调用"><a href="#被中断的系统调用" class="headerlink" title="被中断的系统调用"></a>被中断的系统调用</h3><ul><li><p>低速系统调用</p><p>可能会使进程永久阻塞的一类</p></li><li><p>出错返回</p><p>errno EINTR</p></li><li><p>自动重新启动的系统调用</p><p>ioctl read/readv write/writev wait/waitpid</p></li></ul><h3 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h3><ul><li><p>异步信号安全</p><p><img src="https://i.loli.net/2021/10/13/mTB6qjaRNg81KUw.png" alt="image-20211013235025005"></p></li><li><p>不可重入的情况</p><p>static静态变量</p><p>global全局变量</p><p>调用了不可重入函数</p></li><li><p>malloc是线程安全的（递归锁），但是维护共享内存，故是不可重入的</p></li></ul><h3 id="可靠信号"><a href="#可靠信号" class="headerlink" title="可靠信号"></a>可靠信号</h3><ul><li><p>未决的 pending<br>产生信号和送达之间</p></li><li><p>信号屏蔽字 signal mask （signal procmask）</p><ul><li>进程可以阻塞某种信号递送sigpending<ul><li>保持未决状态</li><li>直到进程接触阻塞或设置为忽略才送达</li><li>阻塞期间同一个信号触发多次（是否排队：sigqueue）</li></ul></li><li>sigsuspend 解除了 使用 sigprocmask 和 pause 组合 的原子性问题</li></ul></li><li><p>信号集 sigset_t</p><p>相关api ： sigemptyset / sigfillset / sigaddset / sigdelset / sigismember</p><p>与 sigprocmask 相配合</p></li></ul><h3 id="递送信号"><a href="#递送信号" class="headerlink" title="递送信号"></a>递送信号</h3><ul><li><p>kill  / raise 库函数</p></li><li><p>kill命令</p></li><li><p>定时器</p><p>alarm：SIGALARM  默认动作为终止进程</p><p>一个进程只能有一个定时器</p></li></ul><h3 id="睡眠"><a href="#睡眠" class="headerlink" title="睡眠"></a>睡眠</h3><ul><li>sleep / nanosleep / clock_nanosleep</li></ul><h3 id="进程控制的延申"><a href="#进程控制的延申" class="headerlink" title="进程控制的延申"></a>进程控制的延申</h3><ul><li>信号做父子进程的同步</li><li>加入信号处理的system实现</li></ul><h3 id="非局部跳出（deprecated）"><a href="#非局部跳出（deprecated）" class="headerlink" title="非局部跳出（deprecated）"></a>非局部跳出（deprecated）</h3><ul><li><p>sigsetjmp / siglongjmp</p></li><li><p>对比 setjmp / longjmp</p><p>handler自动屏蔽某种信号</p><p>跳走后无法保存信号屏蔽字</p></li></ul><h1 id="10-2-API"><a href="#10-2-API" class="headerlink" title="10.2 API"></a>10.2 API</h1><ul><li><p>signal</p></li><li><p>kill / raise</p></li><li><p>alarm</p></li><li><p>pause</p></li><li><p>sigemptyset / sigfillset / sigaddset / sigdelset / sigismember</p></li><li><p>sigprocmask / sigpending</p></li><li><p>sigsetjmp / siglongjmp</p></li><li><p>sigsuspend</p><p>信号屏蔽字被设置为sigmask指向的值然后挂起，在捕捉一个信号之后返回恢复原来的sigmask </p></li><li><p>abort</p></li></ul><h1 id="11-线程"><a href="#11-线程" class="headerlink" title="11. 线程"></a>11. 线程</h1><h2 id="11-1-进程与线程的概念"><a href="#11-1-进程与线程的概念" class="headerlink" title="11.1 进程与线程的概念"></a>11.1 进程与线程的概念</h2><ul><li>进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位）</li><li>进程有自己的独立地址空间，线程是共享进程的地址空间</li><li>线程之间通信更方便，进程则要通过各种IPC机制</li><li>多进程更加健壮，一个进程异常挂掉不会导致其他进程挂掉</li></ul><h2 id="11-2-多线程与多核"><a href="#11-2-多线程与多核" class="headerlink" title="11.2 多线程与多核"></a>11.2 多线程与多核</h2><ul><li>单核也可以多线程</li><li>多核多线程可以达成同时run的效果</li></ul><h2 id="11-3-pthread标准"><a href="#11-3-pthread标准" class="headerlink" title="11.3 pthread标准"></a>11.3 pthread标准</h2><ul><li><p>POSIX 线程</p><p>LinuxThreads的变化（NPTL）</p></li></ul><h2 id="11-4-线程信息"><a href="#11-4-线程信息" class="headerlink" title="11.4 线程信息"></a>11.4 线程信息</h2><p><strong>以下不共享</strong></p><ul><li><p>线程ID</p><p>pthread_t / pthread_equal / pthread_self</p></li><li><p>栈</p></li><li><p>信号屏蔽字</p></li><li><p>调度优先级</p></li><li><p>errno变量</p></li><li><p>线程私有数据</p></li></ul><h2 id="11-5-线程的生与死"><a href="#11-5-线程的生与死" class="headerlink" title="11.5 线程的生与死"></a>11.5 线程的生与死</h2><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><ul><li><p>pthread_creat<strong>e</strong></p></li><li><p>线程创建不能保证哪个线程会先运行</p></li><li><p>线程继承调用线程的浮点环境和信号屏蔽字</p><p>但是 pending 信号集会被清除</p></li></ul><h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h3><ul><li><p>导致进程终止</p><ul><li>任意线程调用 exit / _exit / _Exit</li><li>发送给线程的信号（默认终止进程）</li></ul></li><li><p>单一线程终止</p><ul><li><p>线程从启动历程返回</p><p>pthread_join / pthread_datch</p></li><li><p>线程被同一进程的其他线程取消</p><p>pthread_cancel</p></li><li><p>线程调用 pthread_exit</p></li></ul></li><li><p>线程清理处理程序</p><ul><li>pthread_cleanup_push / pthread_cleanup_pop</li><li>清理情况：<ul><li>主动调用 pthread_exit</li><li>响应 pthread_cancel</li><li>调用 pthread_cleanup_pop 参数不为0的时候</li></ul></li><li>直接 return 并不会执行清理</li><li>执行顺序与注册顺序相反</li></ul></li></ul><h2 id="11-6-进程与线程原语"><a href="#11-6-进程与线程原语" class="headerlink" title="11.6 进程与线程原语"></a>11.6 进程与线程原语</h2><table><thead><tr><th>进程原语</th><th>线程原语</th><th>描述</th></tr></thead><tbody><tr><td>fork</td><td>pthread_create</td><td>创建新的控制流</td></tr><tr><td>exit</td><td>pthread_exit</td><td>从现有的控制流中退出</td></tr><tr><td>waitpid</td><td>pthread_join</td><td>从控制流中得到退出状态</td></tr><tr><td>atexit</td><td>pthread_cancel_push</td><td>注册在退出控制流时调用的函数</td></tr><tr><td>getpid</td><td>pthread_self</td><td>获取控制流的ID</td></tr><tr><td>abort</td><td>pthread_cancel</td><td>请求控制流的非正常退出</td></tr></tbody></table><h2 id="11-7-线程同步、一致性问题"><a href="#11-7-线程同步、一致性问题" class="headerlink" title="11.7 线程同步、一致性问题"></a>11.7 线程同步、一致性问题</h2><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><ul><li><p>POSIX互斥量</p><p>struct pthread_mutex_t</p><ul><li><p>初始化/销毁</p><p>pthread_mutex_init / pthread_mutex_destory</p></li><li><p>上锁</p><p>pthread_mutex_lock / pthread_mutex_timedlock / pthread_mutex_trylock / pthread_mutex_unlock</p></li><li><p>解锁</p><p>pthread_mutex_unlock</p></li></ul></li><li><p>死锁</p><ul><li><p>AB型死锁</p><p>解决方法：</p><ol><li>按序获取锁（程序复杂）</li><li>trylock / timedlock</li></ol></li></ul></li></ul><h3 id="读写锁-共享互斥锁"><a href="#读写锁-共享互斥锁" class="headerlink" title="读写锁(共享互斥锁)"></a>读写锁(共享互斥锁)</h3><ul><li><p>状态</p><ul><li><p>读锁：读请求 pass ，写请求阻塞直到读锁释放（共享锁）</p><p>引用计数实现</p><p>注意写请求的饥饿情况，通常写请求后的读请求被阻塞（FIFO)</p></li><li><p>写锁：阻塞任何的加锁请求（互斥锁）</p></li><li><p>无锁</p></li></ul></li><li><p>一次只有一个线程可以占有写锁，可以有多个线程同时占有读锁</p></li><li><p>适用于读请求&gt;&gt;写请求的情况</p></li><li><p>POSIX读写锁</p><ul><li><p>初始化 / 销毁</p><p>pthread_rwlock_init / pthread_rwlock_destroy</p></li><li><p>读锁</p><p>pthread_rwlock_rdlock / pthread_rwlock_tryrdlock / pthread_rwlock_timedrdlock</p></li><li><p>写锁</p><p>pthread_rwlock_wrlock / pthread_rwlock_trywrlock / pthread_rwlock_timedwrlock</p></li><li><p>解锁</p><p>pthread_rwlock_unlock</p></li></ul></li></ul><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><ul><li><p>配合互斥量使用，提供多线程会合的时间点</p></li><li><p>初始化 / 销毁</p><p>pthread_cond_init / pthread_cond_destroy</p></li><li><p>等待条件变量变为true</p><p>pthread_cond_wait / pthread_cond_timedwait</p></li><li><p>条件变量置信</p><p>pthread_cond_signal 唤醒一个 / pthread_cond_broadcast 唤醒所有</p></li></ul><h3 id="自旋锁-spinlock"><a href="#自旋锁-spinlock" class="headerlink" title="自旋锁 spinlock"></a>自旋锁 spinlock</h3><ul><li>特征：忙等阻塞</li><li>锁持有时间段，线程不希望被调度</li><li>用户态基本不使用自旋锁</li><li>不要调用在持有自旋锁的情况下可能会进入休眠状态的函数</li></ul><h3 id="屏障-barrier"><a href="#屏障-barrier" class="headerlink" title="屏障 barrier"></a>屏障 barrier</h3><ul><li><p>协调多个进程并行工作</p><p>每个线程等待，直到所有线程共同达到某一点</p></li><li><p>初始化 / 销毁</p><p>pthread_barrier_init / pthread_barrier_destory</p></li><li><p>等待</p><p>pthread_barrier_wait</p><p>未满足屏障计数时阻塞 、满足屏障计数时唤醒所有（最后一个线程）</p></li></ul><h1 id="12-线程控制"><a href="#12-线程控制" class="headerlink" title="12. 线程控制"></a>12. 线程控制</h1><h2 id="12-1-属性"><a href="#12-1-属性" class="headerlink" title="12.1 属性"></a>12.1 属性</h2><h3 id="pthread遵循的对于属性的模式"><a href="#pthread遵循的对于属性的模式" class="headerlink" title="pthread遵循的对于属性的模式"></a>pthread遵循的对于属性的模式</h3><ol><li>每个对象都和自己类型的属性对象相关联（互斥量与互斥量属性相关联，线程与线程属性相关联），表现为 attr 指针，每个属性对象可以代表多个属性。属性对应用不透明，便于提高可移植性，因此需要函数来进行管理</li><li>每个属性对象有一个初始化函数，它把属性设置为默认值</li><li>还有一个销毁属性对象的函数，用于释放与属性对象的资源</li><li>获取各个属性值的函数，返回存储它的内存单元</li><li>设置属性值的函数，一般来说属性作为参数用指针传递</li></ol><h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><ul><li><p>初始化 / 销毁</p><p>pthread_attr_init / pthread_attr_destory</p></li><li><p>线程分离状态属性(分离线程的资源在线程终止时立即收回，无法用 join 等待其终止状态)</p><p>pthread_attr_getdetachstate / pthread_attr_setdetachstate</p></li><li><p>以下不建议用</p><p>pthread_attr_getguardsize / pthread_attr_setguardsize</p><p>pthread_attr_getstacksize / pthread_attr_setstacksize</p><p>pthread_attr_getstack / pthread_attr_setstack</p></li><li><p>取消状态（取消点）不建议用</p><p>PTHREAD_CANCEL_ENABLE / PTHREAD_CANCEL_DISABLE </p><p>pthread_setcancelstate</p><p>被取消线程在调用点会感知到取消 (pthread_cancel调用方不等待)</p><p>默认情况延迟取消</p></li></ul><h3 id="同步属性"><a href="#同步属性" class="headerlink" title="同步属性"></a>同步属性</h3><h4 id="互斥量属性-pthread-mutexattr-t"><a href="#互斥量属性-pthread-mutexattr-t" class="headerlink" title="互斥量属性 pthread_mutexattr_t"></a>互斥量属性 pthread_mutexattr_t</h4><p><del>共享属性、健壮属性</del>、类型属性</p><ul><li><p>pthread_mutexattr_init / pthread_mutexattr_destroy</p></li><li><p>以下不建议使用</p><ul><li><p>进程共享(内核开销大，不属于NPTL)</p><p>pthread_mutexattr_getpshared / pthread_mutexattr_setpshared</p></li><li><p>健壮属性</p></li><li><p><strong>类型属性</strong></p><ul><li><p>pthread_mutexattr_gettype / pthread_mutexattr_settype</p></li><li><table><thead><tr><th>互斥量类型</th><th>递归上锁</th><th>不占用时解锁</th><th>已解锁时解锁</th></tr></thead><tbody><tr><td>PTHREAD_MUTEX_NORMAL</td><td>死锁</td><td>未定义</td><td>未定义</td></tr><tr><td>PTHREAD_MUTEX_ERRORCHECK</td><td>返回错误</td><td>返回错误</td><td>返回错误</td></tr><tr><td>PTHREAD_MUTEX_RECURSIVE</td><td>允许</td><td>返回错误</td><td>返回错误</td></tr><tr><td>PTHREAD_MUTEX_DEFAULT</td><td>未定义</td><td>未定义</td><td>未定义</td></tr></tbody></table></li><li><p>递归锁的使用场景</p><p><img src="https://i.loli.net/2021/10/15/adhHkbEo9LBI1gC.png" alt="image-20211015230742334"></p></li></ul></li></ul></li></ul><h4 id="读写锁属性-pthread-rwlockattr-t"><a href="#读写锁属性-pthread-rwlockattr-t" class="headerlink" title="读写锁属性 pthread_rwlockattr_t"></a>读写锁属性 pthread_rwlockattr_t</h4><ul><li>pthread_rwlockattr_init / pthread_rwlockattr_destroy</li><li>pthread_rwlockattr_getpshared / pthread_rwlockattr_setpshared</li></ul><h4 id="条件变量属性-pthread-condattr-t"><a href="#条件变量属性-pthread-condattr-t" class="headerlink" title="条件变量属性 pthread_condattr_t"></a>条件变量属性 pthread_condattr_t</h4><ul><li>pthread_condattr_init / pthread_condattr_destroy</li><li>pthread_condattr_getpshared / pthread_condattr_setpshared</li></ul><h4 id="屏障属性-pthread-barrierattr-t"><a href="#屏障属性-pthread-barrierattr-t" class="headerlink" title="屏障属性 pthread_barrierattr_t"></a>屏障属性 pthread_barrierattr_t</h4><ul><li>pthread_barrierattr_init / pthread_barrierattr_destroy</li><li>pthread_barrierattr_getpshared / pthread_barrierattr_setpshared</li></ul><h2 id="12-2-重入"><a href="#12-2-重入" class="headerlink" title="12.2 重入"></a>12.2 重入</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>如果一个函数对多个线程来说时可重入的，就说这个函数是线程安全的。但并不能说明对信号处理程序来说该函数也是可重入的。</p></li><li><p>如果函数对于异步信号处理程序的重入是安全的，那么可以说函数是异步信号安全的</p></li><li><p><strong>重入的要求高于线程安全</strong></p><p>可重入要求信号安全</p><p>一般来说：</p><p>如果一个函数的实现使用了全局或者静态变量，且访问未加锁，那么这个函数既不是可重入的，也不是线程安全的。</p><p>如果放宽条件，这个函数仍然用到了全局或者静态变量，但是在访问这些变量时，通过加锁来保证互斥访问，那么这个函数就可以变成线程安全的函数。但它此时仍然是不可重入的，因为通常加锁是针对不同线程的访问，对同一线程可能出现问题（发生信号软中断，signal handler中恰巧也执行了该函数）。</p></li></ul><h3 id="非线程安全函数"><a href="#非线程安全函数" class="headerlink" title="非线程安全函数"></a>非线程安全函数</h3><p><img src="https://i.loli.net/2021/10/15/7JrTCHj1DRlBpy6.png" alt="image-20211015231532218"></p><h3 id="替代的线程安全函数"><a href="#替代的线程安全函数" class="headerlink" title="替代的线程安全函数"></a>替代的线程安全函数</h3><p><img src="https://i.loli.net/2021/10/15/3b7pgVX6hin1FEW.png" alt="image-20211015231605762"></p><h2 id="12-3-线程私有数据"><a href="#12-3-线程私有数据" class="headerlink" title="12.3 线程私有数据"></a>12.3 线程私有数据</h2><ul><li><p>由于线程共享地址空间，故线程无法阻止另一个线程访问其私有数据</p><p>因此需要管理线程特定数据的函数（设计上封装隔离）</p></li><li><p>pthread_key_create / pthread_key_delete</p></li><li><p>让不同线程看到同一个键值 pthread_once</p><p>pthread_once_t = PTHREAD_ONCE_INIT</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destructor</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *)</span></span>;<br><span class="hljs-keyword">pthread_key_t</span> key;<br><span class="hljs-keyword">pthread_once_t</span> init_done = PTHREAD_ONCE_INIT;<br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">thread_init</span><span class="hljs-params">(Void)</span></span><br><span class="hljs-function"></span>&#123;<br>err = pthread_key_create(&amp;key, destructor);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">threadfunc</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>pthread_once(&amp;init_done, thread_init);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>关联键和私有数据</p><p>pthread_getspecific / pthread_setspecific</p></li></ul><h2 id="12-4-线程和信号"><a href="#12-4-线程和信号" class="headerlink" title="12.4 线程和信号"></a>12.4 线程和信号</h2><ul><li><p>线程都有自己的信号屏蔽字</p></li><li><p>线程的处理是进程中所有线程共享的</p></li><li><p>信号是传递给单个线程的</p><ul><li>信号与硬件相关，递送给引起时间的进程</li><li>其他信号发送给任意一个进程</li></ul></li><li><p>pthread_sigmask</p><ul><li><p>sigprocmask在多线程环境中行为未定义</p></li><li><p>用法类似sigprocmask</p></li><li><p>sigwait等待信号出现</p><ul><li><p>先阻塞等待的信号（在外部）</p></li><li><p>原子取消信号集阻塞状态</p></li><li><p>信号递送后返回</p></li><li><p>返回前恢复阻塞信号集</p><p>类比条件变量和互斥量</p></li></ul></li><li><p>多个线程等待同一信号，只有一个会被唤醒</p></li></ul></li><li><p>pthread_kill</p><p>给指定进程发送信号</p></li><li><p>线程与I/O</p><ul><li><p>lseek read</p><p>多线程有问题</p></li><li><p>pread</p><p>lseek read 的原子操作</p></li></ul></li></ul><h2 id="12-5-API"><a href="#12-5-API" class="headerlink" title="12.5 API"></a>12.5 API</h2><ul><li>pthread_attr_init / pthread_attr_destroy</li><li>pthread_attr_getdetachstate / pthread_attr_setdetachstate</li><li>pthread_key_create</li><li>pthread_mutexattr_init / pthread_mutexattr_destroy</li><li>pthread_mutexattr_gettype / pthread_mutexattr_settype</li><li>pthread_key_create / pthread_key_delete</li><li>pthread_getspecific / pthread_setspecific</li><li>pthread_sigmask</li><li>pthread_sigkill</li></ul><h1 id="13-守护进程"><a href="#13-守护进程" class="headerlink" title="13. 守护进程"></a>13. 守护进程</h1><h2 id="13-1-概念"><a href="#13-1-概念" class="headerlink" title="13.1 概念"></a>13.1 概念</h2><h3 id="守护进程的概念"><a href="#守护进程的概念" class="headerlink" title="守护进程的概念"></a>守护进程的概念</h3><ul><li>内核态守护进程（内核线程）<ul><li>eg： 虚拟内存换页kswapd / 脏页面冲刷 flush</li></ul></li><li>用户态守护进程<ul><li>由 init 拉起</li><li>setsid 使其一般是会话首进程，同时也是进程组组长、唯一进程</li></ul></li></ul><h3 id="编写守护进程的惯例"><a href="#编写守护进程的惯例" class="headerlink" title="编写守护进程的惯例"></a>编写守护进程的惯例</h3><ol><li><p>umask 设置文件模式创建屏蔽字</p><p>通常 umask(0)</p></li><li><p>父进程 fork 并 exit</p><p>为子进程 setsid 创建会话创造条件</p></li><li><p> setsid</p></li></ol><p>   会话首进程 / 进程组组长 / 没有控制终端</p><ol start="4"><li><p>当前工作目录改为根目录或者其他位置</p><p>chdir(“/“)            防挂在umount</p></li><li><p>关闭不用的文件描述符</p><p>首先 getrlimit 判定最高文件描述符的值，然后用循环全部关闭</p></li><li><p>打开 /dev/null 使具有文件描述符0、1、2</p><p>因为守护进程并不与终端设备相关联，无从显示也无需输入</p><p>fd0 = open(“/dev/null”, O_RDWR);</p></li><li><p>一般还需要处理 SIGHUP 信号</p><p>原因：孤儿进程</p></li></ol><h3 id="出错记录"><a href="#出错记录" class="headerlink" title="出错记录"></a>出错记录</h3><ul><li><img src="https://i.loli.net/2021/10/15/U2B4Ym8CMXEQ1Lh.png" alt="image-20211015160833072"></li><li>内核例程调用log函数</li><li>用户守护进程调用 syslog 函数</li><li>本地或其他主机可通过 UDP 514端口传递log</li><li>rsyslog</li></ul><h3 id="单例守护进程"><a href="#单例守护进程" class="headerlink" title="单例守护进程"></a>单例守护进程</h3><ul><li><p>文件记录锁</p><p>记录锁</p></li><li><p>惯例</p><ol><li><p>锁通常指定在 /var/run/%name%.pid</p><p>内容一般就是pid号</p></li><li><p>配置文件通常在 /etc/%name%.conf</p></li><li><p>守护进程一般通过初始化脚本之一启动</p><p>/etc/rc*    /etc/init.d/*    /etc/inittab启动自动重启</p></li><li><p>一般注册 SIGHUP 处理程序</p><p>一方面使为了防止默认动作终止</p><p>功能上设置为重新读取配置</p></li></ol></li></ul><h2 id="13-2-API"><a href="#13-2-API" class="headerlink" title="13.2 API"></a>13.2 API</h2><ul><li>openlog / syslog / closelog / setlog / mask</li><li>vsyslog</li></ul><h1 id="14-进阶I-O"><a href="#14-进阶I-O" class="headerlink" title="14 进阶I/O"></a>14 进阶I/O</h1><h2 id="14-1-非阻塞I-O"><a href="#14-1-非阻塞I-O" class="headerlink" title="14.1 非阻塞I/O"></a>14.1 非阻塞I/O</h2><ul><li><p>低速系统调用</p><p>定义：会引起进程永久阻塞</p><ul><li>某些文件类型数据不存在，读引起永久阻塞</li><li>数据不能被相同的文件类型接受，写操作会永久阻塞</li><li>对加了记录锁的文件读写</li><li>ioctl</li><li>进程通信函数</li></ul></li><li><p>open 先天指定 O_NONBLOCK</p></li><li><p>fcntl 后天设置  O_NONBLOCK</p></li><li><p>轮询 polling + 非阻塞I/O</p><p>类似用户态的自旋锁   浪费cpu时间</p></li><li><p>多线程 + 阻塞I/O</p><p>额外的线程开销、同步开销</p></li></ul><h2 id="14-2-记录锁-recording-lock"><a href="#14-2-记录锁-recording-lock" class="headerlink" title="14.2 记录锁 recording lock"></a>14.2 记录锁 recording lock</h2><ul><li><p>确保进程单独写文件</p><p>进程读或写文件的某个部分时，使用记录锁组织其他进程修改同一文件区</p><p>byte range locking</p></li><li><p>fcntl 记录锁</p><ul><li><p>struct flock</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">flock</span>&#123;</span><br><span class="hljs-keyword">short</span> l_type;<br><span class="hljs-keyword">short</span> l_whence;<br><span class="hljs-keyword">off_t</span> l_start;<br><span class="hljs-keyword">off_t</span> l_len;<br><span class="hljs-keyword">pid_t</span> l_pid;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>l_type :  F_GETLK / F_SETLK / F_SETLKW</p></li><li><p>F_GETLK 检测上锁后上锁不是原子操作</p></li><li><p>F_SETLKW 检测到死锁后杀死另一个进程获得资源</p></li></ul></li><li><p>锁的隐含继承与释放</p><ol><li><p>进程终止时，建立的所有锁全部释放</p></li><li><p>关联的fd何时关闭，锁都会释放</p></li><li><p>fork 子进程只能继承文件描述符，不能继承它的锁</p></li></ol></li><li><p>文件尾端加锁</p></li><li><p>建议性锁和强制性锁</p></li></ul><h2 id="14-3-异步I-O"><a href="#14-3-异步I-O" class="headerlink" title="14.3 异步I/O"></a>14.3 异步I/O</h2><p>不建议用</p><h2 id="14-4-I-O多路转接-multiplexing"><a href="#14-4-I-O多路转接-multiplexing" class="headerlink" title="14.4 I/O多路转接(multiplexing)"></a>14.4 I/O多路转接(multiplexing)</h2><h3 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h3><ul><li><p>阻塞模式下在多个fd上写，一个block会导致后面的pending</p><ul><li><p>polling + 无阻塞可以解决</p></li><li><p>异步I/O 用信号通知</p><p>缺点在于不知道哪个fd ready（不够映射）</p></li><li><p>I/O多路复用</p></li></ul></li></ul><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><ul><li>select / pselect</li><li>pselect 支持 timespec 结构，更精确的时间</li><li>最多支持fd 有上限</li></ul><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><ul><li>通过数组表明关心的条件</li><li>解决了fd数量的瓶颈</li></ul><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><ul><li>linux I/O多路转接的最优机制</li><li>性能高<ul><li>规避了所有fd的用户态 copy 到内核态的开销<ul><li>fd常驻内核</li><li>内核以红黑树组织</li></ul></li><li>内核态只回传ready 部分的fd</li><li>边沿触发</li></ul></li></ul><h2 id="14-5-其他"><a href="#14-5-其他" class="headerlink" title="14.5 其他"></a>14.5 其他</h2><h3 id="readv-writev"><a href="#readv-writev" class="headerlink" title="readv / writev"></a>readv / writev</h3><ul><li><p>散布读(scatter read) / 聚集写(gather write)</p><ul><li><p>iovec 结构数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span>&#123;</span><br><span class="hljs-keyword">void</span> *iov_base;<br><span class="hljs-keyword">size_t</span> iov_len<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>降低系统调用的次数，获取性能</p></li></ul><h3 id="readn-writen"><a href="#readn-writen" class="headerlink" title="readn / writen"></a>readn / writen</h3><ul><li><p>apue 对 read / write 的一些容错封装</p></li><li><p>原因： 管道、FIFO、网络、终端</p><p>可能读的字节数小于指定数量</p><p>写可能因为内核缓冲区满而失效</p></li></ul><h3 id="mmap-munmap"><a href="#mmap-munmap" class="headerlink" title="mmap / munmap"></a>mmap / munmap</h3><ul><li><p>存储映射I/O</p><p>磁盘文件映射到内存空间</p><p>直接读写内存就是修改磁盘文件</p></li><li><p>mprotect</p><p>修改映射区权限</p></li><li><p>msync</p><p>立刻同步刷新</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0-tips&quot;&gt;&lt;a href=&quot;#0-tips&quot; class=&quot;headerlink&quot; title=&quot;0.tips&quot;&gt;&lt;/a&gt;0.tips&lt;/h1&gt;&lt;h2 id=&quot;输入输出问题&quot;&gt;&lt;a href=&quot;#输入输出问题&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux Cammand Line 阅读笔记</title>
    <link href="https://wuyifff.github.io/2021/10/17/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    <id>https://wuyifff.github.io/2021/10/17/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/</id>
    <published>2021-10-17T07:22:38.467Z</published>
    <updated>2021-10-17T07:39:51.329Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h1><ul><li>人们说，“图形用户界面让简单的任务更容易完成，而命令行界面使 完成复杂的任务成为可能”，到现在这句话仍然很正确。</li></ul><h1 id="2-什么是shell"><a href="#2-什么是shell" class="headerlink" title="2.什么是shell"></a>2.什么是shell</h1><h2 id="2-1终端仿真器"><a href="#2-1终端仿真器" class="headerlink" title="2.1终端仿真器"></a>2.1终端仿真器</h2><p>shell 就是一个程序，它接受从键盘输入的命令，然后 把命令传递给操作系统去执行</p><p>当使用图形用户界面时，我们需要另一个和 shell 交互的叫做终端仿真器的程序。</p><h2 id="2-2第一次按键"><a href="#2-2第一次按键" class="headerlink" title="2.2第一次按键"></a>2.2第一次按键</h2><p>用户名 @ 主机 名，紧接着当前工作目录和一个美元符号</p><p>如果提示符的最后一个字符是“#”, 而不是“$”, 那么这个终端会话就有超级用户权限。 这意味着，我们或者是以 root 用户的身份登录，或者是我们选择的终端仿真器提供超级用户 （管理员）权限。</p><h2 id="2-3命令历史"><a href="#2-3命令历史" class="headerlink" title="2.3命令历史"></a>2.3命令历史</h2><p>默认保存500</p><ul><li><p>上箭头得到上一次命令</p></li><li><p>按下鼠标左键拖动快速复制，鼠标中键粘贴==不要用ctrl c==</p></li><li><p>设置聚焦跟随鼠标代替单机聚焦，可以使复制粘贴更方便</p></li></ul><h2 id="2-4简单命令"><a href="#2-4简单命令" class="headerlink" title="2.4简单命令"></a>2.4简单命令</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">date<br>cal<span class="hljs-regexp">//</span>显示月历<br>df<span class="hljs-regexp">//</span>显示磁盘剩余空间<br>free<span class="hljs-regexp">//</span>空闲内存<br><span class="hljs-keyword">exit</span><span class="hljs-regexp">//</span>终止会话<br></code></pre></td></tr></table></figure><h2 id="2-5幕后控制台"><a href="#2-5幕后控制台" class="headerlink" title="2.5幕后控制台"></a>2.5幕后控制台</h2><ul><li><p>按下 Ctrl-Alt-F1 到 Ctrl-Alt-F6 访问</p></li><li><p>当一个会话被访问的时候，它会显示登录提示框，我们需要输入用户名和密码。</p></li><li><p>要从一 个虚拟控制台转换到另一个，按下 Alt 和 F1-F6(中的一个)。返回图形桌面，按下 Alt-F7</p></li></ul><h1 id="3-文件系统中跳转"><a href="#3-文件系统中跳转" class="headerlink" title="3.文件系统中跳转"></a>3.文件系统中跳转</h1><h2 id="3-1文件系统树"><a href="#3-1文件系统树" class="headerlink" title="3.1文件系统树"></a>3.1文件系统树</h2><ul><li>分层目录结构组织文件，所有文件组成一颗树型目录，倒置的树</li><li>总是只有一个单一的文件系统树，不管存储设备的连接（不像 Windows ，每个存储设备都有一个独自的文件系统）</li></ul><h2 id="3-2当前工作目录"><a href="#3-2当前工作目录" class="headerlink" title="3.2当前工作目录"></a>3.2当前工作目录</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">pwd</span><span class="hljs-string">//print</span> working directory显示当前目录<br><span class="hljs-keyword">ls</span><span class="hljs-string">//</span>列出一个目录包含的文件以及子目录<br><span class="hljs-keyword">ls</span> -a<br></code></pre></td></tr></table></figure><ul><li>当我们首次登录系统（或者启动终端仿真器会话）后，当前工作目录是我们的家目录。每个d用户都有他自己的家目录，当用户以普通用户的身份操控系统时，家目录是唯一允许用户写入文件的地方。</li><li>以 “.” 字符开头的文件名是隐藏文件，用<strong>ls -a</strong>命令</li><li><img src="https://i.loli.net/2021/05/09/eSIFcb9WpHRC2Od.png" alt="image-20210509210658151"></li></ul><h2 id="3-4更改当前工作目录"><a href="#3-4更改当前工作目录" class="headerlink" title="3.4更改当前工作目录"></a>3.4更改当前工作目录</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> <span class="hljs-string">/usr/bin</span><span class="hljs-string">//</span>绝对路径<br><span class="hljs-keyword">cd</span> <span class="hljs-string">..</span><span class="hljs-string">//</span>相对路径回到usr<br><span class="hljs-keyword">cd</span> <span class="hljs-string">./bin</span><span class="hljs-string">//</span>相对路径进入bin也可以直接<span class="hljs-keyword">cd</span> bin<br></code></pre></td></tr></table></figure><ul><li>绝对路径从根目录开始，直到它的目的地，而相对路径开始于工作目录</li><li>符号 “.” 指的是工作目录，”..” 指的是工作目录的父目录</li><li>==./是隐含的可以省略==</li></ul><p><img src="https://i.loli.net/2021/05/09/FNuxWrYnCG5Pv6E.png" alt="image-20210503151718776"></p><ul><li>文件名和命令名是大小写敏感的</li><li>文件没有拓展名，文件名可能包含空格，标点符号，但标点符号仅限 使用“.”，“－”，下划线，但是<strong>不要使用空格</strong></li></ul><h1 id="4-探究操作系统"><a href="#4-探究操作系统" class="headerlink" title="4.探究操作系统"></a>4.探究操作系统</h1><h2 id="4-1ls"><a href="#4-1ls" class="headerlink" title="4.1ls"></a>4.1ls</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">ls</span> <span class="hljs-string">/usr</span><span class="hljs-string">//</span>指定别的目录<br><span class="hljs-keyword">ls</span> ~ <span class="hljs-string">/usr</span><span class="hljs-string">//</span>指定多个目录（家目录和usr目录<br><span class="hljs-keyword">ls</span> -l <span class="hljs-string">//</span>以长模式输出<br></code></pre></td></tr></table></figure><ul><li>家目录用**~**代表</li></ul><h2 id="4-2选项和参数"><a href="#4-2选项和参数" class="headerlink" title="4.2选项和参数"></a>4.2选项和参数</h2><ul><li>大多数命令使用的选项，是由一个中划线加上一个字符组成，例如，“-l”，但是许多命令， 包括来自于 GNU 项目的命令，也支持长选项，长选项由两个中划线加上一个字组成。</li></ul><p><img src="https://i.loli.net/2021/05/09/VB2AWDIj95aCro1.png" alt="image-20210503153258807"></p><h2 id="4-3长格式输出"><a href="#4-3长格式输出" class="headerlink" title="4.3长格式输出"></a>4.3长格式输出</h2><p><img src="https://i.loli.net/2021/05/09/lyZe5n2GAqt3CDF.png" alt="image-20210503153900813"></p><h2 id="4-4确定文件类型"><a href="#4-4确定文件类型" class="headerlink" title="4.4确定文件类型"></a>4.4确定文件类型</h2><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-meta">file</span> <span class="hljs-meta">filename</span>//<span class="hljs-meta">file</span>命令打印文件内容的简单描述<br></code></pre></td></tr></table></figure><h2 id="4-5用less浏览文件内容"><a href="#4-5用less浏览文件内容" class="headerlink" title="4.5用less浏览文件内容"></a>4.5用less浏览文件内容</h2><ul><li>系统配置文件以文本格式储存</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">less filename<br>less <span class="hljs-regexp">/etc/</span>passwd<br></code></pre></td></tr></table></figure><p>按下<strong>q</strong>键退出less程序</p><p><img src="https://i.loli.net/2021/05/09/LUnIRdDK6xH3NEy.png" alt="image-20210503154749096"></p><p><img src="https://i.loli.net/2021/05/09/TGUYunWPIaeQ8Es.png" alt="image-20210503154821201"></p><h2 id="4-6浏览文件"><a href="#4-6浏览文件" class="headerlink" title="4.6浏览文件"></a>4.6浏览文件</h2><p>目录文件概览</p><p><img src="https://i.loli.net/2021/05/09/DstdF5mrvkyKEM1.png" alt="image-20210503163447945"></p><p><img src="https://i.loli.net/2021/05/09/cmJN4MFztTjoYS7.png" alt="image-20210503163522307"></p><p><img src="https://i.loli.net/2021/05/09/9G3hHiMfbAYNpmL.png" alt="image-20210503163533077"></p><h1 id="5-操作文件和目录"><a href="#5-操作文件和目录" class="headerlink" title="5.操作文件和目录"></a>5.操作文件和目录</h1><h2 id="5-1通配符"><a href="#5-1通配符" class="headerlink" title="5.1通配符"></a>5.1通配符</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ls <span class="hljs-regexp">/usr/</span>bin/t*<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/09/3ktnvrZ6DVbJoUc.png" alt="image-20210503164153279"></p><p><img src="https://i.loli.net/2021/05/09/C2cqUJ7GwjWR3KF.png" alt="image-20210503164224977"></p><p><img src="https://i.loli.net/2021/05/09/i5FIRYK8HZblUyA.png" alt="image-20210503164238485"></p><p><img src="https://i.loli.net/2021/05/09/rk59JXjBzKW8Ggd.png" alt="image-20210503164255229"></p><h2 id="5-2mkdir创建目录"><a href="#5-2mkdir创建目录" class="headerlink" title="5.2mkdir创建目录"></a>5.2mkdir创建目录</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mkdir</span> directory... //三个点表示参数可重复<br><span class="hljs-attribute">mkdir</span> dir<span class="hljs-number">1</span> dir<span class="hljs-number">2</span> dir<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="5-3cp复制文件或目录"><a href="#5-3cp复制文件或目录" class="headerlink" title="5.3cp复制文件或目录"></a>5.3cp复制文件或目录</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cp</span> item<span class="hljs-number">1</span> item<span class="hljs-number">2</span>//复制单个文件或目录item<span class="hljs-number">1</span>到item<span class="hljs-number">2</span><br><span class="hljs-attribute">cp</span> item... directory//复制多个项目到一个目录下<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/09/dgc9RnFShDr8Gzj.png" alt="image-20210503165042706"></p><p><img src="https://i.loli.net/2021/05/09/3WyqcJzPt6olvHY.png" alt="image-20210503165106591"></p><h2 id="5-4mv移动和重命名文件"><a href="#5-4mv移动和重命名文件" class="headerlink" title="5.4mv移动和重命名文件"></a>5.4mv移动和重命名文件</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mv</span> item<span class="hljs-number">1</span> item<span class="hljs-number">2</span><br><span class="hljs-attribute">mv</span> item... directory<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/09/4hvScjteluO76Ga.png" alt="image-20210503165417114"></p><h2 id="5-5rm删除文件和目录"><a href="#5-5rm删除文件和目录" class="headerlink" title="5.5rm删除文件和目录"></a>5.5rm删除文件和目录</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">rm</span></span> item...<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/09/34tPEqJuFDaU7Z1.png" alt="image-20210503165621012"></p><h2 id="5-6ln创建链接"><a href="#5-6ln创建链接" class="headerlink" title="5.6ln创建链接"></a>5.6ln创建链接</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">ln</span> <span class="hljs-built_in">file</span> link<span class="hljs-comment">//创建硬链接</span><br><span class="hljs-built_in">ln</span> -s <span class="hljs-keyword">item</span> link<span class="hljs-comment">//创建符号链接</span><br></code></pre></td></tr></table></figure><h2 id="5-7硬链接"><a href="#5-7硬链接" class="headerlink" title="5.7硬链接"></a>5.7硬链接</h2><ul><li><p>一个硬链接不能关联它所在文件系统之外的文件。</p></li><li><p>一个硬链接不能关联一个目录。</p></li></ul><h2 id="5-8符号链接（软链接-symlink）"><a href="#5-8符号链接（软链接-symlink）" class="headerlink" title="5.8符号链接（软链接/symlink）"></a>5.8符号链接（软链接/symlink）</h2><ul><li>类似于windows的快捷方式，其本身与其他符号链接几乎没有区别</li><li>向符号链接写入，写入相关联的文件，删除符号链接不会删除文件自身</li><li>坏链接为红色</li></ul><h2 id="5-9-playground练习（很重要）"><a href="#5-9-playground练习（很重要）" class="headerlink" title="5.9 playground练习（很重要）"></a>5.9 playground练习（很重要）</h2><ul><li>cp命令至少两个地址(本地用.)</li><li>cp -v 看详细做了什么， -i 获得提示</li><li>mv要么两个地址（移动），要么改名字</li><li>ln创建链接 <strong>-s</strong>符号链接 跟文件和目录</li><li>ls -li 可以看到文件索引结点 </li><li>创建符号链接可以绝对路径也可以相对路径</li></ul><h1 id="6-使用命令"><a href="#6-使用命令" class="headerlink" title="6.使用命令"></a>6.使用命令</h1><h2 id="6-1命令四种形式"><a href="#6-1命令四种形式" class="headerlink" title="6.1命令四种形式"></a>6.1命令四种形式</h2><ul><li>可执行程序，编程语言或脚本语言写成</li><li>内建于shell自身的命令,<strong>内建命令</strong></li><li><strong>shell函数</strong>，即小规模shell脚本，混合到环境变量中</li><li><strong>命令别名</strong>，自定义命令建立在其他命令之上</li></ul><h2 id="6-2-type显示命令的类型"><a href="#6-2-type显示命令的类型" class="headerlink" title="6.2 type显示命令的类型"></a>6.2 type显示命令的类型</h2><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-keyword">type</span><br><span class="hljs-keyword">type</span> ls<br></code></pre></td></tr></table></figure><h2 id="6-3-显示一个可执行程序的位置"><a href="#6-3-显示一个可执行程序的位置" class="headerlink" title="6.3 显示一个可执行程序的位置"></a>6.3 显示一个可执行程序的位置</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">which</span> <span class="hljs-keyword">ls</span><br></code></pre></td></tr></table></figure><p>这个命令只对可执行程序有效，不包括内建命令和命令别名，别名是真正的可执行程序的替代物</p><h2 id="6-4-help得到shell内建命令的帮助文档"><a href="#6-4-help得到shell内建命令的帮助文档" class="headerlink" title="6.4 help得到shell内建命令的帮助文档"></a>6.4 help得到shell内建命令的帮助文档</h2><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">help</span> <span class="hljs-built_in">cd</span><br><span class="hljs-built_in">mkdir</span> --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p><strong>–help</strong>显示用法信息</p><h2 id="6-5-man显示程序手册页"><a href="#6-5-man显示程序手册页" class="headerlink" title="6.5 man显示程序手册页"></a>6.5 man显示程序手册页</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">man</span> <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>man使用less显示参考手册，可以使用less命令进行浏览</p><p>man参考手册分成的章节：</p><p><img src="https://i.loli.net/2021/05/09/Yai7qIrHvQK4Ebp.png" alt="image-20210509164918894"></p><p><img src="https://i.loli.net/2021/05/09/3Gobfrdm4ItChxw.png" alt="image-20210509164939272"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">man</span> <span class="hljs-number">5</span> passwd<br></code></pre></td></tr></table></figure><p>如果不成功显示No manual entry for passwd in section 5</p><p>则需要yum install man-pages</p><h2 id="6-6-apropos显示适当的命令"><a href="#6-6-apropos显示适当的命令" class="headerlink" title="6.6 apropos显示适当的命令"></a>6.6 apropos显示适当的命令</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">apropos floppy<br>man -k floppy<span class="hljs-regexp">//</span>功能同上<br></code></pre></td></tr></table></figure><p>输出结果每行的第一个字段是手册页的名字，第二个字段展示章节</p><h2 id="6-7-whatis显示简洁的命令说明"><a href="#6-7-whatis显示简洁的命令说明" class="headerlink" title="6.7 whatis显示简洁的命令说明"></a>6.7 whatis显示简洁的命令说明</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">whatis 命令<span class="hljs-regexp">/系统调用/</span>库函数/特殊文件名<br></code></pre></td></tr></table></figure><p>相当于man -f</p><h2 id="6-8-info显示程序info条目"><a href="#6-8-info显示程序info条目" class="headerlink" title="6.8 info显示程序info条目"></a>6.8 info显示程序info条目</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">info</span> ls<br></code></pre></td></tr></table></figure><p>info 文件是树型结构,包含超链接，可以从*号处跳转到另一个结点</p><p><img src="https://i.loli.net/2021/05/09/dCOj72tezXgs39f.png" alt="image-20210509171548454"></p><h2 id="6-9-README以及其他程序文档"><a href="#6-9-README以及其他程序文档" class="headerlink" title="6.9 README以及其他程序文档"></a>6.9 README以及其他程序文档</h2><ul><li><p>许多安装在你系统中的软件，都有自己的文档文件，这些文件位于/usr/share/doc 目录下。大多数是以文本文件的形式存储的，可用 less 阅读器来浏览。</p></li><li><p>以 “.gz” 结尾的文件表示 gzip压缩程序已经压缩了这些文件。gzip软件包包括一个特殊的 less 版本，叫做 zless，zless 可以显示由 gzip 压缩 的文本文件的内容。</p></li></ul><h2 id="6-10用别名（alias）创建命令"><a href="#6-10用别名（alias）创建命令" class="headerlink" title="6.10用别名（alias）创建命令"></a>6.10用别名（alias）创建命令</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">alias</span> foo=&#x27;<span class="hljs-keyword">cd</span> <span class="hljs-string">/usr</span>; <span class="hljs-keyword">ls</span>; <span class="hljs-keyword">cd</span> -&#x27;<br><span class="hljs-keyword">alias</span> name=&#x27;string&#x27;<span class="hljs-string">//</span>格式<br>type foo<br><span class="hljs-keyword">unalias</span> foo<span class="hljs-string">//</span>删除别名<br></code></pre></td></tr></table></figure><ul><li><p>在命令 “alias” 之后，输入“name”，紧接着（**<em>没有空格</em> **）是一个等号，等号之后是一串用引 号引起的字符串，字符串的内容要赋值给 name。</p></li><li><p>通常经常使用的命令带有普遍用到的选项，例如    ls is aliased to `ls –color=auto’，使用不带参数的alias查看默认定义的别名</p></li><li><p>==在命令行中定义别名有点儿小问题。当你的 shell 会话结束时，它们会消失。==</p></li></ul><h1 id="7-I-O重定向"><a href="#7-I-O重定向" class="headerlink" title="7.I/O重定向"></a>7.I/O重定向</h1><h2 id="7-1标准输入输出和错误"><a href="#7-1标准输入输出和错误" class="headerlink" title="7.1标准输入输出和错误"></a>7.1标准输入输出和错误</h2><ul><li>默认情况下，标准输出stdout和标准错误都连接屏幕而不是磁盘文件。</li><li>标准输入stdin默认情况下连接键盘</li><li><strong>I/O重定向</strong>允许我们更改输出地点和输入来源</li></ul><h2 id="7-2标准输出重定向"><a href="#7-2标准输出重定向" class="headerlink" title="7.2标准输出重定向"></a>7.2标准输出重定向</h2><ul><li>用 <strong>&gt;</strong>  重定向符接文件名</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">ls -l <span class="hljs-regexp">/usr/</span>bin &gt; ls-output.txt<span class="hljs-regexp">//</span>直接创建文件<br>less le-output.txt<br></code></pre></td></tr></table></figure><ul><li><strong>当我们使用 “&gt;” 重定向符来重定向输出结果时，目标文件总是 从开头被重写</strong>（如果错误了就清空文件）</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">&gt; ls-output.txt<span class="hljs-regexp">//</span>故意用重定向符来清空文件内容<br>ls -l <span class="hljs-regexp">/usr/</span>bin &gt;&gt; ls-output.txt<br></code></pre></td></tr></table></figure><ul><li>用 &gt;&gt; 操作符可以把输出结果加到文件内容之后，如果文件不存在则会被创建</li></ul><h2 id="7-3标准错误重定向"><a href="#7-3标准错误重定向" class="headerlink" title="7.3标准错误重定向"></a>7.3标准错误重定向</h2><ul><li>一一个程序可以在几个编号的文件流中的任一个上产生输出。前三个称作标准输入、输出和错误，shell 内部分别将其称为文件描述符 0、1 和 2</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ls -l <span class="hljs-regexp">/bin/u</span>sr <span class="hljs-number">2</span>&gt; ls-error.txt<span class="hljs-regexp">//</span>测试错误输出<br></code></pre></td></tr></table></figure><h2 id="7-4-重定向标准输出和错误到同一个文件"><a href="#7-4-重定向标准输出和错误到同一个文件" class="headerlink" title="7.4 重定向标准输出和错误到同一个文件"></a>7.4 重定向标准输出和错误到同一个文件</h2><ul><li>方法一</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ls</span> -l /bin/usr &gt; ls-output.txt <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>完成两个重定向，首先重定向标准输出到文件，然后重定向标准错误到标准输出，用2&gt;&amp;1。</strong></p><p><strong>注意重定向的顺序安排非常重要。标准错误的重定向必须总是出现在标准输出重定向之后， 要不然它不起作用。</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&gt; ls-output.txt <span class="hljs-number">2</span>&gt;<span class="hljs-meta">&amp;1<span class="hljs-comment">//重定向标准错误到文件 ls-output.txt</span></span><br><span class="hljs-number">2</span>&gt;<span class="hljs-meta">&amp;1 &gt; ls-output.txt<span class="hljs-comment">//标准错误定向到屏幕</span></span><br></code></pre></td></tr></table></figure><ul><li>方法二</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ls -l <span class="hljs-regexp">/bin/u</span>sr &amp;&gt; ls-output.txt<br></code></pre></td></tr></table></figure><p>用 &amp;&gt; 来重定向标准输出和错误到文件 ls-output.txt</p><h2 id="7-5处理不需要的输出"><a href="#7-5处理不需要的输出" class="headerlink" title="7.5处理不需要的输出"></a>7.5处理不需要的输出</h2><ul><li>不想要一个命令的输出结果，系统重定向输出结果到 /dev/null 的特殊文件</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">ls -l <span class="hljs-regexp">/bin/u</span>sr <span class="hljs-number">2</span>&gt; <span class="hljs-regexp">/dev/</span><span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><h2 id="7-6-cat连接文件"><a href="#7-6-cat连接文件" class="headerlink" title="7.6 cat连接文件"></a>7.6 cat连接文件</h2><ul><li>cat 命令读取一个或多个文件，然后复制它们到标准输出</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">cat</span> [<span class="hljs-keyword">file</span>]<span class="hljs-comment">//复制到标准输出</span><br>cate <span class="hljs-keyword">ls</span>-output.txt<span class="hljs-comment">//显示简短的文本文件</span><br><span class="hljs-keyword">cat</span> -<span class="hljs-keyword">n</span> textfile1 &gt; textfile2<span class="hljs-comment">//把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里,换成&gt;&gt;为附加到文档中</span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat&gt; lazy_dog.txt<span class="hljs-regexp">//</span>等待输入<br>wowowo.<span class="hljs-regexp">//</span>ctrl d结束<br>cat lazy_dog.txt<span class="hljs-regexp">//</span>复制文件内容到标准输出<br>cat &lt; lazy_dog.txt <span class="hljs-regexp">//</span>重定向标准输入，输入源为lazy_dog.txt<br></code></pre></td></tr></table></figure><h2 id="7-7管道线"><a href="#7-7管道线" class="headerlink" title="7.7管道线"></a>7.7管道线</h2><ul><li>管道线使得标准输入读取数据并输送到标准输出，一个命令的标准输出可以通过管道传到另一个命令的标准输入</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">command</span>1 | <span class="hljs-keyword">command</span>2<br><span class="hljs-keyword">ls</span> -l <span class="hljs-string">/usr/bin</span> | less<span class="hljs-string">//</span>不加less则直接输出到最后一行等待下一步命令，有less变成浏览文本文件<br></code></pre></td></tr></table></figure><ul><li>可以很方便的检测会产生标准输出的命令的运行结果</li></ul><h2 id="7-8过滤器"><a href="#7-8过滤器" class="headerlink" title="7.8过滤器"></a>7.8过滤器</h2><ul><li>用来对数据完成复杂操作，把几个命令放在一起组成一个管道线，过滤器接受输入，以某种方式改变它，然后输出它。</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">ls</span> <span class="hljs-string">/bin</span> <span class="hljs-string">/usr/bin</span> | sort | less<span class="hljs-string">//</span>产生两个目录的有序列表<br></code></pre></td></tr></table></figure><h2 id="7-9-uniq-报道或忽略重复行"><a href="#7-9-uniq-报道或忽略重复行" class="headerlink" title="7.9 uniq 报道或忽略重复行"></a>7.9 uniq 报道或忽略重复行</h2><ul><li>uniq 经常和 sort 命令结合起来一起使用，默认情况下在数据列表中删除任何重复行</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">ls</span> <span class="hljs-string">/bin</span> <span class="hljs-string">/usr/bin</span> | sort | uniq | less<br><span class="hljs-keyword">ls</span> <span class="hljs-string">/bin</span> <span class="hljs-string">/usr/bin</span> | sort | uniq -d | less<span class="hljs-string">//</span>只看重复数据列表<br></code></pre></td></tr></table></figure><h2 id="7-10-wc-打印行数字数和字节数"><a href="#7-10-wc-打印行数字数和字节数" class="headerlink" title="7.10 wc 打印行数字数和字节数"></a>7.10 wc 打印行数字数和字节数</h2><ul><li>wc（字计数）命令是用来显示文件所包含的行数、字数和字节数。</li><li>如果 wc 不带命令行参数，它接受标准输入。“-l” 选项限制命令输出只能报道行数。添加 wc 到管道线来统计数据，是个很便利的方法。查看我们的有序列表中程序个数</li></ul><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coq">wc ls-output.txt<br>ls /bin /usr/bin | <span class="hljs-type">sort</span> | <span class="hljs-type">uniq</span> | <span class="hljs-type">wc</span> -l<br></code></pre></td></tr></table></figure><h2 id="7-11-grep打印匹配行"><a href="#7-11-grep打印匹配行" class="headerlink" title="7.11 grep打印匹配行"></a>7.11 grep打印匹配行</h2><ul><li>grep用来找到文件中的匹配文本</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">grep</span> pattern [<span class="hljs-keyword">file</span>...]<span class="hljs-comment">//使用方法</span><br>ls <span class="hljs-regexp">/bin /u</span>sr<span class="hljs-regexp">/bin | sort |uniq | grep zip/</span><span class="hljs-regexp">/找到文件名中包含单词zip的所有文件</span><br></code></pre></td></tr></table></figure><ul><li> grep   -i 忽略大小写  -v  只打印不匹配的行</li></ul><h2 id="7-12-head-tail打印文件开头部分-结尾部分"><a href="#7-12-head-tail打印文件开头部分-结尾部分" class="headerlink" title="7.12 head/tail打印文件开头部分/结尾部分"></a>7.12 head/tail打印文件开头部分/结尾部分</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">head -n <span class="hljs-number">5</span> ls-output.txt<br>tail -n <span class="hljs-number">10</span> ls-output.txt<br>ls -l <span class="hljs-regexp">/usr/</span>bin | tail -n <span class="hljs-number">5</span> <span class="hljs-regexp">//</span>用于管道线中<br>tail -f <span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/messages/</span><span class="hljs-regexp">/循环读取，跟踪增长情况</span><br></code></pre></td></tr></table></figure><h2 id="7-13-tee从stdin读取数据，并同时输出到stdout和文件"><a href="#7-13-tee从stdin读取数据，并同时输出到stdout和文件" class="headerlink" title="7.13 tee从stdin读取数据，并同时输出到stdout和文件"></a>7.13 tee从stdin读取数据，并同时输出到stdout和文件</h2><ul><li>tee 程序从标准输入读入数据，并且同时复制数据到标准输出（允许数据继续随着管道线流动和一个或多个文件。当在某个中间处理阶段来捕捉一个管道线的内容时，这很有帮助。</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">ls <span class="hljs-regexp">/usr/</span>bin | tee ls.txt | <span class="hljs-keyword">grep</span> zip<br></code></pre></td></tr></table></figure><ul><li>在 grep 过滤 管道线的内容之前，来捕捉整个目录列表到文件 ls.txt</li></ul><h1 id="8-从shell眼中看世界"><a href="#8-从shell眼中看世界" class="headerlink" title="8.从shell眼中看世界"></a>8.从shell眼中看世界</h1><h2 id="8-1-（字符）展开"><a href="#8-1-（字符）展开" class="headerlink" title="8.1 （字符）展开"></a>8.1 （字符）展开</h2><ul><li>echo 命令显示一行文本</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">echo</span> this is a test<span class="hljs-string">//</span>测试<span class="hljs-keyword">echo</span><br><span class="hljs-keyword">echo</span> *<span class="hljs-string">//</span>观察*的展开,打印了所有文件<br></code></pre></td></tr></table></figure><ul><li>shell 中 * 会被展开，当回车键被按下时，shell 在命令被执行前在命令行上自动展开任何符合条件的字符，所以 echo 命令的实际参数并不是 “*”，而 是它展开后的结果。</li></ul><h2 id="8-2-路径名展开"><a href="#8-2-路径名展开" class="headerlink" title="8.2 路径名展开"></a>8.2 路径名展开</h2><ul><li>通配符所依赖的工作机制叫做路径名展开</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">echo</span> <span class="hljs-string">/usr/</span>*<span class="hljs-string">/share</span><br></code></pre></td></tr></table></figure><ul><li>隐藏文件的路径名展开</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">echo .*<span class="hljs-regexp">//</span>隐藏文件均以原点开头，但是输出包含 <span class="hljs-string">&#x27;.&#x27;</span> 和 <span class="hljs-string">&#x27;..&#x27;</span><br>ls -d .* | less<span class="hljs-regexp">//</span>-d表示只显示当前目录文件，展开正确<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/09/jWC7UYn6ocb1wNM.png" alt="image-20210509211225734"></p><h2 id="8-3波浪线展开"><a href="#8-3波浪线展开" class="headerlink" title="8.3波浪线展开"></a>8.3波浪线展开</h2><ul><li>用在一个单词开头时，它会展开成指定用户的家目录名，如果没有指定用户名，则展开成当前用户的家目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> ~<br><span class="hljs-built_in">echo</span> ~root<br></code></pre></td></tr></table></figure><h2 id="8-4-算术表达式展开"><a href="#8-4-算术表达式展开" class="headerlink" title="8.4 算术表达式展开"></a>8.4 算术表达式展开</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> $((expression))<br><span class="hljs-built_in">echo</span> 5+$((<span class="hljs-number">9</span>-<span class="hljs-number">8</span>))<br></code></pre></td></tr></table></figure><h2 id="8-5-花括号展开"><a href="#8-5-花括号展开" class="headerlink" title="8.5 花括号展开"></a>8.5 花括号展开</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">echo</span> <span class="hljs-built_in">Front</span><span class="hljs-operator">-</span><span class="hljs-punctuation">&#123;</span><span class="hljs-variable">A</span><span class="hljs-operator">,</span><span class="hljs-variable">B</span><span class="hljs-operator">,</span><span class="hljs-built_in">C</span><span class="hljs-punctuation">&#125;</span><span class="hljs-operator">-</span><span class="hljs-built_in">Back</span><br></code></pre></td></tr></table></figure><ul><li>花括号展开模式可能包含一个开头部分叫做<strong>报头</strong>，一个结尾部分叫做<strong>附言</strong>。花括号表达式 本身可能包含一个由<strong>逗号分开</strong>的字符串列表，或者一个<strong>整数区间</strong>，或者单个的字符的区间。这 种模式不能嵌入空白字符</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">echo</span> Number &#123;1.<span class="hljs-string">.5</span>&#125;<br><span class="hljs-keyword">echo</span> &#123;Z.<span class="hljs-string">.A</span>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>花括号展开可以嵌套</strong>，最常见的应用是，创建一系列的文件或目录列表</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mkdir</span> Pics<br><span class="hljs-attribute">cd</span> Pics<br><span class="hljs-attribute">mkdir</span> &#123;<span class="hljs-number">2007</span>..<span class="hljs-number">2019</span>&#125;-<span class="hljs-number">0</span>&#123;<span class="hljs-number">1</span>..<span class="hljs-number">9</span>&#125; &#123;<span class="hljs-number">2007</span>..<span class="hljs-number">2019</span>&#125;-&#123;<span class="hljs-number">10</span>..<span class="hljs-number">12</span>&#125;<br><span class="hljs-attribute">ls</span><br></code></pre></td></tr></table></figure><h2 id="8-6-命令替换"><a href="#8-6-命令替换" class="headerlink" title="8.6 命令替换"></a>8.6 命令替换</h2><ul><li>命令替换允许我们把一个命令的输出作为一个展开模式来使用</li><li>不只限制于简单命令,也可以使用整个管道 线</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">ls -l <span class="hljs-constructor">$(<span class="hljs-params">which</span> <span class="hljs-params">cd</span>)</span><span class="hljs-comment">//which得到cd命令的地址，ls显示文件信息</span><br>file <span class="hljs-constructor">$(<span class="hljs-params">ls</span> <span class="hljs-operator">/</span><span class="hljs-params">usr</span><span class="hljs-operator">/</span><span class="hljs-params">bin</span><span class="hljs-operator">/</span><span class="hljs-operator">*</span> | <span class="hljs-params">grep</span> <span class="hljs-params">zip</span>)</span><span class="hljs-comment">//用于管道线，管道线输出结果为file命令的参数列表</span><br></code></pre></td></tr></table></figure><h2 id="8-7-引用"><a href="#8-7-引用" class="headerlink" title="8.7 引用"></a>8.7 引用</h2><ul><li><strong>双引号</strong> 把文本放在双引号中，shell 使用的特殊字 符，都失去它们的特殊含义，被当作普通字符来看待</li><li>在双引号中，<strong>参数展开</strong>、<strong>算术表达式展开和命令替换仍然有效</strong></li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">ls</span> -l <span class="hljs-string">&quot;two words.txt&quot;</span><span class="hljs-string">//</span>防止单词分割<br><span class="hljs-keyword">echo</span> $<span class="hljs-params">(cal)</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;$(cal)&quot;</span><span class="hljs-string">//</span>在第一个实例中，没有引用的命令替换导致命令行包含38 个参数。在第二个例子中，命令行只有一个参数，参数中包括嵌入的空格和换行符。<br></code></pre></td></tr></table></figure><ul><li><strong>单引号</strong> 禁止所有展开，<strong>包括转义字符</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> text ~/*.txt &#123;a,b&#125; $(<span class="hljs-built_in">echo</span> foo) $((<span class="hljs-number">2</span>+<span class="hljs-number">2</span>)) <span class="hljs-variable">$USER</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;text ~/*.txt &#123;a,b&#125; <span class="hljs-subst">$(echo foo)</span> <span class="hljs-subst">$((2+2)</span>) <span class="hljs-variable">$USER</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/16/vLt2gD7FqImXs1l.png" alt="image-20210516212438539"></p><h2 id="8-8-转义字符"><a href="#8-8-转义字符" class="headerlink" title="8.8 转义字符"></a>8.8 转义字符</h2><ul><li>\ 作为转义字符，<strong>阻止展开</strong>、<strong>消除特殊含义字符</strong>(比如$)</li><li>在文件名包含特殊字符时起作用</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The balance for user <span class="hljs-variable">$USER</span> is: \$5.00&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The balance for user <span class="hljs-variable">$USER</span> is: <span class="hljs-variable">$5</span>.00&quot;</span><br></code></pre></td></tr></table></figure><h1 id="9-键盘高级操作"><a href="#9-键盘高级操作" class="headerlink" title="9 键盘高级操作"></a>9 键盘高级操作</h1><h2 id="9-1-移动光标"><a href="#9-1-移动光标" class="headerlink" title="9.1 移动光标"></a>9.1 移动光标</h2><p><img src="https://i.loli.net/2021/05/16/uBoMmTyZ1h6O8pY.png" alt="image-20210516214256754"></p><p><img src="https://i.loli.net/2021/05/16/uzLkp8iWBnDydVQ.png" alt="image-20210516214317134"></p><h2 id="9-2-修改文本"><a href="#9-2-修改文本" class="headerlink" title="9.2 修改文本"></a>9.2 修改文本</h2><p><img src="https://i.loli.net/2021/05/16/zSIBo6ApVjiXK1t.png" alt="image-20210516214447911"></p><h2 id="9-3-剪切和粘贴文本"><a href="#9-3-剪切和粘贴文本" class="headerlink" title="9.3 剪切和粘贴文本"></a>9.3 剪切和粘贴文本</h2><p><img src="https://i.loli.net/2021/05/16/2byUAgY1EZij9dF.png" alt="image-20210516214558968"></p><h2 id="9-4-自动补全"><a href="#9-4-自动补全" class="headerlink" title="9.4 自动补全"></a>9.4 自动补全</h2><ul><li>按下tab，<strong>自动补全路径名</strong>、<strong>对变量补全</strong>、<strong>用户名</strong>、<strong>命令</strong>、<strong>主机名</strong></li></ul><p><img src="https://i.loli.net/2021/05/16/KutXY6kR3BIFNSm.png" alt="image-20210516215654911"></p><h2 id="9-5-利用历史命令"><a href="#9-5-利用历史命令" class="headerlink" title="9.5 利用历史命令"></a>9.5 利用历史命令</h2><ul><li>搜索历史命令</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">history | less <span class="hljs-regexp">//</span>浏览历史列表的内容<br>history | grep <span class="hljs-regexp">/usr/</span>bin<br>!<span class="hljs-number">88</span><span class="hljs-regexp">//</span>展开历史列表中<span class="hljs-number">88</span>行的内容<br></code></pre></td></tr></table></figure><ul><li>ctrl-r进入搜索</li></ul><p><img src="https://i.loli.net/2021/05/16/oiT3qkejra7hNlZ.png" alt="image-20210516220947075"></p><p><img src="https://i.loli.net/2021/05/16/2gcmzBNGIEpxy56.png" alt="image-20210516220959790"></p><h2 id="9-8-历史命令展开"><a href="#9-8-历史命令展开" class="headerlink" title="9.8 历史命令展开"></a>9.8 历史命令展开</h2><p><img src="https://i.loli.net/2021/05/16/yMKihNQA8zb9w7c.png" alt="image-20210516221107108"></p><h1 id="10-权限"><a href="#10-权限" class="headerlink" title="10 权限"></a>10 权限</h1><h2 id="10-1-拥有者、组成员和其他人"><a href="#10-1-拥有者、组成员和其他人" class="headerlink" title="10.1 拥有者、组成员和其他人"></a>10.1 拥有者、组成员和其他人</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">id<span class="hljs-regexp">//</span>显示用户id并且映射到一个用户名<br></code></pre></td></tr></table></figure><ul><li>用户帐户定义在/etc/passwd 文件里面,用户组定义在/etc/group</li></ul><h2 id="10-2-读取写入和执行"><a href="#10-2-读取写入和执行" class="headerlink" title="10.2 读取写入和执行"></a>10.2 读取写入和执行</h2><p><img src="https://i.loli.net/2021/05/17/eWbKZa19Sig8xMR.png" alt="image-20210517082421786"></p><p><img src="https://i.loli.net/2021/05/17/xRAJLGdOCZpetN1.png" alt="image-20210517082452333"></p><ul><li>剩下的九个字符叫做文件模式，代表着文件所有者、文件组所有者和其他人的读、写和执 行权限。</li></ul><table><thead><tr><th>owner</th><th>group</th><th>world</th></tr></thead><tbody><tr><td>rwx</td><td>rwx</td><td>rwx</td></tr></tbody></table><table><thead><tr><th>属性</th><th>文件</th><th align="center">目录</th></tr></thead><tbody><tr><td>r</td><td>允许打开并 读取文件内 容</td><td align="center">允许列出目录中的内容，前提是目录必须设置了可执 行属性（x）</td></tr><tr><td>w</td><td>允许写入文 件内容或截 断文件。但 是 不允 许 对文件进行重命名或删 除，重命名 或删除是由 目录的属性 决定的</td><td align="center">允许在目录下新建、删除或重命名文件，前提是目录 必须设置了可执行属性（x）</td></tr><tr><td>x</td><td>允许将文件 作为程序来 执行，使用 脚本语言编 写的程序必 须设置为可 读才能被执 行。</td><td align="center">允许进入目录，例如：cd directory</td></tr></tbody></table><p><img src="https://i.loli.net/2021/05/17/hudfGzH9YXKQUoy.png" alt="image-20210517084100337"></p><h2 id="10-3-chomod更改文件模式"><a href="#10-3-chomod更改文件模式" class="headerlink" title="10.3 chomod更改文件模式"></a>10.3 chomod更改文件模式</h2><p>分为八进制表示法和符号表示法两种</p><ul><li>八进制对应3个二进制数字，正好用于映射存储文件模式所使用的方案</li></ul><p><img src="https://i.loli.net/2021/05/17/jcXRZST5bxfyost.png" alt="image-20210517084424709"></p><p><img src="https://i.loli.net/2021/05/17/jXoYl6UBkHpKQLZ.png" alt="image-20210517084701149"></p><p><code>chomod 600 foo.txt</code></p><ul><li>常见映射7 (rwx)，6 (rw-)，5 (r-x)，4 (r–)，和 0 (—)</li></ul><p><img src="https://i.loli.net/2021/05/17/mKYhNkQyPbc94n3.png" alt="image-20210517084931091"></p><table><thead><tr><th>符号表示法</th><th>操作内容</th></tr></thead><tbody><tr><td>u+x</td><td>为文件所有者添加可执行权限</td></tr><tr><td>u-x</td><td>为文件所有者添加可执行权限</td></tr><tr><td>+x</td><td>为文件所有者，用户组，和其他所有人添加可执行权限。等 价于 a+x</td></tr><tr><td>o-rw</td><td>除了文件所有者和用户组，删除其他人的读权限和写权限</td></tr><tr><td>go=rw</td><td>给文件所属的组和文件所属者/组以外的人读写权限。如果 文件所属组或其他人已经拥有执行的权限，执行权限将被移 除</td></tr><tr><td>u+x,go=rw</td><td>给文件拥有者执行权限并给组和其他人读和执行的权限。 多种设定可以用逗号分开</td></tr></tbody></table><h2 id="10-4-借助GUI来设置文件模式"><a href="#10-4-借助GUI来设置文件模式" class="headerlink" title="10.4 借助GUI来设置文件模式"></a>10.4 借助GUI来设置文件模式</h2><ul><li>右击文件或者目录图标</li></ul><p><img src="https://i.loli.net/2021/05/17/J4PnSak8cEHus3z.png" alt="image-20210517085505660"></p><h2 id="10-5-umask设置默认权限"><a href="#10-5-umask设置默认权限" class="headerlink" title="10.5 umask设置默认权限"></a>10.5 umask设置默认权限</h2><table><thead><tr><th>umask值</th><th>权限</th></tr></thead><tbody><tr><td>0000</td><td>-rw-rw-rw-</td></tr><tr><td>0002</td><td>-rw-rw-r–</td></tr></tbody></table><p>有二进制数字1的位置属性被删除</p><p><img src="https://i.loli.net/2021/05/17/JhOeiR3IjDVkBaA.png" alt="image-20210517090349654"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">umask<span class="hljs-regexp">//</span>得到掩码值<br>umask <span class="hljs-number">0000</span><span class="hljs-regexp">//</span>设置掩码值<br></code></pre></td></tr></table></figure><ul><li>setuid、setgid、sticky位特殊权限</li></ul><p><img src="https://i.loli.net/2021/05/17/q6xOAMbG7DvVsQp.png" alt="image-20210517093707217"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">chmod u+s program<span class="hljs-regexp">//</span>授予一个程序 setuid 权限<br>chmod g+s dir<span class="hljs-regexp">//</span>授予一个目录 setgid 权限<br>chmod +t dir<span class="hljs-regexp">//</span>授予一个目录 sticky 权限<br></code></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>结果</th></tr></thead><tbody><tr><td>具有 setuid 属性的程序</td><td>-rw**<u>s</u>**r-xr-x</td></tr><tr><td>具有 setgid 属性的目录</td><td>drwxrw**<u>s</u>**r-x</td></tr><tr><td>设置了 sticky 位的目录</td><td>drwxrwxrw<u><strong>t</strong></u></td></tr></tbody></table><h2 id="10-6-更改身份"><a href="#10-6-更改身份" class="headerlink" title="10.6 更改身份"></a>10.6 更改身份</h2><ol><li>注销系统并以其他用户身份重新登录系统。</li><li> 使用 su 命令</li><li>使用 sudo 命令</li></ol><h2 id="10-7-su命令"><a href="#10-7-su命令" class="headerlink" title="10.7 su命令"></a>10.7 su命令</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">su <span class="hljs-comment">[-<span class="hljs-comment">[l]</span>]</span> <span class="hljs-comment">[user]</span><br></code></pre></td></tr></table></figure><ul><li><p>如果包含 “-l” 选项，那么会为指定用户启动一个需要登录的 shell。这意味着会加载此用户 的 shell 环境，并且工作目录会更改到这个用户的家目录。这通常是我们所需要的。**-l可以缩写为-**</p></li><li><p>如果不指 定用户，那么就假定是超级用户</p></li><li><p>输入exit回到原来的shell</p></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">su -c <span class="hljs-string">&#x27;command&#x27;</span><span class="hljs-regexp">//</span>格式<br>su -c <span class="hljs-string">&#x27;ls -l /root/*&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>传递命令command到新的shell中执行，而不启动这个shell，<strong>引号防止命令展开</strong></li></ul><h2 id="10-8-sudo命令"><a href="#10-8-sudo命令" class="headerlink" title="10.8 sudo命令"></a>10.8 sudo命令</h2><ul><li>sudo 命令不要求超级用户的密码，使用 sudo 命令时，用户 使用他/她自己的密码来认证</li><li>管理员能够配置 sudo 命令，从而允许一个普通用户以不同的身份（通常是超级用户），通过一种非常可控的方式来执行命令</li><li>su 和 sudo 之间的一个重要区别是 sudo 不会重新启动一个 shell，也不会加载 另一个用户的 shell 运行环境</li></ul><h2 id="10-9-chown更改文件所有者和用户组"><a href="#10-9-chown更改文件所有者和用户组" class="headerlink" title="10.9 chown更改文件所有者和用户组"></a>10.9 chown更改文件所有者和用户组</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">chown <span class="hljs-comment">[owner]</span><span class="hljs-comment">[:<span class="hljs-comment">[group]</span>]</span> file<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/17/7x8GI3KmLXQdzCo.png" alt="image-20210517092431871"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-attr">[janet@linuxbox ~]</span>$ sudo cp myfile<span class="hljs-selector-class">.txt</span> ~tony<span class="hljs-comment">//用户 janet 把文件从她的目录复制到 tony 的家目录</span><br>Password:<br><span class="hljs-selector-attr">[janet@linuxbox ~]</span>$ sudo ls -l ~tony/myfile<span class="hljs-selector-class">.txt</span><br>-rw-r--r-- <span class="hljs-number">1</span> root root <span class="hljs-number">8031</span> <span class="hljs-number">2008</span>-<span class="hljs-number">03</span>-<span class="hljs-number">20</span> <span class="hljs-number">14</span>:<span class="hljs-number">30</span> /home/tony/myfile<span class="hljs-selector-class">.txt</span><br><span class="hljs-selector-attr">[janet@linuxbox ~]</span>$ sudo chown tony: ~tony/myfile<span class="hljs-selector-class">.txt</span><span class="hljs-comment">//janet 把文件所有者从 root（使用 sudo 命令的原因）改到 tony,同时把文件用户组改为 tony 登录系统时，所属的用户组，碰巧是用户组 tony</span><br><span class="hljs-selector-attr">[janet@linuxbox ~]</span>$ sudo ls -l ~tony/myfile<span class="hljs-selector-class">.txt</span><br>-rw-r--r-- <span class="hljs-number">1</span> tony tony <span class="hljs-number">8031</span> <span class="hljs-number">2008</span>-<span class="hljs-number">03</span>-<span class="hljs-number">20</span> <span class="hljs-number">14</span>:<span class="hljs-number">30</span> /home/tony/myfile.txt<br></code></pre></td></tr></table></figure><p><strong>可能存在的问题：</strong></p><ul><li><p>系统中默认的掩码值是 0022，这会禁止用户组成员编辑 属于同组成员的文件，<strong>修改掩码值解决</strong></p></li><li><p>用户组成员创建的文件和目录的用户组，将会设置为用户的主要组，而不是想要的用户组，<strong>设置此目录的setgid位来解决</strong></p></li></ul><h2 id="10-10-更改用户密码"><a href="#10-10-更改用户密码" class="headerlink" title="10.10 更改用户密码"></a>10.10 更改用户密码</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">passwd</span><span class="hljs-meta"> [user]</span><br></code></pre></td></tr></table></figure><ul><li>如果你具有超级用户权限，你可以指定一个用户名作为 passwd 命令的参数，这样可以设置 另一个用户的密码。还有其它的 passwd 命令选项对超级用户有效，允许帐号锁定，密码失效,详细内容参考 passwd 命令的手册页</li></ul><p><strong>还有一系列的命令行程序，可以用来创建和维护用户和用户组：</strong></p><ul><li>adduser</li><li>useradd</li><li>groupadd</li></ul><h1 id="11-进程"><a href="#11-进程" class="headerlink" title="11 进程"></a>11 进程</h1><h2 id="11-1-ps查看进程"><a href="#11-1-ps查看进程" class="headerlink" title="11.1 ps查看进程"></a>11.1 ps查看进程</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">ps<br>ps x<span class="hljs-regexp">//</span>显示所有进程<br>ps aux<span class="hljs-regexp">//</span>显示所有进程并获得详细信息<br></code></pre></td></tr></table></figure><ul><li>stat状态含义</li></ul><p><img src="https://i.loli.net/2021/05/20/hrSk6liUX3PBRnH.png" alt="image-20210520000339163"></p><h2 id="11-1-top查看进程"><a href="#11-1-top查看进程" class="headerlink" title="11.1 top查看进程"></a>11.1 top查看进程</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">top<span class="hljs-regexp">//</span>动态显示进程<br></code></pre></td></tr></table></figure><ul><li>h查看帮助，q退出</li></ul><p><img src="https://i.loli.net/2021/05/20/oUcTAKvsMzGL1nw.png" alt="image-20210520150337666"></p><h2 id="11-2信号"><a href="#11-2信号" class="headerlink" title="11.2信号"></a>11.2信号</h2><p><strong>kill命令可以像进程发送信号，默认是term</strong></p><p><strong>注意，信号既可以用号码，也可以用名字来 指定，包括在前面加上字母“SIG”的名字</strong></p><p><img src="https://i.loli.net/2021/05/20/ebAnMy62OZmvQKG.png" alt="image-20210520151425593"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">kill</span> -signal PID<br><span class="hljs-attribute">kill</span> -<span class="hljs-number">1</span> <span class="hljs-number">13546</span><br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/20/YZaRbGSUpgExONi.png" alt="image-20210520151123810"></p><p><img src="https://i.loli.net/2021/05/20/8mOYToHh9N2iGvw.png" alt="image-20210520151509766"></p><p><img src="https://i.loli.net/2021/05/20/8SIwb9BRZsUpfl5.png" alt="image-20210520151519019"></p><h2 id="11-3-killall向多个进程发送信号"><a href="#11-3-killall向多个进程发送信号" class="headerlink" title="11.3 killall向多个进程发送信号"></a>11.3 killall向多个进程发送信号</h2><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">killall [-u user] [-signal] name...<br></code></pre></td></tr></table></figure><h2 id="10-4-关闭系统"><a href="#10-4-关闭系统" class="headerlink" title="10.4 关闭系统"></a>10.4 关闭系统</h2><p>4种方式</p><p>halt    poweroff     reboot    shutdown</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">sudo reboot<br>sudo shutdown -h now<span class="hljs-comment">//挂起</span><br>sudo shutdown -r now<span class="hljs-comment">//重启</span><br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/20/9kgRDvCjIe78wqx.png" alt="image-20210520153312540"></p><h1 id="12-环境"><a href="#12-环境" class="headerlink" title="12 环境"></a>12 环境</h1><h2 id="12-1检查环境"><a href="#12-1检查环境" class="headerlink" title="12.1检查环境"></a>12.1检查环境</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">printenv | less<br>printenv USER<span class="hljs-regexp">//</span>列出指定环境变量的值<br>set | less<br>echo <span class="hljs-variable">$HOME</span><span class="hljs-regexp">//</span>用echo命令查看变量内容<br></code></pre></td></tr></table></figure><ul><li>环境中的别名无法使用set命令和printenv命令显示，想要查看别名，可以使用不包含参数的alias</li><li>查找用/  ,区分大小写         </li></ul><h2 id="12-2-值得注意的环境变量"><a href="#12-2-值得注意的环境变量" class="headerlink" title="12.2 值得注意的环境变量"></a>12.2 值得注意的环境变量</h2><p><img src="https://i.loli.net/2021/05/20/gLDkbYCN5SIizAs.png" alt="image-20210520190132204"></p><p><img src="https://i.loli.net/2021/05/20/ToLVdIyuvtKcSqh.png" alt="image-20210520190143788"></p><h2 id="12-3-如何建立环境"><a href="#12-3-如何建立环境" class="headerlink" title="12.3 如何建立环境"></a>12.3 如何建立环境</h2><ul><li>是登录 shell 会话</li></ul><p><img src="https://i.loli.net/2021/05/20/hmF93cLQfusD74e.png" alt="image-20210520190605756"></p><p><img src="https://i.loli.net/2021/05/20/z9yAQ1RnCbrXg8a.png" alt="image-20210520190645227"></p><ul><li>非登录shell会话</li></ul><p><img src="https://i.loli.net/2021/05/20/9gfGsCna7NMTFAc.png" alt="image-20210520190712283"></p><p>非登录 shell 会话也会继承它们父进程的环境设置，通常是一 个登录 shell</p><h2 id="12-4-启动文件"><a href="#12-4-启动文件" class="headerlink" title="12.4 启动文件"></a>12.4 启动文件</h2><ul><li>当我们 输入 ls 后，shell 不会查找整个计算机系统来找到 /bin/ls（ls 命令的全路径名），相反，它查找 一个目录列表，这些目录包含在 PATH 变量中</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HOME</span><span class="hljs-regexp">/bin/</span><span class="hljs-regexp">/修改 PATH 变量，添加目录 $HOME/</span>bin 到目录列表的末尾<br></code></pre></td></tr></table></figure><h2 id="12-5-修改环境、使用文本编辑器"><a href="#12-5-修改环境、使用文本编辑器" class="headerlink" title="12.5 修改环境、使用文本编辑器"></a>12.5 修改环境、使用文本编辑器</h2><ul><li>添加目录到你的 PATH 变量或者是定义额外的环境变量，要把这些更改放置 到.bash_profile 文件中</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">gedit some_file<span class="hljs-regexp">//</span>如果所输入的文件名不存在，编辑器则会假定你想要创建一个新文件<br></code></pre></td></tr></table></figure><ul><li><strong>当我们编辑一个重要的配置文件时</strong>，<strong>首先创建一个这个文件的备份总是一个不错的主意</strong>。<strong>这样能避免我们在编辑文件时弄乱文件</strong></li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">cp <span class="hljs-string">.bashrc</span> <span class="hljs-string">.bashrc.bak</span><br></code></pre></td></tr></table></figure><ul><li>ctrl O 保存文件，ctrl X 退出</li></ul><p><img src="https://i.loli.net/2021/05/20/M9YAjK1rveEpHuf.png" alt="image-20210520192935152"></p><ul><li>我们对于文件.bashrc 的修改不会生效，直到我们关闭终端会话，再重新启动一个新的会话，因 为.bashrc 文件只是在刚开始启动终端会话时读取。然而，我们可以强迫 bash 重新读取修改过 的.bashrc 文件,用命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> .bashrc<br></code></pre></td></tr></table></figure><h1 id="13-vi入门"><a href="#13-vi入门" class="headerlink" title="13 vi入门"></a>13 vi入门</h1><h2 id="13-1-启动和退出"><a href="#13-1-启动和退出" class="headerlink" title="13.1 启动和退出"></a>13.1 启动和退出</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">vi<span class="hljs-regexp">//</span>启动vi<br>:q<span class="hljs-regexp">//</span>退出vi<br>:q!<span class="hljs-regexp">//</span>强制退出（一般是修改没保存）<br><span class="hljs-regexp">//</span>连按两下esc可以回到命令模式<br></code></pre></td></tr></table></figure><h2 id="13-2-编辑模式"><a href="#13-2-编辑模式" class="headerlink" title="13.2 编辑模式"></a>13.2 编辑模式</h2><ul><li><p>刚进入vi<strong>进入到命令模式</strong>，每一个按键都是命令，按i键进入输入模式</p></li><li><p>按两下esc回到命令模式，输入:w保存</p></li><li><p>小贴示：如果你阅读 vim 的文档，你会发现命令模式被（令人困惑地）叫做普通模式（<strong>normal mode</strong>)，ex 命令叫做命令模式</p></li></ul><h2 id="13-3-光标移动"><a href="#13-3-光标移动" class="headerlink" title="13.3 光标移动"></a>13.3 光标移动</h2><p><img src="https://i.loli.net/2021/05/20/sW1jMBxfzVZ93YL.png" alt="image-20210520194709123"></p><ul><li>G是大写，要配合shift</li><li>vi命令都可以加上数字前缀，<strong>5j</strong>可以使光标下移5行</li></ul><h2 id="13-4-基本编辑"><a href="#13-4-基本编辑" class="headerlink" title="13.4 基本编辑"></a>13.4 基本编辑</h2><h3 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h3><ul><li><p>insert命令做不到</p></li><li><p>a 命令，在当前光标后追加（进入插入模式）</p></li><li><p>A命令，在当前行末尾追加（进入插入模式）</p></li></ul><h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><p><img src="https://i.loli.net/2021/05/20/XwC2vM6HSQy7oE5.png" alt="image-20210520195958743"></p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><img src="https://i.loli.net/2021/05/20/cdAWblZTEtoHj9U.png" alt="image-20210520200056415"></p><ul><li><strong>手速要快</strong></li><li>按u撤销删除</li></ul><h3 id="剪切复制和粘贴"><a href="#剪切复制和粘贴" class="headerlink" title="剪切复制和粘贴"></a>剪切复制和粘贴</h3><ul><li>d 命令不仅删除文本，<strong>它还“剪切”文本</strong>。每次我们使用 d 命令，删除的部分被复制到一 个粘贴缓冲区中（看作剪切板）</li><li>y命令复制文本</li></ul><p><img src="https://i.loli.net/2021/05/20/qo8fx7X9ebzU6hM.png" alt="image-20210520201812389"></p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>p</td><td>粘贴至下一行（无论光标在这一行的哪里）</td></tr><tr><td>P</td><td>粘贴至上一行（无论光标在这一行的哪里）</td></tr></tbody></table><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><ul><li>J 命令合并光标所在行与下一行</li></ul><h2 id="13-5-搜索和替换"><a href="#13-5-搜索和替换" class="headerlink" title="13.5 搜索和替换"></a>13.5 搜索和替换</h2><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><ul><li><strong>行内搜索</strong>用 <strong>fa</strong> 命令；按 <strong>;</strong> 继续行内搜索</li><li>搜索整个文件 <code>/</code>,重复搜索<code>n</code>即可</li></ul><h3 id="全局搜索和替换"><a href="#全局搜索和替换" class="headerlink" title="全局搜索和替换"></a>全局搜索和替换</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">:%s/<span class="hljs-keyword">Line</span>/<span class="hljs-keyword">line</span>/<span class="hljs-keyword">g</span><span class="hljs-comment">//把文件中所有的单词Line都更改为line</span><br>:1,<span class="hljs-variable">$s</span>/<span class="hljs-keyword">Line</span>/<span class="hljs-keyword">line</span>/<span class="hljs-keyword">g</span><span class="hljs-comment">//与前面那个一样</span><br>:%s/<span class="hljs-keyword">line</span>/<span class="hljs-keyword">Line</span>/gv<span class="hljs-comment">//把line改回去，c要求每一次替换前确认替换</span><br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/20/1sBe7koihgSEmqO.png" alt="image-20210520203830502"></p><p><img src="https://i.loli.net/2021/05/20/oyv7kOZlnewbJ6q.png" alt="image-20210520210031330"></p><h2 id="13-6-编辑多个文件"><a href="#13-6-编辑多个文件" class="headerlink" title="13.6 编辑多个文件"></a>13.6 编辑多个文件</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim file1 file2 file3...<span class="hljs-regexp">//</span>用vi会出现问题（可能vi不支持）<br>:bn<span class="hljs-regexp">//</span>切换到下一个文件（强制切换加上！）<br>:bp<span class="hljs-regexp">//</span>切换到上一个文件<br>:buffers<span class="hljs-regexp">//</span>显示缓冲区<br>:buffer <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ul><li>载入更多文件</li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:e</span> ls-output.txt<br></code></pre></td></tr></table></figure><ul><li>将一个文件的内容复制到另一个文件: 用yy复制buffer切换p粘贴即可</li><li>将整个文件插入另一个文件（<strong>注意是在光标位置之后</strong>）</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">:r foo.txt<span class="hljs-regexp">//</span>在光标位置之后将文件读入并<br></code></pre></td></tr></table></figure><h2 id="13-7-保存工作"><a href="#13-7-保存工作" class="headerlink" title="13.7 保存工作"></a>13.7 保存工作</h2><ul><li>在命令模式下输入 <strong>ZZ</strong> 即可</li><li>输入:w</li><li><strong>另存为</strong>   <code>:w foo1.txt</code>    (<strong>注意这样是另存为foo1，现在仍在编辑foo</strong>)</li></ul><h1 id="14-定制提示符"><a href="#14-定制提示符" class="headerlink" title="14. 定制提示符"></a>14. 定制提示符</h1><h2 id="14-1-分解提示符"><a href="#14-1-分解提示符" class="headerlink" title="14.1 分解提示符"></a>14.1 分解提示符</h2><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">echo $PS1<br>[\u<span class="hljs-symbol">@\h</span> \W]\$<br></code></pre></td></tr></table></figure><ul><li>转移字符表</li></ul><p><img src="https://i.loli.net/2021/05/20/3qRmSN1zsGfYDFt.png" alt="image-20210520212857378"></p><h2 id="14-2-换一种提示符"><a href="#14-2-换一种提示符" class="headerlink" title="14.2 换一种提示符"></a>14.2 换一种提示符</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">ps1_old=<span class="hljs-string">&quot;$PS1&quot;</span><span class="hljs-regexp">//</span>首先备份现有的提示符<br>PS1=<span class="hljs-string">&quot;$ps1_old&quot;</span><span class="hljs-regexp">//</span>恢复原有的提示符<br>PS1=<span class="hljs-string">&quot;\[\033[0;41m\]&lt;\u@\h \W&gt;\$\[\033[0m\]&quot;</span><span class="hljs-regexp">//</span>前一个使输出系统信息为红色，后一个使输入文字信息为黑色<br></code></pre></td></tr></table></figure><ul><li><p><img src="https://i.loli.net/2021/05/20/WNLgqOom8sxfa67.png" alt="image-20210520214444090"></p></li><li><p>背景颜色</p></li></ul><p><img src="https://i.loli.net/2021/05/20/izWGYmSojlecdby.png" alt="image-20210520214456315"></p><ul><li>光标设置</li></ul><p><img src="https://i.loli.net/2021/05/20/6v5FyTnUad3pf2E.png" alt="image-20210520214523060"></p><ul><li><code>PS1=&quot;\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\]&lt;\u@\h \W&gt;\$&quot;</code>使用上面的编码，我们将构建一个提示符，每次当这个提示符出现的时候，会在屏幕的上方 画出一个包含时钟（由黄色文本渲染）的红色长条</li></ul><p><img src="https://i.loli.net/2021/05/20/aRQklMexicdyg7v.png" alt="image-20210520214744772"></p><p><img src="https://i.loli.net/2021/05/20/uCLZIvj36J9mbMa.png" alt="image-20210520214754413"></p><h2 id="14-3-保存提示符"><a href="#14-3-保存提示符" class="headerlink" title="14.3 保存提示符"></a>14.3 保存提示符</h2><ul><li>把下面两行添加到.bashr文件中去</li></ul><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">PS1=&quot;<span class="hljs-symbol">\[</span><span class="hljs-symbol">\0</span>33[s<span class="hljs-symbol">\0</span>33[0;0H<span class="hljs-symbol">\0</span>33[0;41m<span class="hljs-symbol">\0</span>33[K<span class="hljs-symbol">\0</span>33[1;33m<span class="hljs-symbol">\t</span><span class="hljs-symbol">\0</span>33[0m<span class="hljs-symbol">\0</span>33[u<span class="hljs-symbol">\]</span>&lt;<span class="hljs-symbol">\u</span>@<span class="hljs-symbol">\h</span> <span class="hljs-symbol">\W</span>&gt;<span class="hljs-symbol">\$</span>&quot;<br>export PS1<br></code></pre></td></tr></table></figure><h1 id="15-软件包管理"><a href="#15-软件包管理" class="headerlink" title="15 软件包管理"></a>15 软件包管理</h1><h2 id="15-1-打包系统"><a href="#15-1-打包系统" class="headerlink" title="15.1 打包系统"></a>15.1 打包系统</h2><p><img src="https://i.loli.net/2021/05/21/5Lc8zKxlAhk6sbF.png" alt="image-20210521001903091"></p><h2 id="15-2-软件包的工作方式"><a href="#15-2-软件包的工作方式" class="headerlink" title="15.2 软件包的工作方式"></a>15.2 软件包的工作方式</h2><ul><li>Linux系统中几乎所有的软件都可以在互联网上找到。其中大多数软件由发行商以包文件的形式提供，剩下的则以源码形式存在，可以手动安装。</li><li>在包管理系统中软件的基本单元是包文件。包文件是一个构成软件包的文件压缩集合。一个软件包可能由大量程序以及支持这些程序的数据文件组成。</li><li>系统发行版的用户可以在一个中心资源库中得到这些软件包，这个资 源库可能包含了成千上万个软件包，每一个软件包都是专门为这个系统发行版建立和维护的。</li><li>程序很少独立工作；他们需要依靠其他程序的组件来完成他们的工作。现代的软件包管理系统都提供了一些依赖项解析方法，以确保安装软 件包时，其所有的依赖也被安装。</li></ul><p><img src="https://i.loli.net/2021/05/21/drgCb8nsiqyk2xo.png" alt="image-20210521002838341.png"></p><h2 id="15-3-常见的软件包管理任务"><a href="#15-3-常见的软件包管理任务" class="headerlink" title="15.3 常见的软件包管理任务"></a>15.3 常见的软件包管理任务</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><img src="https://i.loli.net/2021/05/21/LedzpiuMHOkWIqY.png" alt="image-20210521004022448"></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>下载安装</li></ul><p><img src="https://i.loli.net/2021/05/21/tHxnfUcEde1Z5pL.png" alt="image-20210521004553392"></p><ul><li>下载好文件直接安装</li></ul><p><img src="https://i.loli.net/2021/05/21/GypJB4ZO7KVkMr1.png" alt="image-20210521004702263"></p><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p><img src="https://i.loli.net/2021/05/21/EytqX3gmzhMAP4O.png" alt="image-20210521004901986"></p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p><img src="https://i.loli.net/2021/05/21/7L4jvUham3ocM6i.png" alt="image-20210521004921977"></p><ul><li>通过下载的软件包升级</li></ul><p><img src="https://i.loli.net/2021/05/21/fKUDZSp84tj2J7F.png" alt="image-20210521004952589"></p><h3 id="列出"><a href="#列出" class="headerlink" title="列出"></a>列出</h3><p><img src="https://i.loli.net/2021/05/21/hIwbFPQ5T6jiYL2.png" alt="image-20210521005010163"></p><h3 id="确认是否安装"><a href="#确认是否安装" class="headerlink" title="确认是否安装"></a>确认是否安装</h3><p><img src="https://i.loli.net/2021/05/21/56pQj3VXBNYA2SI.png" alt="image-20210521005036005"></p><h3 id="显示安装包信息"><a href="#显示安装包信息" class="headerlink" title="显示安装包信息"></a>显示安装包信息</h3><p><img src="https://i.loli.net/2021/05/21/arlJ9ZHDbm2qy3B.png" alt="image-20210521005059496"></p><h3 id="查找安装了某个文件的包"><a href="#查找安装了某个文件的包" class="headerlink" title="查找安装了某个文件的包"></a>查找安装了某个文件的包</h3><p><img src="https://i.loli.net/2021/05/21/ysDFz2bCWNqKOjo.png" alt="image-20210521005132673"></p><h1 id="16-存储介质"><a href="#16-存储介质" class="headerlink" title="16 存储介质"></a>16 存储介质</h1><h2 id="16-1存储设备的挂载与卸载"><a href="#16-1存储设备的挂载与卸载" class="headerlink" title="16.1存储设备的挂载与卸载"></a>16.1存储设备的挂载与卸载</h2><ul><li><p>Linux 在<strong>单一文件系统树中</strong>维 护连接在各个节点的各种设备。在MS-DOS 和 Windows 系 统中，每个设备（例如 C:\，D:\，等）保持着单独的文件系统树</p></li><li><p>文件 <strong>/etc/fstab</strong> 列出了系统启动时要挂载的设备 <code> cat /etc/fstab</code></p></li></ul><p><img src="https://i.loli.net/2021/05/21/xjSkL7WBlRZEidI.png" alt="image-20210521083937799"></p><p><img src="https://i.loli.net/2021/05/21/zx9uHMw3dt7W5hC.png" alt="image-20210521083901885"></p><ul><li>查看已挂载的文件系统列表   <code>mount</code>命令</li></ul><p>若有光盘：<img src="https://i.loli.net/2021/05/21/Gtmx9kXPFuNiscj.png" alt="image-20210521084629825"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">umount <span class="hljs-regexp">/dev/</span>hdc<span class="hljs-regexp">//</span>卸载CDROM（需要root权限）<br>mkdir <span class="hljs-regexp">/mnt/</span>cdrom<span class="hljs-regexp">//</span>建立新目录<br>mount -t iso9660 <span class="hljs-regexp">/dev/</span>hdc <span class="hljs-regexp">/mnt/</span>cdrom<span class="hljs-regexp">//</span>将CDROM挂载到新的挂载点，-t指定文件系统类型<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/21/fAJVmgIrEhOsU9B.png" alt="image-20210521084925810"></p><h2 id="16-2-确定设备名称"><a href="#16-2-确定设备名称" class="headerlink" title="16.2 确定设备名称"></a>16.2 确定设备名称</h2><ul><li>列出/dev 目录下的内容 <code>ls /dev</code></li></ul><p><img src="https://i.loli.net/2021/05/21/eQScTwflgDy3sI9.png" alt="image-20210521085528629"></p><ul><li><code> tail -f /var/log/messages</code> 对操作系统实时监测，<strong>插入设备观察设备名称</strong>，知道设备名称之后挂载设备</li><li>挂载之后设备只要不拔下来，并且系统不重启，设备名称就不会发生变化</li><li>用<code>df</code>命令显示目前在 Linux 系统上的文件系统磁盘使用情况统计</li></ul><h2 id="16-3-创建新文件系统"><a href="#16-3-创建新文件系统" class="headerlink" title="16.3 创建新文件系统"></a>16.3 创建新文件系统</h2><h3 id="用fdisk修改文件系统"><a href="#用fdisk修改文件系统" class="headerlink" title="用fdisk修改文件系统"></a>用fdisk修改文件系统</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo umount <span class="hljs-regexp">/dev/</span>sdb1<br>sudo fdisk <span class="hljs-regexp">/dev/</span>sdb<br>Command (m <span class="hljs-keyword">for</span> help):m<span class="hljs-regexp">//</span>显示菜单<br>Command (m <span class="hljs-keyword">for</span> help):p<span class="hljs-regexp">//</span>显示设备分区表<br>Command (m <span class="hljs-keyword">for</span> help):l<span class="hljs-regexp">//</span>显示可能的文件系统列表及对应的id<br>Command (m <span class="hljs-keyword">for</span> help):t<span class="hljs-regexp">//</span>修改<br>Hex code (type L to list codes): <span class="hljs-number">83</span><br>Command (m <span class="hljs-keyword">for</span> help):w<span class="hljs-regexp">//</span>保存<br></code></pre></td></tr></table></figure><h3 id="使用mkfs创建新的文件系统"><a href="#使用mkfs创建新的文件系统" class="headerlink" title="使用mkfs创建新的文件系统"></a>使用mkfs创建新的文件系统</h3><p>make file system</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo mkfs -t ext3 <span class="hljs-regexp">/dev/</span>sdb1<span class="hljs-regexp">//</span>指定ext4为文件系统类型<br>sudo mkfs -t vfat <span class="hljs-regexp">/dev/</span>sdb1<span class="hljs-regexp">//</span>指定vfat为文件系统类型<br></code></pre></td></tr></table></figure><h2 id="16-4-文件系统的检查与修复"><a href="#16-4-文件系统的检查与修复" class="headerlink" title="16.4 文件系统的检查与修复"></a>16.4 文件系统的检查与修复</h2><ul><li><code> sudo fsck /dev/sdb1</code>修复损坏的文件系统</li><li>已修复的文件会存放在各个文件系统根目录下的lost+found 目录里面</li></ul><h2 id="16-5-设备之间直接移动数据"><a href="#16-5-设备之间直接移动数据" class="headerlink" title="16.5 设备之间直接移动数据"></a>16.5 设备之间直接移动数据</h2><ul><li> <code>dd</code>命令实现将数据块从一处复制到另一处</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">dd <span class="hljs-keyword">if</span>=input_file of=output_file [bs=block_size [count=blocks]]<br>dd <span class="hljs-keyword">if</span>=<span class="hljs-regexp">/dev/</span>sdb of=<span class="hljs-regexp">/dev/</span>sdc<span class="hljs-regexp">//</span>如果连接两个设备到计算机上，它们各自被分配到设备<span class="hljs-regexp">/dev/</span>sdb和<span class="hljs-regexp">/dev/</span>sdc<br>上把第一个驱动器中的所有数据复制到第二个驱动器中<br>dd <span class="hljs-keyword">if</span>=<span class="hljs-regexp">/dev/</span>sdb of=flash_drive.img<span class="hljs-regexp">//</span>如果只有第一个驱动器被连接到计算机上，我们可以把它的内容复制到一个普通文件<br>中供以后恢复或复制数据<br></code></pre></td></tr></table></figure><p>==注意==：</p><p>dd命令的功能非常强大，起名取自“data definition”（数据定义），然而有时候也会被成为“destory disk”（摧毁磁盘），因为用户经常不小心输错if 或者of 说明。<strong>在Enter之前，一定要检查一遍if of说明</strong>！</p><h3 id="向可刻录CD写入数据"><a href="#向可刻录CD写入数据" class="headerlink" title="向可刻录CD写入数据"></a>向可刻录CD写入数据</h3><p><strong>写入一个可记录的 CD-ROM（一个 CD-R 或者是 CD-RW）由两步组成</strong></p><ul><li>首先，构建一个 iso 映像文件，这就是一个 CD-ROM 的文件系统映像</li><li>第二步，把这个映像文件写入到 CD-ROM 媒介中。</li></ul><h4 id="创建iso映像文件"><a href="#创建iso映像文件" class="headerlink" title="创建iso映像文件"></a>创建iso映像文件</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">dd</span> <span class="hljs-keyword">if</span>=/dev/cdrom of=ubuntu<span class="hljs-selector-class">.iso</span><span class="hljs-comment">//使用 dd 命令来读取 CD-ROW 中的所有数据块，并把它们复制到本地文件中</span><br>genisoimage -o cd-rom<span class="hljs-selector-class">.iso</span> -R -J ~/cd-rom-files<span class="hljs-comment">//用genisoimage命令来从文件集合中创建一个映像</span><br><span class="hljs-comment">//“-R” 选项添加元数据为 Rock Ridge 扩展，这允许使用长文件名和 POSIX 风格的文件权限。 “-J” 选项使 Joliet 扩展生效，这样Windows中就支持长文件名了</span><br></code></pre></td></tr></table></figure><h4 id="写入CD-ROM中"><a href="#写入CD-ROM中" class="headerlink" title="写入CD-ROM中"></a>写入CD-ROM中</h4><ul><li>直接挂载iso映像文件</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkdir <span class="hljs-regexp">/mnt/i</span>so_image<span class="hljs-regexp">//</span>创建挂载点<br>mount -t iso9660 -o loop image.iso <span class="hljs-regexp">/mnt/i</span>so_image<span class="hljs-regexp">//</span>使用mount命令的-o loop选项、指定文件系统类型的-t iso9660选项，将iso映像文件当作设备挂载到文件系统树（可以把它当作真实的CD使用）<br>md5sum image.iso<span class="hljs-regexp">//</span>使用md5sum命令产生十六进制书校验文件(检查完整性)<br>md5sum <span class="hljs-regexp">/dev/</span>cdrom<br></code></pre></td></tr></table></figure><ul><li>擦除可刻录CD、刻录映像文件</li><li><img src="https://i.loli.net/2021/05/21/Zxok4GRg3XhEPYT.png" alt="image-20210521101401935"></li></ul><h1 id="17-联网"><a href="#17-联网" class="headerlink" title="17 联网"></a>17 联网</h1><h2 id="17-1-网络检查与监控"><a href="#17-1-网络检查与监控" class="headerlink" title="17.1 网络检查与监控"></a>17.1 网络检查与监控</h2><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><ul><li><p><code>ping</code>命令： ping 命令发送一个特殊的网络数据包，叫做 ICMP ECHO_REQUEST，到一台指定的主机。大多数接收这个包的网络设备将会回复它，来 允许网络连接验证</p></li><li><p><strong>注意</strong>：大多数网络设备（包括 Linux 主机）都可以被配置为忽略这些数据包。通常，这样 做是出于网络安全原因，部分地遮蔽一台主机免受一个潜在攻击者地侵袭。配置防火墙来阻塞 IMCP 流量也很普遍。</p></li></ul><h3 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h3><ul><li>traceroute程序完整过程：首先它发送一份TTL字段为1的IP数据包给目的主机，处理这个数据包的第一个路由器将TTL值减1，然后丢弃该数据报，并给源主机发送一个ICMP报文（“超时”信息，这个报文包含了路由器的IP地址，这样就得到了第一个路由器的地址），然后traceroute发送一个TTL为2的数据报来得到第二个路由器的IP地址，继续这个过程，直至这个数据报到达目的主机</li><li>输出结果中会<strong>列出网络流量从本地系统到指定主机的所有跳（hop）数</strong>，其中没有提供标识信息的路由器用*号表示</li></ul><h3 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h3><ul><li><code>ip a</code>检查系统的网络接口和路由表</li><li>当执行日常网络诊断时，要查看的重要信息是每个网络接口第四行开头出现的单词“<strong>UP</strong>”， 说明这个网络接口已经生效，还要查看第二行中 inet字段出现的有效 IP 地址。</li></ul><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><ul><li><code>netstat</code>t 程序被用来检查各种各样的网络设置和统计数据。通过此命令的许多选项，我们可以看 看网络设置中的各种特性</li><li>使用“-ie”选项，我们能够查看系统中的网络接口</li><li>“-r”选项能够显示内核的网络路由表，从中能够看出分组时如何在网络之间传送的</li></ul><h2 id="17-2-通过网络来传输文件"><a href="#17-2-通过网络来传输文件" class="headerlink" title="17.2 通过网络来传输文件"></a>17.2 通过网络来传输文件</h2><h3 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h3><ul><li><strong>FTP指的是协议，ftp指的是与之同名的程序</strong></li></ul><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>ftp fileserver</td><td>连接名叫fileserver的ftp服务器</td></tr><tr><td>cd pub/</td><td>在大多数匿名的 FTP 服务器中，支持公共 下载的文件都能在目录 pub 下找到</td></tr><tr><td>lcd Desktop</td><td>将本地目录改为 ~/Desktop,ftp程序工作目录默认在 ~/Desktop下</td></tr><tr><td>get …iso</td><td>将远程系统文件传至本地，即~/Desktop</td></tr><tr><td>bye</td><td>登出远程服务器</td></tr></tbody></table><ul><li>lftp-更好的ftp：包括多协议支持（包括 HTTP），若下载失败会自动地重新下载， 后台处理，用 tab 按键来补全路径名</li></ul><h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3><ul><li>支持递归下载、后台下载、断点续传</li></ul><p><code>wget http://linuxcommand.org/index.php</code></p><h2 id="17-3-与远程主机的通信"><a href="#17-3-与远程主机的通信" class="headerlink" title="17.3 与远程主机的通信"></a>17.3 与远程主机的通信</h2><ul><li><strong>都在OpenSSH包中</strong></li></ul><h3 id="ssh（Secure-Shell"><a href="#ssh（Secure-Shell" class="headerlink" title="ssh（Secure Shell)"></a>ssh（Secure Shell)</h3><ul><li>认证身份</li><li>加密本地与远程主机通信<strong>（从22端口）</strong></li></ul><p><strong>SSH 由两部分组成。</strong>(<strong>必须都要安装</strong>)</p><p>1.SSH服务端运行在远端主机上，在端口 22 上监听收到的外部连接</p><p>2.SSH客户端用在本地系统中，用来和远端服务器通信</p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>ssh bob@remote-sys</td><td>以用户bob的身份连接远程主机</td></tr><tr><td>ssh remote-sys free</td><td>在远程主机上运行free命令并在本地显示结果</td></tr><tr><td><code>ssh remote-sys &#39;ls *&#39; &gt; dirlist.txt</code></td><td>输出到本地主机文件（ls命令用单引号括起来防止在本地展开）</td></tr><tr><td><code>ssh remote-sys &#39;ls * &gt; dirlist.txt&#39;</code></td><td>输出到远程主机（注意单引号位置）</td></tr><tr><td><code>ssh -X remote-sys;xload</code></td><td>在远程主机上运行xload窗口出现在本地主机（-X传界面）</td></tr></tbody></table><h2 id="scp与sftp"><a href="#scp与sftp" class="headerlink" title="scp与sftp"></a>scp与sftp</h2><h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><ul><li>scp（安全复制）被用来复制文件，与熟悉的 cp 程序非常相似。<strong>最显著的区别就是</strong>源或者目标 路径名要以远端主机的名字，后跟一个冒号字符开头</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">scp bob<span class="hljs-meta">@remote</span>-sys:<span class="hljs-built_in">document</span>.txt<span class="hljs-comment">//以bob账号登入远程主机并复制文件</span><br></code></pre></td></tr></table></figure><h3 id="sftp"><a href="#sftp" class="headerlink" title="sftp"></a>sftp</h3><ul><li><p>ftp 程序的安全替代品,是 sftp 不需要远端系统中运行 FTP 服务端。 它<strong>仅仅需要 SSH 服务端</strong>。这意味着任何一台能用 SSH 客户端连接的远端机器，也可当作类似 于 FTP 的服务器来使用。</p></li><li><p>用法参照ftp</p></li></ul><h1 id="18-查找文件"><a href="#18-查找文件" class="headerlink" title="18 查找文件"></a>18 查找文件</h1><h2 id="18-1-locate查找文件"><a href="#18-1-locate查找文件" class="headerlink" title="18.1 locate查找文件"></a>18.1 locate查找文件</h2><ul><li><p><code>locate bin/zip</code>列出所有<strong>以zip开头的程序，目录以bin/结尾</strong>的程序</p></li><li><p>结合grep命令使用更高效</p></li><li><p><img src="https://i.loli.net/2021/05/21/yo7RNv5YcCdBLOJ.png" alt="image-20210521150632972"></p></li></ul><h2 id="18-2-find-复杂的文件的查找方法"><a href="#18-2-find-复杂的文件的查找方法" class="headerlink" title="18.2 find-复杂的文件的查找方法"></a>18.2 find-复杂的文件的查找方法</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">find ~<span class="hljs-comment">//指定一个目录为查找范围</span><br>find ~ | wc -l<br></code></pre></td></tr></table></figure><h3 id="测试条件"><a href="#测试条件" class="headerlink" title="测试条件"></a>测试条件</h3><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">find</span> ~ -<span class="hljs-built_in">type</span> d | wc -l<span class="hljs-comment">//type d限制只查找目录</span><br><span class="hljs-built_in">find</span> ~ -<span class="hljs-built_in">type</span> f | wc -l<span class="hljs-comment">//限制只查找普通文件</span><br><span class="hljs-built_in">find</span> ~ -<span class="hljs-built_in">type</span> f -<span class="hljs-built_in">name</span> <span class="hljs-string">&quot;*.JPG&quot;</span> -<span class="hljs-built_in">size</span> +<span class="hljs-number">1</span>M | wc -l<span class="hljs-comment">//查找所有匹配*.JPG而且大于1MB的普通文件（加入双引号防止路径名扩展）</span><br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/21/YWR1kuLNoGfaeDC.png" alt="image-20210521151825372"></p><p><img src="https://i.loli.net/2021/05/21/OUr4HMtkezm3GFA.png" alt="image-20210521151931893"></p><p><img src="https://i.loli.net/2021/05/21/7NWjYOqUIm6g4cx.png" alt="image-20210521151953549"></p><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><ul><li>查找权限不为0600的文件和权限不为0700的目录</li></ul><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">find ~ \( -<span class="hljs-keyword">type</span> <span class="hljs-type">f </span>-<span class="hljs-keyword">not</span> -perm <span class="hljs-number">0600</span> \) -<span class="hljs-keyword">or</span> \( -<span class="hljs-keyword">type</span> <span class="hljs-type">d </span>-<span class="hljs-keyword">not</span> -perm <span class="hljs-number">0700</span> \)<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/21/sbKMCjn3u47NfJa.png" alt="image-20210521154546432"></p><ul><li>注意默认使用and    以及括号组合字符</li><li>对于被分隔的表达式，不一定默认求值        <code>expr1 -operator expr2</code></li></ul><p><img src="https://i.loli.net/2021/05/21/ZUD9pGVQPNCs68o.png" alt="image-20210521154738960"></p><h3 id="预定义操作"><a href="#预定义操作" class="headerlink" title="预定义操作"></a>预定义操作</h3><ul><li><code>-print</code> 为默认操作</li></ul><p><img src="https://i.loli.net/2021/05/21/YKfGtiyvV6e24LT.png" alt="image-20210521154921293"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">find</span> ~ -<span class="hljs-built_in">type</span> f -name <span class="hljs-string">&#x27;*.bak&#x27;</span> -<span class="hljs-built_in">print</span>//先筛选再<span class="hljs-built_in">print</span><br><span class="hljs-built_in">find</span> ~ -<span class="hljs-built_in">print</span> -<span class="hljs-built_in">type</span> f -name <span class="hljs-string">&#x27;*.bak&#x27;</span> //先<span class="hljs-built_in">print</span>再筛选<br></code></pre></td></tr></table></figure><ul><li>在使用<code>delete</code>命令之前，先用print检查输出，确保万无一失</li></ul><h3 id="自定义操作"><a href="#自定义操作" class="headerlink" title="自定义操作"></a>自定义操作</h3><ul><li>find的-exec选项</li><li>command是命令名， <strong>{}</strong> 是代表当前路径名的符号， <strong>;</strong> 作为分隔符，表示命令结束（需要转义，用\ 和 ‘’ 都可以） </li></ul><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sqf">-<span class="hljs-built_in">exec</span> command &#123;&#125; ;<span class="hljs-comment">//-exec操作用法</span><br><span class="hljs-built_in">find</span> ~ -<span class="hljs-built_in">type</span> f -<span class="hljs-built_in">name</span> <span class="hljs-string">&#x27;.*&#x27;</span> -<span class="hljs-built_in">exec</span> ls -l <span class="hljs-string">&#x27;&#123;&#125;&#x27;</span> <span class="hljs-string">&#x27;;&#x27;</span><span class="hljs-comment">//在当前目录下，找到所有的隐藏文件并ls -l输出</span><br><span class="hljs-built_in">find</span> ~ -<span class="hljs-built_in">type</span> f -<span class="hljs-built_in">name</span> <span class="hljs-string">&#x27;.*&#x27;</span> -ok ls -l <span class="hljs-string">&#x27;&#123;&#125;&#x27;</span> <span class="hljs-string">&#x27;;&#x27;</span><span class="hljs-comment">//加入 -ok 在执行操作前提示用户</span><br></code></pre></td></tr></table></figure><ul><li>提高效率 （使用xargs 或者find命令自身新特性）</li></ul><p>将结尾的分号改成加号，就能让find命令将查找结果组合成参数列表，共指定的命令一次性使用</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">find</span> ~ -<span class="hljs-built_in">type</span> f -<span class="hljs-built_in">name</span> <span class="hljs-string">&#x27;.*&#x27;</span> -<span class="hljs-built_in">exec</span> ls -l <span class="hljs-string">&#x27;&#123;&#125;&#x27;</span> +<br></code></pre></td></tr></table></figure><p>虽然得到一样的结果，但是只执行了一次ls命令</p><h3 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h3><ul><li>从标注输入接受输入，将其转换为指定命令的参数列表</li><li>命令参数数量不是无限制的，超出shell支持的最大参数xargs会重复使用最大参数直至完成</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">find</span> ~ -<span class="hljs-built_in">type</span> <span class="hljs-keyword">f</span> -name <span class="hljs-string">&#x27;.*&#x27;</span> -<span class="hljs-keyword">print</span> | xargs <span class="hljs-keyword">ls</span> -<span class="hljs-keyword">l</span>//<span class="hljs-keyword">find</span>命令的输出结果通过管道传给了xargs命令，后者构造<span class="hljs-keyword">ls</span>命令的参数列表，然后执行该命令<br><span class="hljs-keyword">find</span> ~ -<span class="hljs-built_in">type</span> <span class="hljs-keyword">f</span> -name <span class="hljs-string">&#x27;.*&#x27;</span> -<span class="hljs-keyword">print</span> | xargs --show-limits <span class="hljs-keyword">ls</span> -<span class="hljs-keyword">l</span>//执行xargs 时加入--show-limits显示最大支持参数(注意是在xargs命令后面加入)<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/21/oHwevKW64iNFmS3.png" alt="image-20210521164911871"></p><h2 id="18-3-实战演练"><a href="#18-3-实战演练" class="headerlink" title="18.3 实战演练"></a>18.3 实战演练</h2><ul><li> <code>mkdir -p</code> 命令创建指定路径的父目录以及子目录</li><li><code>touch</code> 命令通常被用来<strong>设置或更新文件的访问，更改，和修改时间</strong>。如果一个文件名参数是一个不存在的文件，则会<strong>创建一个空文件</strong>。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript">[me<span class="hljs-meta">@linuxbox</span> ~]$ mkdir -p playground/dir-&#123;<span class="hljs-number">00</span>&#123;<span class="hljs-number">1.</span><span class="hljs-number">.9</span>&#125;,<span class="hljs-number">0</span>&#123;<span class="hljs-number">10.</span><span class="hljs-number">.99</span>&#125;,<span class="hljs-number">100</span>&#125;<span class="hljs-comment">//创建100个子目录</span><br>[me<span class="hljs-meta">@linuxbox</span> ~]$ touch playground/dir-&#123;<span class="hljs-number">00</span>&#123;<span class="hljs-number">1.</span><span class="hljs-number">.9</span>&#125;,<span class="hljs-number">0</span>&#123;<span class="hljs-number">10.</span><span class="hljs-number">.99</span>&#125;,<span class="hljs-number">100</span>&#125;/file-&#123;A..Z&#125;<span class="hljs-comment">//每个目录26个空文件</span><br>[me<span class="hljs-meta">@linuxbox</span> ~]$ find playground -<span class="hljs-keyword">type</span> f -name <span class="hljs-string">&#x27;file-A&#x27;</span> | wc -l<br>[me<span class="hljs-meta">@linuxbox</span> ~]$ touch playground/timestamp<span class="hljs-comment">//创建timestamp将其时间设置当前时间</span><br>[me<span class="hljs-meta">@linuxbox</span> ~]$ stat playground/timestamp<span class="hljs-comment">//查看属性（ls增强版）</span><br>[me<span class="hljs-meta">@linuxbox</span> ~]$ touch playground/timestamp<br>[me<span class="hljs-meta">@linuxbox</span> ~]$ stat playground/timestamp<br>[me<span class="hljs-meta">@linuxbox</span> ~]$ find playground -<span class="hljs-keyword">type</span> f -name <span class="hljs-string">&#x27;file-B&#x27;</span> -exec touch <span class="hljs-string">&#x27;&#123;&#125;&#x27;</span> <span class="hljs-string">&#x27;;&#x27;</span><span class="hljs-comment">//更新所有file-B文件</span><br>[me<span class="hljs-meta">@linuxbox</span> ~]$ find playground -<span class="hljs-keyword">type</span> f -newer playground/timestamp<span class="hljs-comment">//识别所有更新</span><br>[me<span class="hljs-meta">@linuxbox</span> ~]$ find playground \( -<span class="hljs-keyword">type</span> f -not -perm <span class="hljs-number">0600</span> \) -or \( -<span class="hljs-keyword">type</span> d -not -perm <span class="hljs-number">0700</span> \)<br>[me<span class="hljs-meta">@linuxbox</span> ~]$ find playground \( -<span class="hljs-keyword">type</span> f -not -perm <span class="hljs-number">0600</span> -exec chmod <span class="hljs-number">0600</span> <span class="hljs-string">&#x27;&#123;&#125;&#x27;</span> <span class="hljs-string">&#x27;;&#x27;</span> \) -or \( -<span class="hljs-keyword">type</span> d -not -perm <span class="hljs-number">0711</span> -exec chmod <span class="hljs-number">0700</span> <span class="hljs-string">&#x27;&#123;&#125;&#x27;</span> <span class="hljs-string">&#x27;;&#x27;</span> \)<span class="hljs-comment">//为所有文件设置新的权限</span><br></code></pre></td></tr></table></figure><h2 id="18-4-find命令选项"><a href="#18-4-find命令选项" class="headerlink" title="18.4 find命令选项"></a>18.4 find命令选项</h2><p><img src="https://i.loli.net/2021/05/21/q1wQrevGEVBgLtI.png" alt="image-20210521171219346"></p><h1 id="19-归档与备份"><a href="#19-归档与备份" class="headerlink" title="19 归档与备份"></a>19 归档与备份</h1><h2 id="19-1-文件压缩"><a href="#19-1-文件压缩" class="headerlink" title="19.1 文件压缩"></a>19.1 文件压缩</h2><h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">gzip foo.txt<br>gzip -tv foo.txt.gz<span class="hljs-string">//</span>没有v只验证完整性不输出结果<br>gunzip foo.txt<span class="hljs-string">//</span>解压，不用带<span class="hljs-string">.gz</span>的后缀名<br><span class="hljs-keyword">ls</span> -l <span class="hljs-string">/etc</span> | gzip &gt; foo.txt.gz<span class="hljs-string">//</span>输出直接压缩成文件（加上后缀表名是压缩过的）<br>gunzip -c foo.txt.gz | less <span class="hljs-string">//</span>只查看压缩文件的文本内容（注意-c后缀的作用）<br>zcat foo.txt.gz | less<span class="hljs-string">//</span>等同于-c的gzip<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/21/OGaeib7dWuZ6yq5.png" alt="image-20210521172237328"></p><ul><li>zless 程序共功能等同于管道操作符</li></ul><h3 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h3><ul><li>用法与gzip差不多</li><li>扩展名为<code>.bz2</code></li><li>牺牲压缩速度实现了更高的压缩率</li></ul><h3 id="二次压缩"><a href="#二次压缩" class="headerlink" title="二次压缩"></a>二次压缩</h3><ul><li> 二次压缩并不会节省空间，所有压缩技术都涉及额外信息，用来描述压缩过程</li><li>尝试压缩不包含任何冗余信息的文件，省下来的空间不足以抵消额外信息使用的空间</li></ul><h2 id="19-2-文件归档"><a href="#19-2-文件归档" class="headerlink" title="19.2 文件归档"></a>19.2 文件归档</h2><ul><li>文件归档：收集多个文件将其组合成一个大文件(可以同时压缩)</li></ul><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><ul><li>f选项指定名称，是必须的，“-”不是必须的</li><li>v选项获得详细清单</li><li>tar命令从归档中提取出来的文件所有权属于执行提取操作的用户，而非原先的用户（超级用户操作除外）</li><li>tar命令<strong>归档、提取都是</strong>相对路径</li><li><strong>归档tar，归档压缩tgz、tbz</strong></li></ul><p><img src="https://i.loli.net/2021/05/23/Y64cEeFZLMUshRw.png" alt="image-20210523192843787"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">tar mode<span class="hljs-selector-attr">[options]</span> pathname<br>tar cf playground<span class="hljs-selector-class">.tar</span> playground<span class="hljs-comment">//为playgorund归档，f选项为指定名称</span><br>tar tvf playground<span class="hljs-selector-class">.tar</span><span class="hljs-comment">//列出归档文件的详细内容</span><br></code></pre></td></tr></table></figure><ul><li>通过硬盘把一台电脑系统主目录复制到另一台电脑</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo tar cf <span class="hljs-regexp">/media/</span>BigDisk<span class="hljs-regexp">/home.tar /</span>home<span class="hljs-regexp">//</span>硬盘自动挂载在/media目录下<br><span class="hljs-regexp">//</span>卸载硬盘接入另一台计算机<br>cd <span class="hljs-regexp">//</span><span class="hljs-regexp">/提取归档是相对路径，不进入根目录就会出现/</span>home<span class="hljs-regexp">/usr/</span>home...<br>sudo tar xf <span class="hljs-regexp">/media/</span>BigDisk/home.tar<br></code></pre></td></tr></table></figure><ul><li>限制提取</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">tar xf archive.tar pathname<span class="hljs-regexp">//</span>只提取指定文件，可多指定<br>tar xf ..<span class="hljs-regexp">/playground2.tar --wildcards &#x27;home/</span>playground<span class="hljs-regexp">/dir-*/</span>file-A<span class="hljs-string">&#x27;//提取所有的fileA，--wildcards加入对通配符的支持</span><br></code></pre></td></tr></table></figure><ul><li>与find配合</li></ul><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">find</span> playground -<span class="hljs-built_in">name</span> <span class="hljs-string">&#x27;file-A&#x27;</span> -<span class="hljs-built_in">exec</span> tar rvf playground.tar <span class="hljs-string">&#x27;&#123;&#125;&#x27;</span> <span class="hljs-string">&#x27;+&#x27;</span><span class="hljs-comment">//以追加模式（r）调用tar，将查找到的所有文件添加进来</span><br></code></pre></td></tr></table></figure><p>可以通过find查找更新的文件，创建上一次归档之后出现的那些文件的归档</p><ul><li>利用标准输入输出</li></ul><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">find</span> playground -<span class="hljs-built_in">name</span> <span class="hljs-string">&#x27;file-A&#x27;</span> | tar cvf - --files-<span class="hljs-keyword">from</span>=- | gzip &gt; playground.tgz<span class="hljs-comment">//先用find匹配文件列表，通过管道线传给tar，“-”为标准输入输出的惯例，--files-from (也可以写为-T)使其从文件中而不是命令行中读取文件列表，最后传给gzip压缩</span><br><span class="hljs-built_in">find</span> playground -<span class="hljs-built_in">name</span> <span class="hljs-string">&#x27;file-A&#x27;</span> | tar czf playground.tgz -T -<span class="hljs-comment">//简化命令，通过z选项指定gzip压缩，j选项可有指定bzip2压缩（文件后缀改为tbz）</span><br></code></pre></td></tr></table></figure><ul><li>通过ssh打包远程主机文件</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ssh remote-sys <span class="hljs-string">&#x27;tar cf - Documents&#x27;</span> | tar xf -<span class="hljs-regexp">//</span>在远程主机上执行tar命令，标准输出传到本地主机，本地主机把标准输出提取（x命令）<br></code></pre></td></tr></table></figure><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><ul><li>zip既能压缩也能归档（gzip、bzip2在linux上才是主流）</li><li>zip与tar不同之处在于，如果内容已存在（同名），zip是<strong>添加新文件并且替换</strong>，而tar是<strong>直接替换</strong></li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">zip</span> options zipfile <span class="hljs-keyword">file</span><br><span class="hljs-keyword">zip</span> -r playground.<span class="hljs-keyword">zip</span> playground <span class="hljs-comment">//不加入递归（-r)则只保留目录不包含内容</span><br>unzip playground.<span class="hljs-keyword">zip</span><span class="hljs-comment">//提取并解压缩</span><br>unzip -<span class="hljs-keyword">l</span> playground.<span class="hljs-keyword">zip</span> playground/<span class="hljs-keyword">dir</span>-087/<span class="hljs-keyword">file</span>-Z<span class="hljs-comment">//指定文件-l选项只列出不提取解压缩</span><br></code></pre></td></tr></table></figure><ul><li>zip 的标准输入输出（unzip不接受标准输入）</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">find playground -name <span class="hljs-string">&quot;file-A&quot;</span> | <span class="hljs-keyword">zip</span> -@ <span class="hljs-keyword">file</span>-A.<span class="hljs-keyword">zip</span><span class="hljs-comment">//-@选项将文件名列表传给zip</span><br><span class="hljs-keyword">ls</span> -<span class="hljs-keyword">l</span> /etc/ | <span class="hljs-keyword">zip</span> <span class="hljs-keyword">ls</span>-etc.<span class="hljs-keyword">zip</span> -<span class="hljs-comment">//结尾的“-”是标准输入</span><br>unzip -p <span class="hljs-keyword">ls</span>-etc.<span class="hljs-keyword">zip</span> | less<span class="hljs-comment">//将unzip结果发送到标准输出</span><br></code></pre></td></tr></table></figure><h2 id="19-3-同步文件与目录"><a href="#19-3-同步文件与目录" class="headerlink" title="19.3 同步文件与目录"></a>19.3 同步文件与目录</h2><ul><li>rsync 远程更新协议</li><li>这里 source 和 destination 是下列选项之一：<br>• 一个本地文件或目录<br>• 一个远端文件或目录，以 [user@]host:path的形式存在<br>• 一个远端 rsync 服务器，由rsync://[user@]host[:port]/path指定</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">rsync <span class="hljs-keyword">options</span> <span class="hljs-keyword">source</span> destination<br>rsync -av playground foo<span class="hljs-comment">//playground的所有内容包括自身都同步到foo中（-a表示递归且保留文件属性，-v显示详细）</span><br>rsync <span class="hljs-keyword">source</span><span class="hljs-regexp">/ destination/</span><span class="hljs-regexp">/source下的所有文件不包括自身被同步，只复制目录不复制目录本身</span><br></code></pre></td></tr></table></figure><ul><li>硬盘备份</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">mkdir <span class="hljs-string">/media/BigDisk/backup</span><br>sudo rsync -av <span class="hljs-params">--delete</span> <span class="hljs-string">/etc</span> <span class="hljs-string">/home</span> <span class="hljs-string">/usr/local</span> <span class="hljs-string">/media/BigDisk/bcakup</span><span class="hljs-string">//</span>添加<span class="hljs-params">--delete</span>选项，用于删除存在于备份设备而原设备不存在的文件<br><span class="hljs-string">//</span> <span class="hljs-keyword">alias</span> backup=&#x27;sudo rsync -av <span class="hljs-params">--delete</span> <span class="hljs-string">/etc</span> <span class="hljs-string">/home</span> <span class="hljs-string">/usr/local</span> <span class="hljs-string">/media/BigDisk/bcakup</span>&#x27;定义别名备份更方便<br></code></pre></td></tr></table></figure><ul><li>在网络上使用rsync</li><li>方法一</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sudo rsync -av <span class="hljs-params">--delete</span> <span class="hljs-params">--rsh=ssh</span> <span class="hljs-string">/etc</span> <span class="hljs-string">/home</span> <span class="hljs-string">/usr/local</span> remote-sys:<span class="hljs-string">/backup</span><br><span class="hljs-string">//</span>加入<span class="hljs-params">--rsh=ssh</span>选项，用于指示rsync用远程shell备份<br></code></pre></td></tr></table></figure><ul><li>方法二</li></ul><p><img src="https://i.loli.net/2021/05/23/DAYV8THo1N9gKIm.png" alt="image-20210523210628205"></p><h1 id="20-正则表达式"><a href="#20-正则表达式" class="headerlink" title="20.正则表达式"></a>20.正则表达式</h1><p><a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md">https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md</a></p><p><img src="https://i.loli.net/2021/06/02/QUbws2cA1TvhLma.png" alt="image-20210602211824794"></p><h1 id="21-文本处理"><a href="#21-文本处理" class="headerlink" title="21. 文本处理"></a>21. 文本处理</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1.引言&quot;&gt;&lt;/a&gt;1.引言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;人们说，“图形用户界面让简单的任务更容易完成，而命令行界面使 完成复杂的任务成为可能”，到现在这句话仍然很正确。</summary>
      
    
    
    
    
  </entry>
  
</feed>
